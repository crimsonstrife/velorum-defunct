// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/AdvKitRuntime.h"
#include "AdvKitRuntime.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeAdvKitRuntime() {}
	void UAdvKitOrientationComponent::StaticRegisterNativesUAdvKitOrientationComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitOrientationComponent::StaticClass(), "SetOrientation",(Native)&UAdvKitOrientationComponent::execSetOrientation);
	}
	IMPLEMENT_CLASS(UAdvKitOrientationComponent, 4208144500);
static class UEnum* EAdvKitMovementMode_StaticEnum()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode();
		Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitMovementMode"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitMovementMode(EAdvKitMovementMode_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitMovementMode"), false, nullptr, nullptr);
class UScriptStruct* FAdvKitMovementProperties::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitMovementProperties();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FAdvKitMovementProperties_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAdvKitMovementProperties, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("AdvKitMovementProperties"), sizeof(FAdvKitMovementProperties), Get_Z_Construct_UScriptStruct_FAdvKitMovementProperties_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAdvKitMovementProperties(FAdvKitMovementProperties::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("AdvKitMovementProperties"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitMovementProperties
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitMovementProperties()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AdvKitMovementProperties")),new UScriptStruct::TCppStructOps<FAdvKitMovementProperties>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitMovementProperties;
	void UAdvKitCharacterMovementComponent::StaticRegisterNativesUAdvKitCharacterMovementComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "AccumulateRootMotion",(Native)&UAdvKitCharacterMovementComponent::execAccumulateRootMotion);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "CanTransition",(Native)&UAdvKitCharacterMovementComponent::execCanTransition);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "ChangeTargetBalance",(Native)&UAdvKitCharacterMovementComponent::execChangeTargetBalance);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetAdvCustomMovementMode",(Native)&UAdvKitCharacterMovementComponent::execGetAdvCustomMovementMode);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetAdvMovementMode",(Native)&UAdvKitCharacterMovementComponent::execGetAdvMovementMode);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetDesiredOffsetFromZone",(Native)&UAdvKitCharacterMovementComponent::execGetDesiredOffsetFromZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetDesiredRotationInZone",(Native)&UAdvKitCharacterMovementComponent::execGetDesiredRotationInZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetGlobalLocationInZone",(Native)&UAdvKitCharacterMovementComponent::execGetGlobalLocationInZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetHalfExtentForZone",(Native)&UAdvKitCharacterMovementComponent::execGetHalfExtentForZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetPossibleTransition",(Native)&UAdvKitCharacterMovementComponent::execGetPossibleTransition);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetZone",(Native)&UAdvKitCharacterMovementComponent::execGetZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "GetZoneLocation",(Native)&UAdvKitCharacterMovementComponent::execGetZoneLocation);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "JumpUpZone",(Native)&UAdvKitCharacterMovementComponent::execJumpUpZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "LetGoOfZone",(Native)&UAdvKitCharacterMovementComponent::execLetGoOfZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "MoveLocationInZone",(Native)&UAdvKitCharacterMovementComponent::execMoveLocationInZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "PhysMoveInZone",(Native)&UAdvKitCharacterMovementComponent::execPhysMoveInZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "SetAdvMovementMode",(Native)&UAdvKitCharacterMovementComponent::execSetAdvMovementMode);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterMovementComponent::StaticClass(), "TryToTransition",(Native)&UAdvKitCharacterMovementComponent::execTryToTransition);
	}
	IMPLEMENT_CLASS(UAdvKitCharacterMovementComponent, 1797203781);
	void UAdvKitCharacterAction_Arguments::StaticRegisterNativesUAdvKitCharacterAction_Arguments()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction_Arguments::StaticClass(), "CreateArguments",(Native)&UAdvKitCharacterAction_Arguments::execCreateArguments);
	}
	IMPLEMENT_CLASS(UAdvKitCharacterAction_Arguments, 1331753375);
static class UEnum* EAdvKitActionResponseType_StaticEnum()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitActionResponseType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitActionResponseType(EAdvKitActionResponseType_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitActionResponseType"), false, nullptr, nullptr);
class UScriptStruct* FAdvKitActionResponse::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitActionResponse();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FAdvKitActionResponse_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAdvKitActionResponse, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("AdvKitActionResponse"), sizeof(FAdvKitActionResponse), Get_Z_Construct_UScriptStruct_FAdvKitActionResponse_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAdvKitActionResponse(FAdvKitActionResponse::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("AdvKitActionResponse"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitActionResponse
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitActionResponse()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AdvKitActionResponse")),new UScriptStruct::TCppStructOps<FAdvKitActionResponse>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitActionResponse;
	bool UAdvKitCharacterAction::CanBeInterruptedBy(const UAdvKitCharacterAction* Other) const
	{
		AdvKitCharacterAction_eventCanBeInterruptedBy_Parms Parms;
		Parms.Other=Other;
		const_cast<UAdvKitCharacterAction*>(this)->ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanBeInterruptedBy),&Parms);
		return !!Parms.ReturnValue;
	}
	bool UAdvKitCharacterAction::CanInterrupt(const UAdvKitCharacterAction* Other) const
	{
		AdvKitCharacterAction_eventCanInterrupt_Parms Parms;
		Parms.Other=Other;
		const_cast<UAdvKitCharacterAction*>(this)->ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanInterrupt),&Parms);
		return !!Parms.ReturnValue;
	}
	TArray<TSubclassOf<UAdvKitCharacterAction> > UAdvKitCharacterAction::GetAdditionalRequiredActions()
	{
		AdvKitCharacterAction_eventGetAdditionalRequiredActions_Parms Parms;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GetAdditionalRequiredActions),&Parms);
		return Parms.ReturnValue;
	}
	void UAdvKitCharacterAction::OnMontageEnded(UAnimMontage* EndedMontage, bool bInterrupted)
	{
		AdvKitCharacterAction_eventOnMontageEnded_Parms Parms;
		Parms.EndedMontage=EndedMontage;
		Parms.bInterrupted=bInterrupted ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnMontageEnded),&Parms);
	}
	FAdvKitActionResponse UAdvKitCharacterAction::Start(UAdvKitCharacterAction_Arguments* Arguments, UAdvKitCharacterAction* InterruptedOther)
	{
		AdvKitCharacterAction_eventStart_Parms Parms;
		Parms.Arguments=Arguments;
		Parms.InterruptedOther=InterruptedOther;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_Start),&Parms);
		return Parms.ReturnValue;
	}
	FAdvKitActionResponse UAdvKitCharacterAction::Stop(const UAdvKitCharacterAction* InterruptedBy)
	{
		AdvKitCharacterAction_eventStop_Parms Parms;
		Parms.InterruptedBy=InterruptedBy;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_Stop),&Parms);
		return Parms.ReturnValue;
	}
	void UAdvKitCharacterAction::StaticRegisterNativesUAdvKitCharacterAction()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "CanBeInterruptedBy",(Native)&UAdvKitCharacterAction::execCanBeInterruptedBy);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "CanInterrupt",(Native)&UAdvKitCharacterAction::execCanInterrupt);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "Failed",(Native)&UAdvKitCharacterAction::execFailed);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "GetAdditionalRequiredActions",(Native)&UAdvKitCharacterAction::execGetAdditionalRequiredActions);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "OnMontageEnded",(Native)&UAdvKitCharacterAction::execOnMontageEnded);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "PlayAnimMontage",(Native)&UAdvKitCharacterAction::execPlayAnimMontage);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "Redirect",(Native)&UAdvKitCharacterAction::execRedirect);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "Start",(Native)&UAdvKitCharacterAction::execStart);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "Stop",(Native)&UAdvKitCharacterAction::execStop);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCharacterAction::StaticClass(), "Succeeded",(Native)&UAdvKitCharacterAction::execSucceeded);
	}
	IMPLEMENT_CLASS(UAdvKitCharacterAction, 2472216674);
static class UEnum* EAdvKitCameraType_StaticEnum()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitCameraType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitCameraType(EAdvKitCameraType_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitCameraType"), false, nullptr, nullptr);
class UScriptStruct* FRepAdvKitAnimMontage::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FRepAdvKitAnimMontage();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FRepAdvKitAnimMontage_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRepAdvKitAnimMontage, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("RepAdvKitAnimMontage"), sizeof(FRepAdvKitAnimMontage), Get_Z_Construct_UScriptStruct_FRepAdvKitAnimMontage_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRepAdvKitAnimMontage(FRepAdvKitAnimMontage::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("RepAdvKitAnimMontage"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFRepAdvKitAnimMontage
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFRepAdvKitAnimMontage()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RepAdvKitAnimMontage")),new UScriptStruct::TCppStructOps<FRepAdvKitAnimMontage>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFRepAdvKitAnimMontage;
class UScriptStruct* FAdvKitInventoryConfig::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitInventoryConfig();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FAdvKitInventoryConfig_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAdvKitInventoryConfig, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("AdvKitInventoryConfig"), sizeof(FAdvKitInventoryConfig), Get_Z_Construct_UScriptStruct_FAdvKitInventoryConfig_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAdvKitInventoryConfig(FAdvKitInventoryConfig::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("AdvKitInventoryConfig"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitInventoryConfig
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitInventoryConfig()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AdvKitInventoryConfig")),new UScriptStruct::TCppStructOps<FAdvKitInventoryConfig>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitInventoryConfig;
	float AAdvKitCharacter::BlockAnyDamage(float DamageReceived, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser)
	{
		AdvKitCharacter_eventBlockAnyDamage_Parms Parms;
		Parms.DamageReceived=DamageReceived;
		Parms.DamageType=DamageType;
		Parms.InstigatedBy=InstigatedBy;
		Parms.DamageCauser=DamageCauser;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_BlockAnyDamage),&Parms);
		return Parms.ReturnValue;
	}
	float AAdvKitCharacter::BlockPointDamage(float DamageReceived, const UDamageType* DamageType, FVector HitLocation, FVector HitNormal, UPrimitiveComponent* HitComponent, FName BoneName, FVector ShotFromDirection, AController* InstigatedBy, AActor* DamageCauser)
	{
		AdvKitCharacter_eventBlockPointDamage_Parms Parms;
		Parms.DamageReceived=DamageReceived;
		Parms.DamageType=DamageType;
		Parms.HitLocation=HitLocation;
		Parms.HitNormal=HitNormal;
		Parms.HitComponent=HitComponent;
		Parms.BoneName=BoneName;
		Parms.ShotFromDirection=ShotFromDirection;
		Parms.InstigatedBy=InstigatedBy;
		Parms.DamageCauser=DamageCauser;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_BlockPointDamage),&Parms);
		return Parms.ReturnValue;
	}
	float AAdvKitCharacter::BlockRadialDamage(float DamageReceived, const UDamageType* DamageType, FVector Origin, const FHitResult& HitInfo, AController* InstigatedBy, AActor* DamageCauser)
	{
		AdvKitCharacter_eventBlockRadialDamage_Parms Parms;
		Parms.DamageReceived=DamageReceived;
		Parms.DamageType=DamageType;
		Parms.Origin=Origin;
		Parms.HitInfo=HitInfo;
		Parms.InstigatedBy=InstigatedBy;
		Parms.DamageCauser=DamageCauser;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_BlockRadialDamage),&Parms);
		return Parms.ReturnValue;
	}
	void AAdvKitCharacter::Died(AController* Killer, const FDamageEvent& DamageEvent, FVector HitLocation)
	{
		AdvKitCharacter_eventDied_Parms Parms;
		Parms.Killer=Killer;
		Parms.DamageEvent=DamageEvent;
		Parms.HitLocation=HitLocation;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_Died),&Parms);
	}
	void AAdvKitCharacter::Dodge()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_Dodge),NULL);
	}
	void AAdvKitCharacter::DodgeServer()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_DodgeServer),NULL);
	}
	void AAdvKitCharacter::EnterZoneServer(AAdvKitZone* NewZone)
	{
		AdvKitCharacter_eventEnterZoneServer_Parms Parms;
		Parms.NewZone=NewZone;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_EnterZoneServer),&Parms);
	}
	bool AAdvKitCharacter::IsAlive()
	{
		AdvKitCharacter_eventIsAlive_Parms Parms;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_IsAlive),&Parms);
		return !!Parms.ReturnValue;
	}
	bool AAdvKitCharacter::IsDodging() const
	{
		AdvKitCharacter_eventIsDodging_Parms Parms;
		const_cast<AAdvKitCharacter*>(this)->ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_IsDodging),&Parms);
		return !!Parms.ReturnValue;
	}
	void AAdvKitCharacter::PlayAnimMontageServer(UAnimMontage* AnimMontage, float InPlayRate, FName StartSectionName)
	{
		AdvKitCharacter_eventPlayAnimMontageServer_Parms Parms;
		Parms.AnimMontage=AnimMontage;
		Parms.InPlayRate=InPlayRate;
		Parms.StartSectionName=StartSectionName;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_PlayAnimMontageServer),&Parms);
	}
	void AAdvKitCharacter::ServerUse(AAdvKitUsable* Useable, AAdvKitInventoryItem* WithItem)
	{
		AdvKitCharacter_eventServerUse_Parms Parms;
		Parms.Useable=Useable;
		Parms.WithItem=WithItem;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_ServerUse),&Parms);
	}
	void AAdvKitCharacter::SetCameraModeServer(EAdvKitCameraType NewMode)
	{
		AdvKitCharacter_eventSetCameraModeServer_Parms Parms;
		Parms.NewMode=NewMode;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_SetCameraModeServer),&Parms);
	}
	void AAdvKitCharacter::SetFirstPersonEnabledServer(bool bEnabled)
	{
		AdvKitCharacter_eventSetFirstPersonEnabledServer_Parms Parms;
		Parms.bEnabled=bEnabled ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_SetFirstPersonEnabledServer),&Parms);
	}
	void AAdvKitCharacter::SetZoneLocationServer(UAdvKitZoneLocation* NewLocation, bool bSnap)
	{
		AdvKitCharacter_eventSetZoneLocationServer_Parms Parms;
		Parms.NewLocation=NewLocation;
		Parms.bSnap=bSnap ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_SetZoneLocationServer),&Parms);
	}
	void AAdvKitCharacter::SetZoneServer(AAdvKitZone* NewZone, bool bSnap)
	{
		AdvKitCharacter_eventSetZoneServer_Parms Parms;
		Parms.NewZone=NewZone;
		Parms.bSnap=bSnap ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_SetZoneServer),&Parms);
	}
	void AAdvKitCharacter::StaticRegisterNativesAAdvKitCharacter()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "AddConditionalMovementInput",(Native)&AAdvKitCharacter::execAddConditionalMovementInput);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "BlockAnyDamage",(Native)&AAdvKitCharacter::execBlockAnyDamage);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "BlockDamage",(Native)&AAdvKitCharacter::execBlockDamage);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "BlockPointDamage",(Native)&AAdvKitCharacter::execBlockPointDamage);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "BlockRadialDamage",(Native)&AAdvKitCharacter::execBlockRadialDamage);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "CanEnterZone",(Native)&AAdvKitCharacter::execCanEnterZone);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "Died",(Native)&AAdvKitCharacter::execDied);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "Dodge",(Native)&AAdvKitCharacter::execDodge);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "DodgeServer",(Native)&AAdvKitCharacter::execDodgeServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "EnterZone",(Native)&AAdvKitCharacter::execEnterZone);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "EnterZoneServer",(Native)&AAdvKitCharacter::execEnterZoneServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetActiveAction",(Native)&AAdvKitCharacter::execGetActiveAction);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetAdvMovementComponent",(Native)&AAdvKitCharacter::execGetAdvMovementComponent);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetAimOffsets",(Native)&AAdvKitCharacter::execGetAimOffsets);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetAllAvailableTargets",(Native)&AAdvKitCharacter::execGetAllAvailableTargets);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetCameraMode",(Native)&AAdvKitCharacter::execGetCameraMode);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetZone",(Native)&AAdvKitCharacter::execGetZone);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "GetZoneLocation",(Native)&AAdvKitCharacter::execGetZoneLocation);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "IsAlive",(Native)&AAdvKitCharacter::execIsAlive);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "IsDodging",(Native)&AAdvKitCharacter::execIsDodging);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "IsFirstPerson",(Native)&AAdvKitCharacter::execIsFirstPerson);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "IsShoulderCam",(Native)&AAdvKitCharacter::execIsShoulderCam);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "IsThirdPerson",(Native)&AAdvKitCharacter::execIsThirdPerson);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "NextCamera",(Native)&AAdvKitCharacter::execNextCamera);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "NextItem",(Native)&AAdvKitCharacter::execNextItem);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "OnRep_RepAnimMontage",(Native)&AAdvKitCharacter::execOnRep_RepAnimMontage);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "PlayAnimMontageServer",(Native)&AAdvKitCharacter::execPlayAnimMontageServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "PreviousItem",(Native)&AAdvKitCharacter::execPreviousItem);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "Reload",(Native)&AAdvKitCharacter::execReload);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "ServerUse",(Native)&AAdvKitCharacter::execServerUse);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetCameraMode",(Native)&AAdvKitCharacter::execSetCameraMode);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetCameraModeServer",(Native)&AAdvKitCharacter::execSetCameraModeServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetFirstPersonEnabledServer",(Native)&AAdvKitCharacter::execSetFirstPersonEnabledServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetMouseCursorEnabled",(Native)&AAdvKitCharacter::execSetMouseCursorEnabled);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetTarget",(Native)&AAdvKitCharacter::execSetTarget);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetZone",(Native)&AAdvKitCharacter::execSetZone);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetZoneLocation",(Native)&AAdvKitCharacter::execSetZoneLocation);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetZoneLocationServer",(Native)&AAdvKitCharacter::execSetZoneLocationServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "SetZoneServer",(Native)&AAdvKitCharacter::execSetZoneServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "StartAction",(Native)&AAdvKitCharacter::execStartAction);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "StartFire",(Native)&AAdvKitCharacter::execStartFire);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "StartTransitionActionTo",(Native)&AAdvKitCharacter::execStartTransitionActionTo);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "StopFire",(Native)&AAdvKitCharacter::execStopFire);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "Use",(Native)&AAdvKitCharacter::execUse);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacter::StaticClass(), "UseClosestUseable",(Native)&AAdvKitCharacter::execUseClosestUseable);
	}
	IMPLEMENT_CLASS(AAdvKitCharacter, 4043323548);
	bool AAdvKitGravityCharacter::CanWallWalkOn(FFindFloorResult NewFloor)
	{
		AdvKitGravityCharacter_eventCanWallWalkOn_Parms Parms;
		Parms.NewFloor=NewFloor;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanWallWalkOn),&Parms);
		return !!Parms.ReturnValue;
	}
	void AAdvKitGravityCharacter::SetNewOrientationServer(FVector GravityUpVector, FVector Origin, bool bForce)
	{
		AdvKitGravityCharacter_eventSetNewOrientationServer_Parms Parms;
		Parms.GravityUpVector=GravityUpVector;
		Parms.Origin=Origin;
		Parms.bForce=bForce ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_SetNewOrientationServer),&Parms);
	}
	void AAdvKitGravityCharacter::StaticRegisterNativesAAdvKitGravityCharacter()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitGravityCharacter::StaticClass(), "CanWallWalkOn",(Native)&AAdvKitGravityCharacter::execCanWallWalkOn);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitGravityCharacter::StaticClass(), "GetAdvGravityMovementComponent",(Native)&AAdvKitGravityCharacter::execGetAdvGravityMovementComponent);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitGravityCharacter::StaticClass(), "SetNewOrientation",(Native)&AAdvKitGravityCharacter::execSetNewOrientation);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitGravityCharacter::StaticClass(), "SetNewOrientationServer",(Native)&AAdvKitGravityCharacter::execSetNewOrientationServer);
	}
	IMPLEMENT_CLASS(AAdvKitGravityCharacter, 4162007366);
	void UAdvKitCA_Dodge::StaticRegisterNativesUAdvKitCA_Dodge()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Dodge, 3028746915);
	void UAdvKitCharacterActionSingleAnimation::StaticRegisterNativesUAdvKitCharacterActionSingleAnimation()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCharacterActionSingleAnimation, 2883734284);
class UScriptStruct* FAdvKitPhysicsTransition::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitPhysicsTransition();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FAdvKitPhysicsTransition_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAdvKitPhysicsTransition, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("AdvKitPhysicsTransition"), sizeof(FAdvKitPhysicsTransition), Get_Z_Construct_UScriptStruct_FAdvKitPhysicsTransition_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAdvKitPhysicsTransition(FAdvKitPhysicsTransition::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("AdvKitPhysicsTransition"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitPhysicsTransition
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitPhysicsTransition()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AdvKitPhysicsTransition")),new UScriptStruct::TCppStructOps<FAdvKitPhysicsTransition>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitPhysicsTransition;
	void UAdvKitCA_PhysicsTransition::StaticRegisterNativesUAdvKitCA_PhysicsTransition()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_PhysicsTransition, 4291474683);
	void UAdvKitCA_ZoneLocationSwitch::StaticRegisterNativesUAdvKitCA_ZoneLocationSwitch()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneLocationSwitch, 2517451082);
	UAnimMontage* UAdvKitCA_ZoneTransition::GetMontageToPlay()
	{
		AdvKitCA_ZoneTransition_eventGetMontageToPlay_Parms Parms;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GetMontageToPlay),&Parms);
		return Parms.ReturnValue;
	}
	void UAdvKitCA_ZoneTransition::StaticRegisterNativesUAdvKitCA_ZoneTransition()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitCA_ZoneTransition::StaticClass(), "GetMontageToPlay",(Native)&UAdvKitCA_ZoneTransition::execGetMontageToPlay);
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneTransition, 3944741106);
class UScriptStruct* FDirectionalMontage::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FDirectionalMontage();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FDirectionalMontage_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FDirectionalMontage, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("DirectionalMontage"), sizeof(FDirectionalMontage), Get_Z_Construct_UScriptStruct_FDirectionalMontage_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FDirectionalMontage(FDirectionalMontage::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("DirectionalMontage"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFDirectionalMontage
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFDirectionalMontage()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("DirectionalMontage")),new UScriptStruct::TCppStructOps<FDirectionalMontage>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFDirectionalMontage;
	void UAdvKitCA_ZoneTransition_Directional::StaticRegisterNativesUAdvKitCA_ZoneTransition_Directional()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneTransition_Directional, 837341618);
	void UAdvKitCA_ZoneTransition_LocationSwitch::StaticRegisterNativesUAdvKitCA_ZoneTransition_LocationSwitch()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneTransition_LocationSwitch, 1511614824);
class UScriptStruct* FTransitionLocation::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FTransitionLocation();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FTransitionLocation_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FTransitionLocation, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("TransitionLocation"), sizeof(FTransitionLocation), Get_Z_Construct_UScriptStruct_FTransitionLocation_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FTransitionLocation(FTransitionLocation::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("TransitionLocation"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFTransitionLocation
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFTransitionLocation()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("TransitionLocation")),new UScriptStruct::TCppStructOps<FTransitionLocation>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFTransitionLocation;
	void UAnimNotifyState_TransitionCorrection::StaticRegisterNativesUAnimNotifyState_TransitionCorrection()
	{
	}
	IMPLEMENT_CLASS(UAnimNotifyState_TransitionCorrection, 642247813);
	void UAdvKitCA_ZoneTransition_NoAnim::StaticRegisterNativesUAdvKitCA_ZoneTransition_NoAnim()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneTransition_NoAnim, 2463322631);
	void UAdvKitCA_ZoneTransition_SingleAnim::StaticRegisterNativesUAdvKitCA_ZoneTransition_SingleAnim()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneTransition_SingleAnim, 725818269);
	void UAdvKitCharacterActionPhysics::StaticRegisterNativesUAdvKitCharacterActionPhysics()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCharacterActionPhysics, 2027169022);
	void UAdvKitCA_UseSwitch::StaticRegisterNativesUAdvKitCA_UseSwitch()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_UseSwitch, 2058931636);
	void UAdvKitCA_Dodge_Arguments::StaticRegisterNativesUAdvKitCA_Dodge_Arguments()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Dodge_Arguments, 922000079);
	void UAdvKitCA_PhysicsTransition_Arguments::StaticRegisterNativesUAdvKitCA_PhysicsTransition_Arguments()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_PhysicsTransition_Arguments, 1918403853);
	void UAdvKitCA_UseSwitch_Arguments::StaticRegisterNativesUAdvKitCA_UseSwitch_Arguments()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_UseSwitch_Arguments, 1895595330);
	void UAdvKitCA_ZoneTransition_Arguments::StaticRegisterNativesUAdvKitCA_ZoneTransition_Arguments()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_ZoneTransition_Arguments, 1682514311);
	void UAdvKitCharacterAction_CharacterModifier::StaticRegisterNativesUAdvKitCharacterAction_CharacterModifier()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCharacterAction_CharacterModifier, 942231532);
	void UAdvKitCA_Mod_Auto_MovementMode::StaticRegisterNativesUAdvKitCA_Mod_Auto_MovementMode()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Mod_Auto_MovementMode, 2869751228);
class UScriptStruct* FResponseConfig::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FResponseConfig();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FResponseConfig_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FResponseConfig, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("ResponseConfig"), sizeof(FResponseConfig), Get_Z_Construct_UScriptStruct_FResponseConfig_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FResponseConfig(FResponseConfig::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("ResponseConfig"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFResponseConfig
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFResponseConfig()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("ResponseConfig")),new UScriptStruct::TCppStructOps<FResponseConfig>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFResponseConfig;
	void UAdvKitCA_Mod_Collision::StaticRegisterNativesUAdvKitCA_Mod_Collision()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Mod_Collision, 2154160970);
	void UAdvKitCA_Mod_Item::StaticRegisterNativesUAdvKitCA_Mod_Item()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Mod_Item, 522684369);
	void UAdvKitCA_Mod_MovementMode::StaticRegisterNativesUAdvKitCA_Mod_MovementMode()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Mod_MovementMode, 358217846);
	void UAdvKitCA_Mod_OrientationToZone::StaticRegisterNativesUAdvKitCA_Mod_OrientationToZone()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Mod_OrientationToZone, 3439117587);
	void UAdvKitCA_Mod_YawRotationBind::StaticRegisterNativesUAdvKitCA_Mod_YawRotationBind()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCA_Mod_YawRotationBind, 3187387655);
	void UAdvKitCharacterAction_StateConfiguration::StaticRegisterNativesUAdvKitCharacterAction_StateConfiguration()
	{
	}
	IMPLEMENT_CLASS(UAdvKitCharacterAction_StateConfiguration, 20851986);
	void AAdvKitCharacterActionManager::StartActionServer(TSubclassOf<UAdvKitCharacterAction>  ActionClass, UAdvKitCharacterAction_Arguments* Arguments)
	{
		AdvKitCharacterActionManager_eventStartActionServer_Parms Parms;
		Parms.ActionClass=ActionClass;
		Parms.Arguments=Arguments;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartActionServer),&Parms);
	}
	void AAdvKitCharacterActionManager::StaticRegisterNativesAAdvKitCharacterActionManager()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitCharacterActionManager::StaticClass(), "StartActionServer",(Native)&AAdvKitCharacterActionManager::execStartActionServer);
	}
	IMPLEMENT_CLASS(AAdvKitCharacterActionManager, 968014108);
	void UAdvKitGravityCharacterMovementComponent::StaticRegisterNativesUAdvKitGravityCharacterMovementComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitGravityCharacterMovementComponent::StaticClass(), "OnOrientationChanged",(Native)&UAdvKitGravityCharacterMovementComponent::execOnOrientationChanged);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitGravityCharacterMovementComponent::StaticClass(), "SetGravityVector",(Native)&UAdvKitGravityCharacterMovementComponent::execSetGravityVector);
	}
	IMPLEMENT_CLASS(UAdvKitGravityCharacterMovementComponent, 1376154939);
static class UEnum* EAdvKitRifleFireType_StaticEnum()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitRifleFireType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitRifleFireType(EAdvKitRifleFireType_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitRifleFireType"), false, nullptr, nullptr);
	void UAdvKitFireModeConfiguration::StaticRegisterNativesUAdvKitFireModeConfiguration()
	{
	}
	IMPLEMENT_CLASS(UAdvKitFireModeConfiguration, 2994564419);
class UScriptStruct* FFootStepSound::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FFootStepSound();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FFootStepSound_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FFootStepSound, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("FootStepSound"), sizeof(FFootStepSound), Get_Z_Construct_UScriptStruct_FFootStepSound_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FFootStepSound(FFootStepSound::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("FootStepSound"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFFootStepSound
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFFootStepSound()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("FootStepSound")),new UScriptStruct::TCppStructOps<FFootStepSound>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFFootStepSound;
	void UAdvKitFootstepComponent::PlayFootstep(int32 Foot)
	{
		AdvKitFootstepComponent_eventPlayFootstep_Parms Parms;
		Parms.Foot=Foot;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_PlayFootstep),&Parms);
	}
	UAudioComponent* UAdvKitFootstepComponent::PlayFootstepAttached(int32 Foot)
	{
		AdvKitFootstepComponent_eventPlayFootstepAttached_Parms Parms;
		Parms.Foot=Foot;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_PlayFootstepAttached),&Parms);
		return Parms.ReturnValue;
	}
	void UAdvKitFootstepComponent::StaticRegisterNativesUAdvKitFootstepComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitFootstepComponent::StaticClass(), "PlayFootstep",(Native)&UAdvKitFootstepComponent::execPlayFootstep);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitFootstepComponent::StaticClass(), "PlayFootstepAttached",(Native)&UAdvKitFootstepComponent::execPlayFootstepAttached);
	}
	IMPLEMENT_CLASS(UAdvKitFootstepComponent, 1298222213);
	void AAdvKitGameMode::StaticRegisterNativesAAdvKitGameMode()
	{
	}
	IMPLEMENT_CLASS(AAdvKitGameMode, 2540190019);
static class UEnum* EAdvKitInventoryState_StaticEnum()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState();
		Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitInventoryState"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitInventoryState(EAdvKitInventoryState_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitInventoryState"), false, nullptr, nullptr);
class UScriptStruct* FRepAdvKitInventoryState::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FRepAdvKitInventoryState();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FRepAdvKitInventoryState_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRepAdvKitInventoryState, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("RepAdvKitInventoryState"), sizeof(FRepAdvKitInventoryState), Get_Z_Construct_UScriptStruct_FRepAdvKitInventoryState_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRepAdvKitInventoryState(FRepAdvKitInventoryState::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("RepAdvKitInventoryState"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFRepAdvKitInventoryState
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFRepAdvKitInventoryState()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RepAdvKitInventoryState")),new UScriptStruct::TCppStructOps<FRepAdvKitInventoryState>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFRepAdvKitInventoryState;
	void AAdvKitInventoryItem::AttachToCharacter()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_AttachToCharacter),NULL);
	}
	bool AAdvKitInventoryItem::CanBeCombinedWith(AAdvKitInventoryItem* With)
	{
		AdvKitInventoryItem_eventCanBeCombinedWith_Parms Parms;
		Parms.With=With;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanBeCombinedWith),&Parms);
		return !!Parms.ReturnValue;
	}
	bool AAdvKitInventoryItem::CanEquip(bool bInstant)
	{
		AdvKitInventoryItem_eventCanEquip_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanEquip),&Parms);
		return !!Parms.ReturnValue;
	}
	bool AAdvKitInventoryItem::CanUneqiup(bool bInstant)
	{
		AdvKitInventoryItem_eventCanUneqiup_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanUneqiup),&Parms);
		return !!Parms.ReturnValue;
	}
	AAdvKitInventoryItem* AAdvKitInventoryItem::CombinedWith(AAdvKitInventoryItem* With)
	{
		AdvKitInventoryItem_eventCombinedWith_Parms Parms;
		Parms.With=With;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CombinedWith),&Parms);
		return Parms.ReturnValue;
	}
	void AAdvKitInventoryItem::DetachFromCharacter()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_DetachFromCharacter),NULL);
	}
	void AAdvKitInventoryItem::EquipServer(bool bInstant)
	{
		AdvKitInventoryItem_eventEquipServer_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_EquipServer),&Parms);
	}
	void AAdvKitInventoryItem::OnEquip(bool bInstant)
	{
		AdvKitInventoryItem_eventOnEquip_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnEquip),&Parms);
	}
	void AAdvKitInventoryItem::OnEquipped(bool bInstant)
	{
		AdvKitInventoryItem_eventOnEquipped_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnEquipped),&Parms);
	}
	void AAdvKitInventoryItem::OnUneqiup(bool bInstant)
	{
		AdvKitInventoryItem_eventOnUneqiup_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnUneqiup),&Parms);
	}
	void AAdvKitInventoryItem::OnUneqiupped(bool bInstant)
	{
		AdvKitInventoryItem_eventOnUneqiupped_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnUneqiupped),&Parms);
	}
	void AAdvKitInventoryItem::UneqiupServer(bool bInstant)
	{
		AdvKitInventoryItem_eventUneqiupServer_Parms Parms;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_UneqiupServer),&Parms);
	}
	void AAdvKitInventoryItem::StaticRegisterNativesAAdvKitInventoryItem()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "AttachToCharacter",(Native)&AAdvKitInventoryItem::execAttachToCharacter);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "CanBeCombinedWith",(Native)&AAdvKitInventoryItem::execCanBeCombinedWith);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "CanEquip",(Native)&AAdvKitInventoryItem::execCanEquip);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "CanUneqiup",(Native)&AAdvKitInventoryItem::execCanUneqiup);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "CombinedWith",(Native)&AAdvKitInventoryItem::execCombinedWith);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "DetachFromCharacter",(Native)&AAdvKitInventoryItem::execDetachFromCharacter);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "Equip",(Native)&AAdvKitInventoryItem::execEquip);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "EquipServer",(Native)&AAdvKitInventoryItem::execEquipServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "GetItemState",(Native)&AAdvKitInventoryItem::execGetItemState);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "OnEquip",(Native)&AAdvKitInventoryItem::execOnEquip);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "OnEquipped",(Native)&AAdvKitInventoryItem::execOnEquipped);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "OnRep_ItemState",(Native)&AAdvKitInventoryItem::execOnRep_ItemState);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "OnUneqiup",(Native)&AAdvKitInventoryItem::execOnUneqiup);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "OnUneqiupped",(Native)&AAdvKitInventoryItem::execOnUneqiupped);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "Uneqiup",(Native)&AAdvKitInventoryItem::execUneqiup);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryItem::StaticClass(), "UneqiupServer",(Native)&AAdvKitInventoryItem::execUneqiupServer);
	}
	IMPLEMENT_CLASS(AAdvKitInventoryItem, 2458272091);
	void AAdvKitInventorySimpleCombinable::StaticRegisterNativesAAdvKitInventorySimpleCombinable()
	{
	}
	IMPLEMENT_CLASS(AAdvKitInventorySimpleCombinable, 2493449725);
	void AAdvKitProjectile::OnImpact(const FHitResult& Impact)
	{
		AdvKitProjectile_eventOnImpact_Parms Parms;
		Parms.Impact=Impact;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnImpact),&Parms);
	}
	void AAdvKitProjectile::StaticRegisterNativesAAdvKitProjectile()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitProjectile::StaticClass(), "Init",(Native)&AAdvKitProjectile::execInit);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitProjectile::StaticClass(), "OnImpact",(Native)&AAdvKitProjectile::execOnImpact);
	}
	IMPLEMENT_CLASS(AAdvKitProjectile, 1379193683);
static class UEnum* EAdvKitWeaponState_StaticEnum()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState();
		Singleton = GetStaticEnum(Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("EAdvKitWeaponState"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAdvKitWeaponState(EAdvKitWeaponState_StaticEnum, TEXT("/Script/AdvKitRuntime"), TEXT("EAdvKitWeaponState"), false, nullptr, nullptr);
class UScriptStruct* FAdvKitWeaponState::StaticStruct()
{
	extern ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitWeaponState();
		extern ADVKITRUNTIME_API uint32 Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAdvKitWeaponState, Z_Construct_UPackage__Script_AdvKitRuntime(), TEXT("AdvKitWeaponState"), sizeof(FAdvKitWeaponState), Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAdvKitWeaponState(FAdvKitWeaponState::StaticStruct, TEXT("/Script/AdvKitRuntime"), TEXT("AdvKitWeaponState"), false, nullptr, nullptr);
static struct FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitWeaponState
{
	FScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitWeaponState()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AdvKitWeaponState")),new UScriptStruct::TCppStructOps<FAdvKitWeaponState>);
	}
} ScriptStruct_AdvKitRuntime_StaticRegisterNativesFAdvKitWeaponState;
	void AAdvKitWeapon::AddAmmunition(int32 Amount)
	{
		AdvKitWeapon_eventAddAmmunition_Parms Parms;
		Parms.Amount=Amount;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_AddAmmunition),&Parms);
	}
	float AAdvKitWeapon::BlockDamage(float Damage, const FDamageEvent& DamageEvent, AController* EventInstigator, AActor* DamageCauser)
	{
		AdvKitWeapon_eventBlockDamage_Parms Parms;
		Parms.Damage=Damage;
		Parms.DamageEvent=DamageEvent;
		Parms.EventInstigator=EventInstigator;
		Parms.DamageCauser=DamageCauser;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_BlockDamage),&Parms);
		return Parms.ReturnValue;
	}
	void AAdvKitWeapon::BlockedBy(AActor* By, float BlockedDamage)
	{
		AdvKitWeapon_eventBlockedBy_Parms Parms;
		Parms.By=By;
		Parms.BlockedDamage=BlockedDamage;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_BlockedBy),&Parms);
	}
	bool AAdvKitWeapon::CanFire()
	{
		AdvKitWeapon_eventCanFire_Parms Parms;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanFire),&Parms);
		return !!Parms.ReturnValue;
	}
	bool AAdvKitWeapon::CanReload()
	{
		AdvKitWeapon_eventCanReload_Parms Parms;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanReload),&Parms);
		return !!Parms.ReturnValue;
	}
	void AAdvKitWeapon::ConsumeAmmunition()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_ConsumeAmmunition),NULL);
	}
	void AAdvKitWeapon::FireAmmunition()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_FireAmmunition),NULL);
	}
	void AAdvKitWeapon::FireCustom()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_FireCustom),NULL);
	}
	void AAdvKitWeapon::FireInstant()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_FireInstant),NULL);
	}
	AAdvKitProjectile* AAdvKitWeapon::FireProjectile()
	{
		AdvKitWeapon_eventFireProjectile_Parms Parms;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_FireProjectile),&Parms);
		return Parms.ReturnValue;
	}
	FVector AAdvKitWeapon::GetMuzzleLocation(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventGetMuzzleLocation_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GetMuzzleLocation),&Parms);
		return Parms.ReturnValue;
	}
	FVector AAdvKitWeapon::GetTraceStart(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventGetTraceStart_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GetTraceStart),&Parms);
		return Parms.ReturnValue;
	}
	void AAdvKitWeapon::HandleFiringPrerequisites()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_HandleFiringPrerequisites),NULL);
	}
	void AAdvKitWeapon::OnFireBegin()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnFireBegin),NULL);
	}
	void AAdvKitWeapon::OnFireEnd()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnFireEnd),NULL);
	}
	void AAdvKitWeapon::OnFireShot()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnFireShot),NULL);
	}
	void AAdvKitWeapon::OnMagazineEmpty()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnMagazineEmpty),NULL);
	}
	void AAdvKitWeapon::OnReloadBegin()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnReloadBegin),NULL);
	}
	void AAdvKitWeapon::OnReloaded()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnReloaded),NULL);
	}
	void AAdvKitWeapon::OnReloadEnd()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnReloadEnd),NULL);
	}
	void AAdvKitWeapon::OnWeaponEmpty()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnWeaponEmpty),NULL);
	}
	void AAdvKitWeapon::ReloadAmmunition()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_ReloadAmmunition),NULL);
	}
	void AAdvKitWeapon::StartFire(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventStartFire_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartFire),&Parms);
	}
	void AAdvKitWeapon::StartFireInternal()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartFireInternal),NULL);
	}
	void AAdvKitWeapon::StartFireServer(uint8 FireModeIndex)
	{
		AdvKitWeapon_eventStartFireServer_Parms Parms;
		Parms.FireModeIndex=FireModeIndex;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartFireServer),&Parms);
	}
	void AAdvKitWeapon::StartReload()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartReload),NULL);
	}
	void AAdvKitWeapon::StartReloadInternal()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartReloadInternal),NULL);
	}
	void AAdvKitWeapon::StartReloadServer()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartReloadServer),NULL);
	}
	void AAdvKitWeapon::StartReloadTimer()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StartReloadTimer),NULL);
	}
	void AAdvKitWeapon::StopFire()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopFire),NULL);
	}
	void AAdvKitWeapon::StopFireInternal()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopFireInternal),NULL);
	}
	void AAdvKitWeapon::StopFireServer()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopFireServer),NULL);
	}
	void AAdvKitWeapon::StopReload()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopReload),NULL);
	}
	void AAdvKitWeapon::StopReloadInternal()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopReloadInternal),NULL);
	}
	void AAdvKitWeapon::StopReloadServer()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopReloadServer),NULL);
	}
	void AAdvKitWeapon::StopReloadTimer()
	{
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_StopReloadTimer),NULL);
	}
	void AAdvKitWeapon::StaticRegisterNativesAAdvKitWeapon()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "AddAmmunition",(Native)&AAdvKitWeapon::execAddAmmunition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "AddSpread",(Native)&AAdvKitWeapon::execAddSpread);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "BlockDamage",(Native)&AAdvKitWeapon::execBlockDamage);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "BlockedBy",(Native)&AAdvKitWeapon::execBlockedBy);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "CanFire",(Native)&AAdvKitWeapon::execCanFire);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "CanReload",(Native)&AAdvKitWeapon::execCanReload);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "ConsumeAmmunition",(Native)&AAdvKitWeapon::execConsumeAmmunition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "FireAmmunition",(Native)&AAdvKitWeapon::execFireAmmunition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "FireCustom",(Native)&AAdvKitWeapon::execFireCustom);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "FireInstant",(Native)&AAdvKitWeapon::execFireInstant);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "FireProjectile",(Native)&AAdvKitWeapon::execFireProjectile);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "GetAdjustedAim",(Native)&AAdvKitWeapon::execGetAdjustedAim);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "GetFireModeClass",(Native)&AAdvKitWeapon::execGetFireModeClass);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "GetMuzzleLocation",(Native)&AAdvKitWeapon::execGetMuzzleLocation);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "GetTraceStart",(Native)&AAdvKitWeapon::execGetTraceStart);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "HandleFiringPrerequisites",(Native)&AAdvKitWeapon::execHandleFiringPrerequisites);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "HasAmmunition",(Native)&AAdvKitWeapon::execHasAmmunition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "HasAmmunitionInMagazine",(Native)&AAdvKitWeapon::execHasAmmunitionInMagazine);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "HasFireMode",(Native)&AAdvKitWeapon::execHasFireMode);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "IsFiring",(Native)&AAdvKitWeapon::execIsFiring);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "IsIdle",(Native)&AAdvKitWeapon::execIsIdle);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "IsMagazineEmpty",(Native)&AAdvKitWeapon::execIsMagazineEmpty);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "IsReloading",(Native)&AAdvKitWeapon::execIsReloading);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnFireBegin",(Native)&AAdvKitWeapon::execOnFireBegin);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnFireEnd",(Native)&AAdvKitWeapon::execOnFireEnd);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnFireShot",(Native)&AAdvKitWeapon::execOnFireShot);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnMagazineEmpty",(Native)&AAdvKitWeapon::execOnMagazineEmpty);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnReloadBegin",(Native)&AAdvKitWeapon::execOnReloadBegin);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnReloaded",(Native)&AAdvKitWeapon::execOnReloaded);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnReloadEnd",(Native)&AAdvKitWeapon::execOnReloadEnd);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnRep_WeaponState",(Native)&AAdvKitWeapon::execOnRep_WeaponState);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "OnWeaponEmpty",(Native)&AAdvKitWeapon::execOnWeaponEmpty);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "RefireTimer",(Native)&AAdvKitWeapon::execRefireTimer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "ReloadAmmunition",(Native)&AAdvKitWeapon::execReloadAmmunition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "ReloadedTimer",(Native)&AAdvKitWeapon::execReloadedTimer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartFire",(Native)&AAdvKitWeapon::execStartFire);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartFireInternal",(Native)&AAdvKitWeapon::execStartFireInternal);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartFireServer",(Native)&AAdvKitWeapon::execStartFireServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartRefireTimer",(Native)&AAdvKitWeapon::execStartRefireTimer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartReload",(Native)&AAdvKitWeapon::execStartReload);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartReloadInternal",(Native)&AAdvKitWeapon::execStartReloadInternal);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartReloadServer",(Native)&AAdvKitWeapon::execStartReloadServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StartReloadTimer",(Native)&AAdvKitWeapon::execStartReloadTimer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopFire",(Native)&AAdvKitWeapon::execStopFire);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopFireInternal",(Native)&AAdvKitWeapon::execStopFireInternal);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopFireServer",(Native)&AAdvKitWeapon::execStopFireServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopRefireTimer",(Native)&AAdvKitWeapon::execStopRefireTimer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopReload",(Native)&AAdvKitWeapon::execStopReload);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopReloadInternal",(Native)&AAdvKitWeapon::execStopReloadInternal);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopReloadServer",(Native)&AAdvKitWeapon::execStopReloadServer);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeapon::StaticClass(), "StopReloadTimer",(Native)&AAdvKitWeapon::execStopReloadTimer);
	}
	IMPLEMENT_CLASS(AAdvKitWeapon, 4111328618);
	void AAdvKitWeaponTracing::OnTraceHit(FHitResult Hit)
	{
		AdvKitWeaponTracing_eventOnTraceHit_Parms Parms;
		Parms.Hit=Hit;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_OnTraceHit),&Parms);
	}
	void AAdvKitWeaponTracing::StaticRegisterNativesAAdvKitWeaponTracing()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeaponTracing::StaticClass(), "OnTraceHit",(Native)&AAdvKitWeaponTracing::execOnTraceHit);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeaponTracing::StaticClass(), "StartTracing",(Native)&AAdvKitWeaponTracing::execStartTracing);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitWeaponTracing::StaticClass(), "StopTracing",(Native)&AAdvKitWeaponTracing::execStopTracing);
	}
	IMPLEMENT_CLASS(AAdvKitWeaponTracing, 2682212190);
	void AAdvKitInventoryManager::AddInventory(AAdvKitInventoryItem* NewInventory, bool bEquip)
	{
		AdvKitInventoryManager_eventAddInventory_Parms Parms;
		Parms.NewInventory=NewInventory;
		Parms.bEquip=bEquip ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_AddInventory),&Parms);
	}
	void AAdvKitInventoryManager::RemoveInventory(AAdvKitInventoryItem* RemovedInventory)
	{
		AdvKitInventoryManager_eventRemoveInventory_Parms Parms;
		Parms.RemovedInventory=RemovedInventory;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_RemoveInventory),&Parms);
	}
	void AAdvKitInventoryManager::SetNewInventoryServer(AAdvKitInventoryItem* NewInventory, bool bInstant)
	{
		AdvKitInventoryManager_eventSetNewInventoryServer_Parms Parms;
		Parms.NewInventory=NewInventory;
		Parms.bInstant=bInstant ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_SetNewInventoryServer),&Parms);
	}
	void AAdvKitInventoryManager::StaticRegisterNativesAAdvKitInventoryManager()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "AddInventory",(Native)&AAdvKitInventoryManager::execAddInventory);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "CanEquipInventory",(Native)&AAdvKitInventoryManager::execCanEquipInventory);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "GetCurrentInventory",(Native)&AAdvKitInventoryManager::execGetCurrentInventory);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "GetInventoryByClass",(Native)&AAdvKitInventoryManager::execGetInventoryByClass);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "GetPendingInventory",(Native)&AAdvKitInventoryManager::execGetPendingInventory);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "NextItem",(Native)&AAdvKitInventoryManager::execNextItem);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "OnRep_InventoryArray",(Native)&AAdvKitInventoryManager::execOnRep_InventoryArray);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "PreviousItem",(Native)&AAdvKitInventoryManager::execPreviousItem);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "RemoveInventory",(Native)&AAdvKitInventoryManager::execRemoveInventory);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "SetNewInventory",(Native)&AAdvKitInventoryManager::execSetNewInventory);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "SetNewInventoryByClass",(Native)&AAdvKitInventoryManager::execSetNewInventoryByClass);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitInventoryManager::StaticClass(), "SetNewInventoryServer",(Native)&AAdvKitInventoryManager::execSetNewInventoryServer);
	}
	IMPLEMENT_CLASS(AAdvKitInventoryManager, 1393594540);
	void AAdvKitPlayerController::StaticRegisterNativesAAdvKitPlayerController()
	{
	}
	IMPLEMENT_CLASS(AAdvKitPlayerController, 1201403655);
	void AAdvKitGravityPlayerController::StaticRegisterNativesAAdvKitGravityPlayerController()
	{
	}
	IMPLEMENT_CLASS(AAdvKitGravityPlayerController, 840184221);
	void UAdvKitTargetLockComponent::StaticRegisterNativesUAdvKitTargetLockComponent()
	{
	}
	IMPLEMENT_CLASS(UAdvKitTargetLockComponent, 1482615501);
	void AAdvKitTargetPoint::StaticRegisterNativesAAdvKitTargetPoint()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitTargetPoint::StaticClass(), "GetTargetedActor",(Native)&AAdvKitTargetPoint::execGetTargetedActor);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitTargetPoint::StaticClass(), "IsValidTarget",(Native)&AAdvKitTargetPoint::execIsValidTarget);
	}
	IMPLEMENT_CLASS(AAdvKitTargetPoint, 3619810624);
	void UAdvKitTraceUtilityComponent::StaticRegisterNativesUAdvKitTraceUtilityComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "BoxTraceMultiBlueprint",(Native)&UAdvKitTraceUtilityComponent::execBoxTraceMultiBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "BoxTraceMultiForObjectsBlueprint",(Native)&UAdvKitTraceUtilityComponent::execBoxTraceMultiForObjectsBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "BoxTraceSingleBlueprint",(Native)&UAdvKitTraceUtilityComponent::execBoxTraceSingleBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "BoxTraceSingleForObjectsBlueprint",(Native)&UAdvKitTraceUtilityComponent::execBoxTraceSingleForObjectsBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "CapsuleTraceMultiBlueprint",(Native)&UAdvKitTraceUtilityComponent::execCapsuleTraceMultiBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "CapsuleTraceMultiForObjects",(Native)&UAdvKitTraceUtilityComponent::execCapsuleTraceMultiForObjects);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "CapsuleTraceSingleBlueprint",(Native)&UAdvKitTraceUtilityComponent::execCapsuleTraceSingleBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "CapsuleTraceSingleForObjectsBlueprint",(Native)&UAdvKitTraceUtilityComponent::execCapsuleTraceSingleForObjectsBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "DrawDebug",(Native)&UAdvKitTraceUtilityComponent::execDrawDebug);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "GetEnd",(Native)&UAdvKitTraceUtilityComponent::execGetEnd);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "GetStart",(Native)&UAdvKitTraceUtilityComponent::execGetStart);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "LineTraceMultiBlueprint",(Native)&UAdvKitTraceUtilityComponent::execLineTraceMultiBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "LineTraceMultiForObjectsBlueprint",(Native)&UAdvKitTraceUtilityComponent::execLineTraceMultiForObjectsBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "LineTraceSingleBlueprint",(Native)&UAdvKitTraceUtilityComponent::execLineTraceSingleBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "LineTraceSingleForObjectBlueprints",(Native)&UAdvKitTraceUtilityComponent::execLineTraceSingleForObjectBlueprints);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "SphereTraceMultiBlueprint",(Native)&UAdvKitTraceUtilityComponent::execSphereTraceMultiBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "SphereTraceMultiForObjectsBlueprint",(Native)&UAdvKitTraceUtilityComponent::execSphereTraceMultiForObjectsBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "SphereTraceSingleBlueprint",(Native)&UAdvKitTraceUtilityComponent::execSphereTraceSingleBlueprint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTraceUtilityComponent::StaticClass(), "SphereTraceSingleForObjectBlueprints",(Native)&UAdvKitTraceUtilityComponent::execSphereTraceSingleForObjectBlueprints);
	}
	IMPLEMENT_CLASS(UAdvKitTraceUtilityComponent, 1180478439);
	bool UAdvKitTransitionBuilderModule::CanCreateTransitionsFor(TSubclassOf<AAdvKitCharacter>  ForCharacterClass, AAdvKitZone* ForZone)
	{
		AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms Parms;
		Parms.ForCharacterClass=ForCharacterClass;
		Parms.ForZone=ForZone;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanCreateTransitionsFor),&Parms);
		return !!Parms.ReturnValue;
	}
	bool UAdvKitTransitionBuilderModule::CreateTransitionBetween(TSubclassOf<AAdvKitCharacter>  ForCharacterClass, AAdvKitZone* SourceZone, AAdvKitZone* TargetZone)
	{
		AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms Parms;
		Parms.ForCharacterClass=ForCharacterClass;
		Parms.SourceZone=SourceZone;
		Parms.TargetZone=TargetZone;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CreateTransitionBetween),&Parms);
		return !!Parms.ReturnValue;
	}
	void UAdvKitTransitionBuilderModule::CreateTransitions(TArray<AAdvKitZone*>& OutAffectedZones)
	{
		AdvKitTransitionBuilderModule_eventCreateTransitions_Parms Parms;
		Parms.OutAffectedZones=OutAffectedZones;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CreateTransitions),&Parms);
		OutAffectedZones=Parms.OutAffectedZones;
	}
	void UAdvKitTransitionBuilderModule::CreateTransitionsFor(TSubclassOf<AAdvKitCharacter>  ForCharacterClass, AAdvKitZone* ForZone)
	{
		AdvKitTransitionBuilderModule_eventCreateTransitionsFor_Parms Parms;
		Parms.ForCharacterClass=ForCharacterClass;
		Parms.ForZone=ForZone;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CreateTransitionsFor),&Parms);
	}
	bool UAdvKitTransitionBuilderModule::GatherPotentialTargetZones(TSubclassOf<AAdvKitCharacter>  ForCharacterClass, AAdvKitZone* ForZone, TArray<AAdvKitZone*>& OutZones)
	{
		AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms Parms;
		Parms.ForCharacterClass=ForCharacterClass;
		Parms.ForZone=ForZone;
		Parms.OutZones=OutZones;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GatherPotentialTargetZones),&Parms);
		OutZones=Parms.OutZones;
		return !!Parms.ReturnValue;
	}
	void UAdvKitTransitionBuilderModule::StaticRegisterNativesUAdvKitTransitionBuilderModule()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "CanCreateTransitionsFor",(Native)&UAdvKitTransitionBuilderModule::execCanCreateTransitionsFor);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "CreateTransitionArea",(Native)&UAdvKitTransitionBuilderModule::execCreateTransitionArea);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "CreateTransitionBetween",(Native)&UAdvKitTransitionBuilderModule::execCreateTransitionBetween);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "CreateTransitionPoint",(Native)&UAdvKitTransitionBuilderModule::execCreateTransitionPoint);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "CreateTransitions",(Native)&UAdvKitTransitionBuilderModule::execCreateTransitions);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "CreateTransitionsFor",(Native)&UAdvKitTransitionBuilderModule::execCreateTransitionsFor);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "GatherPotentialTargetZones",(Native)&UAdvKitTransitionBuilderModule::execGatherPotentialTargetZones);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "GetCharacterHalfExtent",(Native)&UAdvKitTransitionBuilderModule::execGetCharacterHalfExtent);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "GetCharacterMovementProperties_BP",(Native)&UAdvKitTransitionBuilderModule::execGetCharacterMovementProperties_BP);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "GetOuterZone",(Native)&UAdvKitTransitionBuilderModule::execGetOuterZone);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionBuilderModule::StaticClass(), "OverlapForCloseZones",(Native)&UAdvKitTransitionBuilderModule::execOverlapForCloseZones);
	}
	IMPLEMENT_CLASS(UAdvKitTransitionBuilderModule, 77489911);
	void UAdvKitBuildModule_Balance::StaticRegisterNativesUAdvKitBuildModule_Balance()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Balance, 3714128692);
	void UAdvKitBuildModule_Ladder::StaticRegisterNativesUAdvKitBuildModule_Ladder()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Ladder, 1245870798);
	void UAdvKitBuildModule_Ledge::StaticRegisterNativesUAdvKitBuildModule_Ledge()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Ledge, 2603973874);
	void UAdvKitBuildModule_Ledge_Ladder::StaticRegisterNativesUAdvKitBuildModule_Ledge_Ladder()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Ledge_Ladder, 2273895682);
	void UAdvKitBuildModule_Ledge_Tightspace::StaticRegisterNativesUAdvKitBuildModule_Ledge_Tightspace()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Ledge_Tightspace, 2056624194);
	void UAdvKitBuildModule_Tightspace::StaticRegisterNativesUAdvKitBuildModule_Tightspace()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Tightspace, 4066301335);
	void UAdvKitBuildModule_Wall::StaticRegisterNativesUAdvKitBuildModule_Wall()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Wall, 880082124);
	void UAdvKitBuildModule_Wall_Ceiling::StaticRegisterNativesUAdvKitBuildModule_Wall_Ceiling()
	{
	}
	IMPLEMENT_CLASS(UAdvKitBuildModule_Wall_Ceiling, 1752416504);
	void UAdvKitTransitionComponent::StaticRegisterNativesUAdvKitTransitionComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionComponent::StaticClass(), "CanTransition",(Native)&UAdvKitTransitionComponent::execCanTransition);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionComponent::StaticClass(), "GetClosestSourcePosition",(Native)&UAdvKitTransitionComponent::execGetClosestSourcePosition);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionComponent::StaticClass(), "GetClosestTargetPosition",(Native)&UAdvKitTransitionComponent::execGetClosestTargetPosition);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitTransitionComponent::StaticClass(), "IsDynamicTransitionValid",(Native)&UAdvKitTransitionComponent::execIsDynamicTransitionValid);
	}
	IMPLEMENT_CLASS(UAdvKitTransitionComponent, 2670231837);
	void UAdvKitTransitionComponentArea::StaticRegisterNativesUAdvKitTransitionComponentArea()
	{
	}
	IMPLEMENT_CLASS(UAdvKitTransitionComponentArea, 28364049);
	void UAdvKitTransitionComponentPoint::StaticRegisterNativesUAdvKitTransitionComponentPoint()
	{
	}
	IMPLEMENT_CLASS(UAdvKitTransitionComponentPoint, 1137457882);
	bool AAdvKitUsable::CanBeUsedBy(AAdvKitCharacter* Character, AAdvKitInventoryItem* WithItem)
	{
		AdvKitUsable_eventCanBeUsedBy_Parms Parms;
		Parms.Character=Character;
		Parms.WithItem=WithItem;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanBeUsedBy),&Parms);
		return !!Parms.ReturnValue;
	}
	void AAdvKitUsable::UsedBy(AAdvKitCharacter* Character, AAdvKitInventoryItem* WithItem)
	{
		AdvKitUsable_eventUsedBy_Parms Parms;
		Parms.Character=Character;
		Parms.WithItem=WithItem;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_UsedBy),&Parms);
	}
	void AAdvKitUsable::StaticRegisterNativesAAdvKitUsable()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitUsable::StaticClass(), "CanBeUsedBy",(Native)&AAdvKitUsable::execCanBeUsedBy);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitUsable::StaticClass(), "UsedBy",(Native)&AAdvKitUsable::execUsedBy);
	}
	IMPLEMENT_CLASS(AAdvKitUsable, 3955966792);
	bool AAdvKitPickup::CanBePickedUpBy(AAdvKitCharacter* Character)
	{
		AdvKitPickup_eventCanBePickedUpBy_Parms Parms;
		Parms.Character=Character;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_CanBePickedUpBy),&Parms);
		return !!Parms.ReturnValue;
	}
	void AAdvKitPickup::PickedUpBy(AAdvKitCharacter* Character, AAdvKitInventoryItem* WithItem)
	{
		AdvKitPickup_eventPickedUpBy_Parms Parms;
		Parms.Character=Character;
		Parms.WithItem=WithItem;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_PickedUpBy),&Parms);
	}
	void AAdvKitPickup::StaticRegisterNativesAAdvKitPickup()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitPickup::StaticClass(), "CanBePickedUpBy",(Native)&AAdvKitPickup::execCanBePickedUpBy);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitPickup::StaticClass(), "PickedUpBy",(Native)&AAdvKitPickup::execPickedUpBy);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitPickup::StaticClass(), "Respawn",(Native)&AAdvKitPickup::execRespawn);
	}
	IMPLEMENT_CLASS(AAdvKitPickup, 292624244);
	void AAdvKitAmmunitionPickup::StaticRegisterNativesAAdvKitAmmunitionPickup()
	{
	}
	IMPLEMENT_CLASS(AAdvKitAmmunitionPickup, 2778405176);
	void AAdvKitInventoryPickup::StaticRegisterNativesAAdvKitInventoryPickup()
	{
	}
	IMPLEMENT_CLASS(AAdvKitInventoryPickup, 3315130741);
	void AAdvKitUsableSimpleSwitch::StaticRegisterNativesAAdvKitUsableSimpleSwitch()
	{
	}
	IMPLEMENT_CLASS(AAdvKitUsableSimpleSwitch, 3457533746);
	FVector AAdvKitZone::ConstrainDirectionToZone(const FVector& WorldDirection, const FVector& AtWorldLocation)
	{
		AdvKitZone_eventConstrainDirectionToZone_Parms Parms;
		Parms.WorldDirection=WorldDirection;
		Parms.AtWorldLocation=AtWorldLocation;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_ConstrainDirectionToZone),&Parms);
		return Parms.ReturnValue;
	}
	FVector AAdvKitZone::ConstrainPositionToZone(const FVector& WorldPosition, const FVector& HalfExtent, const FRotator& ExtentWorldRotation)
	{
		AdvKitZone_eventConstrainPositionToZone_Parms Parms;
		Parms.WorldPosition=WorldPosition;
		Parms.HalfExtent=HalfExtent;
		Parms.ExtentWorldRotation=ExtentWorldRotation;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_ConstrainPositionToZone),&Parms);
		return Parms.ReturnValue;
	}
	void AAdvKitZone::GenerateTransitions(bool bZoneMoved)
	{
		AdvKitZone_eventGenerateTransitions_Parms Parms;
		Parms.bZoneMoved=bZoneMoved ? true : false;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GenerateTransitions),&Parms);
	}
	UAdvKitZoneLocation* AAdvKitZone::GetClosestZoneLocation(const FVector& WorldPosition, const FVector& HalfExtent, const FRotator& ExtentWorldRotation)
	{
		AdvKitZone_eventGetClosestZoneLocation_Parms Parms;
		Parms.WorldPosition=WorldPosition;
		Parms.HalfExtent=HalfExtent;
		Parms.ExtentWorldRotation=ExtentWorldRotation;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GetClosestZoneLocation),&Parms);
		return Parms.ReturnValue;
	}
	FVector AAdvKitZone::GetPositionInDirection(const FVector& FromWorldPosition, const FVector& WorldDesiredDelta, bool bClamp, const FVector& HalfExtent, const FRotator& ExtentWorldRotation)
	{
		AdvKitZone_eventGetPositionInDirection_Parms Parms;
		Parms.FromWorldPosition=FromWorldPosition;
		Parms.WorldDesiredDelta=WorldDesiredDelta;
		Parms.bClamp=bClamp ? true : false;
		Parms.HalfExtent=HalfExtent;
		Parms.ExtentWorldRotation=ExtentWorldRotation;
		ProcessEvent(FindFunctionChecked(ADVKITRUNTIME_GetPositionInDirection),&Parms);
		return Parms.ReturnValue;
	}
	void AAdvKitZone::StaticRegisterNativesAAdvKitZone()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "AddTransition",(Native)&AAdvKitZone::execAddTransition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "ConstrainDirectionToZone",(Native)&AAdvKitZone::execConstrainDirectionToZone);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "ConstrainPositionToZone",(Native)&AAdvKitZone::execConstrainPositionToZone);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GenerateTransitions",(Native)&AAdvKitZone::execGenerateTransitions);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetClosestZoneLocation",(Native)&AAdvKitZone::execGetClosestZoneLocation);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetCustomPhysics",(Native)&AAdvKitZone::execGetCustomPhysics);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetPhysics",(Native)&AAdvKitZone::execGetPhysics);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetPositionInDirection",(Native)&AAdvKitZone::execGetPositionInDirection);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetZoneForwardVector",(Native)&AAdvKitZone::execGetZoneForwardVector);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetZoneRightVector",(Native)&AAdvKitZone::execGetZoneRightVector);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "GetZoneUpVector",(Native)&AAdvKitZone::execGetZoneUpVector);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "HasCustomPhysics",(Native)&AAdvKitZone::execHasCustomPhysics);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "HasPhysics",(Native)&AAdvKitZone::execHasPhysics);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "MoveLocationInDirection",(Native)&AAdvKitZone::execMoveLocationInDirection);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "RegisterTransition",(Native)&AAdvKitZone::execRegisterTransition);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "RegisterTransitionArea",(Native)&AAdvKitZone::execRegisterTransitionArea);
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZone::StaticClass(), "RemoveExistingTransitionsTo",(Native)&AAdvKitZone::execRemoveExistingTransitionsTo);
	}
	IMPLEMENT_CLASS(AAdvKitZone, 3686679211);
	void AAdvKitZoneLine::StaticRegisterNativesAAdvKitZoneLine()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZoneLine::StaticClass(), "GetProjectedHalfExtent",(Native)&AAdvKitZoneLine::execGetProjectedHalfExtent);
	}
	IMPLEMENT_CLASS(AAdvKitZoneLine, 1200496692);
	void AAdvKitZoneRectangle::StaticRegisterNativesAAdvKitZoneRectangle()
	{
		FNativeFunctionRegistrar::RegisterFunction(AAdvKitZoneRectangle::StaticClass(), "GetProjectedHalfExtent",(Native)&AAdvKitZoneRectangle::execGetProjectedHalfExtent);
	}
	IMPLEMENT_CLASS(AAdvKitZoneRectangle, 2998612390);
	void UAdvKitZoneLocation::StaticRegisterNativesUAdvKitZoneLocation()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitZoneLocation::StaticClass(), "ConstrainDirection",(Native)&UAdvKitZoneLocation::execConstrainDirection);
		FNativeFunctionRegistrar::RegisterFunction(UAdvKitZoneLocation::StaticClass(), "MoveInDirection",(Native)&UAdvKitZoneLocation::execMoveInDirection);
	}
	IMPLEMENT_CLASS(UAdvKitZoneLocation, 779478413);
	void UAnimMetaData_Transition::StaticRegisterNativesUAnimMetaData_Transition()
	{
	}
	IMPLEMENT_CLASS(UAnimMetaData_Transition, 2990568438);
	void UAnimNotify_CharacterModifier::StaticRegisterNativesUAnimNotify_CharacterModifier()
	{
	}
	IMPLEMENT_CLASS(UAnimNotify_CharacterModifier, 689723222);
	void UAnimNotify_SetTransitionZone::StaticRegisterNativesUAnimNotify_SetTransitionZone()
	{
	}
	IMPLEMENT_CLASS(UAnimNotify_SetTransitionZone, 4273673963);
FName ADVKITRUNTIME_AddAmmunition = FName(TEXT("AddAmmunition"));
FName ADVKITRUNTIME_AddInventory = FName(TEXT("AddInventory"));
FName ADVKITRUNTIME_AttachToCharacter = FName(TEXT("AttachToCharacter"));
FName ADVKITRUNTIME_BlockAnyDamage = FName(TEXT("BlockAnyDamage"));
FName ADVKITRUNTIME_BlockDamage = FName(TEXT("BlockDamage"));
FName ADVKITRUNTIME_BlockedBy = FName(TEXT("BlockedBy"));
FName ADVKITRUNTIME_BlockPointDamage = FName(TEXT("BlockPointDamage"));
FName ADVKITRUNTIME_BlockRadialDamage = FName(TEXT("BlockRadialDamage"));
FName ADVKITRUNTIME_CanBeCombinedWith = FName(TEXT("CanBeCombinedWith"));
FName ADVKITRUNTIME_CanBeInterruptedBy = FName(TEXT("CanBeInterruptedBy"));
FName ADVKITRUNTIME_CanBePickedUpBy = FName(TEXT("CanBePickedUpBy"));
FName ADVKITRUNTIME_CanBeUsedBy = FName(TEXT("CanBeUsedBy"));
FName ADVKITRUNTIME_CanCreateTransitionsFor = FName(TEXT("CanCreateTransitionsFor"));
FName ADVKITRUNTIME_CanEquip = FName(TEXT("CanEquip"));
FName ADVKITRUNTIME_CanFire = FName(TEXT("CanFire"));
FName ADVKITRUNTIME_CanInterrupt = FName(TEXT("CanInterrupt"));
FName ADVKITRUNTIME_CanReload = FName(TEXT("CanReload"));
FName ADVKITRUNTIME_CanUneqiup = FName(TEXT("CanUneqiup"));
FName ADVKITRUNTIME_CanWallWalkOn = FName(TEXT("CanWallWalkOn"));
FName ADVKITRUNTIME_CombinedWith = FName(TEXT("CombinedWith"));
FName ADVKITRUNTIME_ConstrainDirectionToZone = FName(TEXT("ConstrainDirectionToZone"));
FName ADVKITRUNTIME_ConstrainPositionToZone = FName(TEXT("ConstrainPositionToZone"));
FName ADVKITRUNTIME_ConsumeAmmunition = FName(TEXT("ConsumeAmmunition"));
FName ADVKITRUNTIME_CreateTransitionBetween = FName(TEXT("CreateTransitionBetween"));
FName ADVKITRUNTIME_CreateTransitions = FName(TEXT("CreateTransitions"));
FName ADVKITRUNTIME_CreateTransitionsFor = FName(TEXT("CreateTransitionsFor"));
FName ADVKITRUNTIME_DetachFromCharacter = FName(TEXT("DetachFromCharacter"));
FName ADVKITRUNTIME_Died = FName(TEXT("Died"));
FName ADVKITRUNTIME_Dodge = FName(TEXT("Dodge"));
FName ADVKITRUNTIME_DodgeServer = FName(TEXT("DodgeServer"));
FName ADVKITRUNTIME_EnterZoneServer = FName(TEXT("EnterZoneServer"));
FName ADVKITRUNTIME_EquipServer = FName(TEXT("EquipServer"));
FName ADVKITRUNTIME_FireAmmunition = FName(TEXT("FireAmmunition"));
FName ADVKITRUNTIME_FireCustom = FName(TEXT("FireCustom"));
FName ADVKITRUNTIME_FireInstant = FName(TEXT("FireInstant"));
FName ADVKITRUNTIME_FireProjectile = FName(TEXT("FireProjectile"));
FName ADVKITRUNTIME_GatherPotentialTargetZones = FName(TEXT("GatherPotentialTargetZones"));
FName ADVKITRUNTIME_GenerateTransitions = FName(TEXT("GenerateTransitions"));
FName ADVKITRUNTIME_GetAdditionalRequiredActions = FName(TEXT("GetAdditionalRequiredActions"));
FName ADVKITRUNTIME_GetClosestZoneLocation = FName(TEXT("GetClosestZoneLocation"));
FName ADVKITRUNTIME_GetMontageToPlay = FName(TEXT("GetMontageToPlay"));
FName ADVKITRUNTIME_GetMuzzleLocation = FName(TEXT("GetMuzzleLocation"));
FName ADVKITRUNTIME_GetPositionInDirection = FName(TEXT("GetPositionInDirection"));
FName ADVKITRUNTIME_GetTraceStart = FName(TEXT("GetTraceStart"));
FName ADVKITRUNTIME_HandleFiringPrerequisites = FName(TEXT("HandleFiringPrerequisites"));
FName ADVKITRUNTIME_IsAlive = FName(TEXT("IsAlive"));
FName ADVKITRUNTIME_IsDodging = FName(TEXT("IsDodging"));
FName ADVKITRUNTIME_OnEquip = FName(TEXT("OnEquip"));
FName ADVKITRUNTIME_OnEquipped = FName(TEXT("OnEquipped"));
FName ADVKITRUNTIME_OnFireBegin = FName(TEXT("OnFireBegin"));
FName ADVKITRUNTIME_OnFireEnd = FName(TEXT("OnFireEnd"));
FName ADVKITRUNTIME_OnFireShot = FName(TEXT("OnFireShot"));
FName ADVKITRUNTIME_OnImpact = FName(TEXT("OnImpact"));
FName ADVKITRUNTIME_OnMagazineEmpty = FName(TEXT("OnMagazineEmpty"));
FName ADVKITRUNTIME_OnMontageEnded = FName(TEXT("OnMontageEnded"));
FName ADVKITRUNTIME_OnReloadBegin = FName(TEXT("OnReloadBegin"));
FName ADVKITRUNTIME_OnReloaded = FName(TEXT("OnReloaded"));
FName ADVKITRUNTIME_OnReloadEnd = FName(TEXT("OnReloadEnd"));
FName ADVKITRUNTIME_OnTraceHit = FName(TEXT("OnTraceHit"));
FName ADVKITRUNTIME_OnUneqiup = FName(TEXT("OnUneqiup"));
FName ADVKITRUNTIME_OnUneqiupped = FName(TEXT("OnUneqiupped"));
FName ADVKITRUNTIME_OnWeaponEmpty = FName(TEXT("OnWeaponEmpty"));
FName ADVKITRUNTIME_PickedUpBy = FName(TEXT("PickedUpBy"));
FName ADVKITRUNTIME_PlayAnimMontageServer = FName(TEXT("PlayAnimMontageServer"));
FName ADVKITRUNTIME_PlayFootstep = FName(TEXT("PlayFootstep"));
FName ADVKITRUNTIME_PlayFootstepAttached = FName(TEXT("PlayFootstepAttached"));
FName ADVKITRUNTIME_ReloadAmmunition = FName(TEXT("ReloadAmmunition"));
FName ADVKITRUNTIME_RemoveInventory = FName(TEXT("RemoveInventory"));
FName ADVKITRUNTIME_ServerUse = FName(TEXT("ServerUse"));
FName ADVKITRUNTIME_SetCameraModeServer = FName(TEXT("SetCameraModeServer"));
FName ADVKITRUNTIME_SetFirstPersonEnabledServer = FName(TEXT("SetFirstPersonEnabledServer"));
FName ADVKITRUNTIME_SetNewInventoryServer = FName(TEXT("SetNewInventoryServer"));
FName ADVKITRUNTIME_SetNewOrientationServer = FName(TEXT("SetNewOrientationServer"));
FName ADVKITRUNTIME_SetZoneLocationServer = FName(TEXT("SetZoneLocationServer"));
FName ADVKITRUNTIME_SetZoneServer = FName(TEXT("SetZoneServer"));
FName ADVKITRUNTIME_Start = FName(TEXT("Start"));
FName ADVKITRUNTIME_StartActionServer = FName(TEXT("StartActionServer"));
FName ADVKITRUNTIME_StartFire = FName(TEXT("StartFire"));
FName ADVKITRUNTIME_StartFireInternal = FName(TEXT("StartFireInternal"));
FName ADVKITRUNTIME_StartFireServer = FName(TEXT("StartFireServer"));
FName ADVKITRUNTIME_StartReload = FName(TEXT("StartReload"));
FName ADVKITRUNTIME_StartReloadInternal = FName(TEXT("StartReloadInternal"));
FName ADVKITRUNTIME_StartReloadServer = FName(TEXT("StartReloadServer"));
FName ADVKITRUNTIME_StartReloadTimer = FName(TEXT("StartReloadTimer"));
FName ADVKITRUNTIME_Stop = FName(TEXT("Stop"));
FName ADVKITRUNTIME_StopFire = FName(TEXT("StopFire"));
FName ADVKITRUNTIME_StopFireInternal = FName(TEXT("StopFireInternal"));
FName ADVKITRUNTIME_StopFireServer = FName(TEXT("StopFireServer"));
FName ADVKITRUNTIME_StopReload = FName(TEXT("StopReload"));
FName ADVKITRUNTIME_StopReloadInternal = FName(TEXT("StopReloadInternal"));
FName ADVKITRUNTIME_StopReloadServer = FName(TEXT("StopReloadServer"));
FName ADVKITRUNTIME_StopReloadTimer = FName(TEXT("StopReloadTimer"));
FName ADVKITRUNTIME_UneqiupServer = FName(TEXT("UneqiupServer"));
FName ADVKITRUNTIME_UsedBy = FName(TEXT("UsedBy"));
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UClass* Z_Construct_UClass_UCharacterMovementComponent();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimMontage_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AController_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UDamageType_NoRegister();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FDamageEvent();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API class UClass* Z_Construct_UClass_ACharacter();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraComponent_NoRegister();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionChannel();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FFindFloorResult();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FRuntimeFloatCurve();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotifyState();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionResponse();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	ENGINE_API class UClass* Z_Construct_UClass_UDataAsset();
	ENGINE_API class UClass* Z_Construct_UClass_USoundCue_NoRegister();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EPhysicalSurface();
	ENGINE_API class UClass* Z_Construct_UClass_UAudioComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AGameMode();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UProjectileMovementComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USphereComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	ENGINE_API class UClass* Z_Construct_UClass_ATargetPoint();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EDrawDebugTrace();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETraceTypeQuery();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_EObjectTypeQuery();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FColor();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FBasedPosition();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimMetaData();
	ENGINE_API class UClass* Z_Construct_UClass_UAnimNotify();

	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_OrientationChanged__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitOrientationComponent_SetOrientation();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitOrientationComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitOrientationComponent();
	ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitMovementProperties();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_AccumulateRootMotion();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_CanTransition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_ChangeTargetBalance();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvCustomMovementMode();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvMovementMode();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredOffsetFromZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredRotationInZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetGlobalLocationInZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetHalfExtentForZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetPossibleTransition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZoneLocation();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_JumpUpZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_LetGoOfZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_MoveLocationInZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_PhysMoveInZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_SetAdvMovementMode();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_TryToTransition();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterMovementComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterMovementComponent();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Arguments_CreateArguments();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_Arguments();
	ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitActionResponse();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_CanBeInterruptedBy();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_CanInterrupt();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Failed();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_GetAdditionalRequiredActions();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_OnMontageEnded();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_PlayAnimMontage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Redirect();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Start();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Stop();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Succeeded();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction();
	ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FRepAdvKitAnimMontage();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitInventoryConfig();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_AddConditionalMovementInput();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockAnyDamage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockDamage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockPointDamage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockRadialDamage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_CanEnterZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_Died();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_Dodge();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_DodgeServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_EnterZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_EnterZoneServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetActiveAction();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetAdvMovementComponent();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetAimOffsets();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetAllAvailableTargets();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetCameraMode();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetZoneLocation();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsAlive();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsDodging();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsFirstPerson();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsShoulderCam();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsThirdPerson();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_NextCamera();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_NextItem();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_OnRep_RepAnimMontage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_PlayAnimMontageServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_PreviousItem();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_Reload();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_ServerUse();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetCameraMode();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetCameraModeServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetFirstPersonEnabledServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetMouseCursorEnabled();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetTarget();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocation();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocationServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZoneServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_StartAction();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_StartFire();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_StartTransitionActionTo();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_StopFire();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_Use();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacter_UseClosestUseable();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitCharacter_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitCharacter();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_CanWallWalkOn();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_GetAdvGravityMovementComponent();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientation();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientationServer();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitGravityCharacter_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitGravityCharacter();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Dodge_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Dodge();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterActionSingleAnimation_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterActionSingleAnimation();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitPhysicsTransition();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneLocationSwitch_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneLocationSwitch();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitCA_ZoneTransition_GetMontageToPlay();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FDirectionalMontage();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Directional_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Directional();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_LocationSwitch_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_LocationSwitch();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FTransitionLocation();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimNotifyState_TransitionCorrection_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimNotifyState_TransitionCorrection();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoAnim_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoAnim();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_SingleAnim_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_SingleAnim();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterActionPhysics_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterActionPhysics();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Dodge_Arguments_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Dodge_Arguments();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition_Arguments_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition_Arguments();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch_Arguments_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch_Arguments();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Arguments_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Arguments();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_Auto_MovementMode_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_Auto_MovementMode();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FResponseConfig();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_Collision_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_Collision();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_Item_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_Item();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_MovementMode_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_MovementMode();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_OrientationToZone_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_OrientationToZone();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_YawRotationBind_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCA_Mod_YawRotationBind();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_StateConfiguration_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitCharacterAction_StateConfiguration();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitCharacterActionManager_StartActionServer();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitCharacterActionManager_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitCharacterActionManager();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_OnOrientationChanged();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_SetGravityVector();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent();
	ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitFireModeConfiguration();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FFootStepSound();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstep();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstepAttached();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitFootstepComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitFootstepComponent();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitGameMode_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitGameMode();
	ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FRepAdvKitInventoryState();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_AttachToCharacter();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CanBeCombinedWith();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CanEquip();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CanUneqiup();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CombinedWith();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_DetachFromCharacter();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_Equip();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_EquipServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_GetItemState();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnEquip();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnEquipped();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnRep_ItemState();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiup();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiupped();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_Uneqiup();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_UneqiupServer();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventoryItem_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventoryItem();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventorySimpleCombinable_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventorySimpleCombinable();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitProjectile_Init();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitProjectile_OnImpact();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitProjectile_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitProjectile();
	ADVKITRUNTIME_API class UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState();
	ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitWeaponState();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddSpread();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockDamage();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockedBy();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanFire();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanReload();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireCustom();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireInstant();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireProjectile();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasFireMode();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsFiring();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsIdle();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsReloading();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireShot();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloaded();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_RefireTimer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFire();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReload();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFire();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReload();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitWeapon_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitWeapon();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeaponTracing_OnTraceHit();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeaponTracing_StartTracing();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitWeaponTracing_StopTracing();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitWeaponTracing_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitWeaponTracing();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_InventoryItemsChanged__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_ActiveItemChanged__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_ItemRemovedSignature__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_ItemAddedSignature__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_AddInventory();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_CanEquipInventory();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_GetCurrentInventory();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_GetInventoryByClass();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_GetPendingInventory();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_NextItem();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_OnRep_InventoryArray();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_PreviousItem();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_RemoveInventory();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventory();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryByClass();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryServer();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventoryManager_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventoryManager();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitPlayerController_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitPlayerController();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitGravityPlayerController_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitGravityPlayerController();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTargetLockComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTargetLockComponent();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitTargetPoint_GetTargetedActor();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitTargetPoint_IsValidTarget();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitTargetPoint_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitTargetPoint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiForObjectsBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleForObjectsBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiForObjects();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleForObjectsBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_DrawDebug();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetEnd();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetStart();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiForObjectsBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleForObjectBlueprints();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiForObjectsBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleBlueprint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleForObjectBlueprints();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTraceUtilityComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTraceUtilityComponent();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CanCreateTransitionsFor();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionArea();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionBetween();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionPoint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitions();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionsFor();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GatherPotentialTargetZones();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterHalfExtent();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterMovementProperties_BP();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetOuterZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_OverlapForCloseZones();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionBuilderModule_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionBuilderModule();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Balance_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Balance();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ladder_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ladder();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Ladder_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Ladder();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Tightspace_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Tightspace();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Tightspace_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Tightspace();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall_Ceiling_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall_Ceiling();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_CanTransition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestSourcePosition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestTargetPosition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_IsDynamicTransitionValid();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionComponent_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionComponent();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionComponentArea_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionComponentArea();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionComponentPoint_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitTransitionComponentPoint();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_UsedBySignature__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitUsable_CanBeUsedBy();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitUsable_UsedBy();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitUsable_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitUsable();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitPickup_CanBePickedUpBy();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitPickup_PickedUpBy();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitPickup_Respawn();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitPickup_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitPickup();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitAmmunitionPickup_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitAmmunitionPickup();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventoryPickup_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitInventoryPickup();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchDeactivatedBySignature__DelegateSignature();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchActivatedBySignature__DelegateSignature();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitUsableSimpleSwitch_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitUsableSimpleSwitch();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_AddTransition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_ConstrainDirectionToZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_ConstrainPositionToZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GenerateTransitions();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetClosestZoneLocation();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetCustomPhysics();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetPhysics();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetPositionInDirection();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetZoneForwardVector();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetZoneRightVector();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_GetZoneUpVector();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_HasCustomPhysics();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_HasPhysics();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_MoveLocationInDirection();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_RegisterTransition();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_RegisterTransitionArea();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZone_RemoveExistingTransitionsTo();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitZone_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitZone();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZoneLine_GetProjectedHalfExtent();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitZoneLine_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitZoneLine();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_AAdvKitZoneRectangle_GetProjectedHalfExtent();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitZoneRectangle_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitZoneRectangle();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitZoneLocation_ConstrainDirection();
	ADVKITRUNTIME_API class UFunction* Z_Construct_UFunction_UAdvKitZoneLocation_MoveInDirection();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitZoneLocation_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAdvKitZoneLocation();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimMetaData_Transition_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimMetaData_Transition();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimNotify_CharacterModifier_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimNotify_CharacterModifier();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimNotify_SetTransitionZone_NoRegister();
	ADVKITRUNTIME_API class UClass* Z_Construct_UClass_UAnimNotify_SetTransitionZone();
	ADVKITRUNTIME_API class UPackage* Z_Construct_UPackage__Script_AdvKitRuntime();
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_OrientationChanged__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventOrientationChanged_Parms
		{
			FTransform OldOrientation;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OrientationChanged__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventOrientationChanged_Parms));
			UProperty* NewProp_OldOrientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldOrientation, _Script_AdvKitRuntime_eventOrientationChanged_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitOrientationComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitOrientationComponent_SetOrientation()
	{
		struct AdvKitOrientationComponent_eventSetOrientation_Parms
		{
			FVector Origin;
			FVector UpNormal;
			bool bForce;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitOrientationComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AdvKitOrientationComponent_eventSetOrientation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForce, AdvKitOrientationComponent_eventSetOrientation_Parms, bool);
			UProperty* NewProp_bForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForce"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForce, AdvKitOrientationComponent_eventSetOrientation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bForce, AdvKitOrientationComponent_eventSetOrientation_Parms), sizeof(bool), true);
			UProperty* NewProp_UpNormal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UpNormal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(UpNormal, AdvKitOrientationComponent_eventSetOrientation_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Origin, AdvKitOrientationComponent_eventSetOrientation_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bForce"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitOrientationComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets a new orientation from an origin location and normal in\nworld space. Input is interpolated with current transform, using\nLocation- and RotationLerpSpeed.\n\n@param       Origin          Center of the new orientation\n@param       UpNormal        Up vector of the new orientation (in world space)\n@param       bForce          Ignore interpolation, hard set values"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitOrientationComponent_NoRegister()
	{
		return UAdvKitOrientationComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitOrientationComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitOrientationComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitOrientationComponent_SetOrientation());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnOrientationChanged = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnOrientationChanged"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnOrientationChanged, UAdvKitOrientationComponent), 0x0010000010080000, Z_Construct_UDelegateFunction_AdvKitRuntime_OrientationChanged__DelegateSignature());
				UProperty* NewProp_RotationLerpSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RotationLerpSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RotationLerpSpeed, UAdvKitOrientationComponent), 0x0020080000000005);
				UProperty* NewProp_LocationLerpSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocationLerpSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LocationLerpSpeed, UAdvKitOrientationComponent), 0x0020080000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitOrientationComponent_SetOrientation(), "SetOrientation"); // 3231340193
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitOrientationComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitOrientationComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Component to provide transformation coordinate methods.\n\nOne of the core classes of the arbitrary gravity system. This component's transform provides\na separate coordinate system aligning with the custom gravity vector as Z. It has several methods\nto easily convert vectors and rotators between world and local space."));
				MetaData->SetValue(NewProp_OnOrientationChanged, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_OnOrientationChanged, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitOrientationComponent.h"));
				MetaData->SetValue(NewProp_OnOrientationChanged, TEXT("ToolTip"), TEXT("Callback when the orientation of this component changes"));
				MetaData->SetValue(NewProp_RotationLerpSpeed, TEXT("Category"), TEXT("AdvKitOrientationComponent"));
				MetaData->SetValue(NewProp_RotationLerpSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitOrientationComponent.h"));
				MetaData->SetValue(NewProp_RotationLerpSpeed, TEXT("ToolTip"), TEXT("Setting a new orientation will not immediately change it, but rather interpolate\nto it using this value multiplied with DeltaTime"));
				MetaData->SetValue(NewProp_LocationLerpSpeed, TEXT("Category"), TEXT("AdvKitOrientationComponent"));
				MetaData->SetValue(NewProp_LocationLerpSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitOrientationComponent.h"));
				MetaData->SetValue(NewProp_LocationLerpSpeed, TEXT("ToolTip"), TEXT("Setting a new orientation location will not immediately change it, but rather interpolate\nto it using this value multiplied with DeltaTime"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitOrientationComponent(Z_Construct_UClass_UAdvKitOrientationComponent, &UAdvKitOrientationComponent::StaticClass, TEXT("UAdvKitOrientationComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitOrientationComponent);
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitMovementMode"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdvKitMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::None")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::Walking")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::NavWalking")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::Falling")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::Swimming")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::Flying")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::ClimbingWall")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::ClimbingCeiling")), 7));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::ClimbingLedge")), 8));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::ClimbingLadder")), 9));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::WalkingTightspace")), 10));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::WalkingBalance")), 11));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::ActionDriven")), 12));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::Custom")), 13));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitMovementMode::EAdvKitMovementMode_MAX")), 14));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EAdvKitMovementMode");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ActionDriven.DisplayName"), TEXT("Action Driven"));
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ClimbingCeiling.DisplayName"), TEXT("Ceiling Climbing"));
			MetaData->SetValue(ReturnEnum, TEXT("ClimbingLadder.DisplayName"), TEXT("Ladder Climbing"));
			MetaData->SetValue(ReturnEnum, TEXT("ClimbingLedge.DisplayName"), TEXT("Ledge Climbing"));
			MetaData->SetValue(ReturnEnum, TEXT("ClimbingWall.DisplayName"), TEXT("Wall Climbing"));
			MetaData->SetValue(ReturnEnum, TEXT("ClimbingWall.ToolTip"), TEXT("Enums above to preserve casting conversion from MovementMode to AdvMovementMode"));
			MetaData->SetValue(ReturnEnum, TEXT("Custom.DisplayName"), TEXT("Custom"));
			MetaData->SetValue(ReturnEnum, TEXT("Falling.DisplayName"), TEXT("Falling"));
			MetaData->SetValue(ReturnEnum, TEXT("Flying.DisplayName"), TEXT("Flying"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/AdvKitTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("NavWalking.DisplayName"), TEXT("Navmesh Walking"));
			MetaData->SetValue(ReturnEnum, TEXT("None.DisplayName"), TEXT("None"));
			MetaData->SetValue(ReturnEnum, TEXT("Swimming.DisplayName"), TEXT("Swimming"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@brief Enumeration for movement mode of the @see UAdvKitMovementComponent"));
			MetaData->SetValue(ReturnEnum, TEXT("Walking.DisplayName"), TEXT("Walking"));
			MetaData->SetValue(ReturnEnum, TEXT("WalkingBalance.DisplayName"), TEXT("Balance Walking"));
			MetaData->SetValue(ReturnEnum, TEXT("WalkingTightspace.DisplayName"), TEXT("Tight Space Walking"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode_CRC() { return 1027653414U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAdvKitMovementProperties()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FAdvKitMovementProperties_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AdvKitMovementProperties"), sizeof(FAdvKitMovementProperties), Get_Z_Construct_UScriptStruct_FAdvKitMovementProperties_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdvKitMovementProperties"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAdvKitMovementProperties>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanClimbLadder, FAdvKitMovementProperties, uint8);
			UProperty* NewProp_bCanClimbLadder = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanClimbLadder"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanClimbLadder, FAdvKitMovementProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanClimbLadder, FAdvKitMovementProperties), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanClimbLedge, FAdvKitMovementProperties, uint8);
			UProperty* NewProp_bCanClimbLedge = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanClimbLedge"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanClimbLedge, FAdvKitMovementProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanClimbLedge, FAdvKitMovementProperties), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanClimbWall, FAdvKitMovementProperties, uint8);
			UProperty* NewProp_bCanClimbWall = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanClimbWall"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanClimbWall, FAdvKitMovementProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanClimbWall, FAdvKitMovementProperties), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanClimbCeiling, FAdvKitMovementProperties, uint8);
			UProperty* NewProp_bCanClimbCeiling = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanClimbCeiling"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanClimbCeiling, FAdvKitMovementProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanClimbCeiling, FAdvKitMovementProperties), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanWalkBalance, FAdvKitMovementProperties, uint8);
			UProperty* NewProp_bCanWalkBalance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanWalkBalance"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanWalkBalance, FAdvKitMovementProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanWalkBalance, FAdvKitMovementProperties), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanWalkTightSpace, FAdvKitMovementProperties, uint8);
			UProperty* NewProp_bCanWalkTightSpace = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanWalkTightSpace"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanWalkTightSpace, FAdvKitMovementProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanWalkTightSpace, FAdvKitMovementProperties), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Movement properties of the adventure kit"));
			MetaData->SetValue(NewProp_bCanClimbLadder, TEXT("Category"), TEXT("AdvKitMovementProperties"));
			MetaData->SetValue(NewProp_bCanClimbLadder, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bCanClimbLadder, TEXT("ToolTip"), TEXT("Can the character use ladders"));
			MetaData->SetValue(NewProp_bCanClimbLedge, TEXT("Category"), TEXT("AdvKitMovementProperties"));
			MetaData->SetValue(NewProp_bCanClimbLedge, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bCanClimbLedge, TEXT("ToolTip"), TEXT("Can the character climb on ledges"));
			MetaData->SetValue(NewProp_bCanClimbWall, TEXT("Category"), TEXT("AdvKitMovementProperties"));
			MetaData->SetValue(NewProp_bCanClimbWall, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bCanClimbWall, TEXT("ToolTip"), TEXT("Can the character climb on walls"));
			MetaData->SetValue(NewProp_bCanClimbCeiling, TEXT("Category"), TEXT("AdvKitMovementProperties"));
			MetaData->SetValue(NewProp_bCanClimbCeiling, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bCanClimbCeiling, TEXT("ToolTip"), TEXT("Can the character climb on ceilings"));
			MetaData->SetValue(NewProp_bCanWalkBalance, TEXT("Category"), TEXT("AdvKitMovementProperties"));
			MetaData->SetValue(NewProp_bCanWalkBalance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bCanWalkBalance, TEXT("ToolTip"), TEXT("Can the character use balancing zones"));
			MetaData->SetValue(NewProp_bCanWalkTightSpace, TEXT("Category"), TEXT("AdvKitMovementProperties"));
			MetaData->SetValue(NewProp_bCanWalkTightSpace, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(NewProp_bCanWalkTightSpace, TEXT("ToolTip"), TEXT("Can the character use tight spaces"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAdvKitMovementProperties_CRC() { return 3305240556U; }
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_AccumulateRootMotion()
	{
		struct AdvKitCharacterMovementComponent_eventAccumulateRootMotion_Parms
		{
			FVector MovementDelta;
			FRotator NewRotation;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AccumulateRootMotion"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AdvKitCharacterMovementComponent_eventAccumulateRootMotion_Parms));
			UProperty* NewProp_NewRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewRotation, AdvKitCharacterMovementComponent_eventAccumulateRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_MovementDelta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MovementDelta"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MovementDelta, AdvKitCharacterMovementComponent_eventAccumulateRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds root motion to the owning character.\n@param       MovementDelta   Translation to be added to the character.\n@param       NewRotation             New rotation the character should have."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_CanTransition()
	{
		struct AdvKitCharacterMovementComponent_eventCanTransition_Parms
		{
			AAdvKitZone* ForZone;
			FVector ForWorldPosition;
			FVector InWorldDirection;
			bool bIsJump;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitCharacterMovementComponent_eventCanTransition_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterMovementComponent_eventCanTransition_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterMovementComponent_eventCanTransition_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterMovementComponent_eventCanTransition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsJump, AdvKitCharacterMovementComponent_eventCanTransition_Parms, bool);
			UProperty* NewProp_bIsJump = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsJump, AdvKitCharacterMovementComponent_eventCanTransition_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsJump, AdvKitCharacterMovementComponent_eventCanTransition_Parms), sizeof(bool), true);
			UProperty* NewProp_InWorldDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWorldDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InWorldDirection, AdvKitCharacterMovementComponent_eventCanTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForWorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForWorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ForWorldPosition, AdvKitCharacterMovementComponent_eventCanTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitCharacterMovementComponent_eventCanTransition_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bIsJump"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Checks if the character can use a transition in a given zone\n@param       ForZone         Zone to start transition in\n@param       ForWorldPosition        Where to start the transition\n@param       InWorldDirection        The direction the player wants to transition in\n@param       bIsJump         True if the character attempts to jump during the transition\n@return      True if the character can transition with the provided arguments"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_ChangeTargetBalance()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ChangeTargetBalance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Timer callback to change target balance"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvCustomMovementMode()
	{
		struct AdvKitCharacterMovementComponent_eventGetAdvCustomMovementMode_Parms
		{
			uint8 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAdvCustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetAdvCustomMovementMode_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetAdvCustomMovementMode_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current custom movement mode\n@return      Current custom movement mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvMovementMode()
	{
		struct AdvKitCharacterMovementComponent_eventGetAdvMovementMode_Parms
		{
			TEnumAsByte<EAdvKitMovementMode> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAdvMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetAdvMovementMode_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetAdvMovementMode_Parms), 0x0010000000000580, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current movement mode\n@return      Current movement mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredOffsetFromZone()
	{
		struct AdvKitCharacterMovementComponent_eventGetDesiredOffsetFromZone_Parms
		{
			AAdvKitZone* Zone;
			UAdvKitZoneLocation* AtLocation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDesiredOffsetFromZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetDesiredOffsetFromZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetDesiredOffsetFromZone_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AtLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AtLocation, AdvKitCharacterMovementComponent_eventGetDesiredOffsetFromZone_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, AdvKitCharacterMovementComponent_eventGetDesiredOffsetFromZone_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query how far the character should be away from the location inside the zone\n@param       Zone                    Zone to get the desired offset from\n@param       AtLocation      Location inside the current zone\n@return      Desired offset from the location inside the zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredRotationInZone()
	{
		struct AdvKitCharacterMovementComponent_eventGetDesiredRotationInZone_Parms
		{
			AAdvKitZone* Zone;
			UAdvKitZoneLocation* AtLocation;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDesiredRotationInZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetDesiredRotationInZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetDesiredRotationInZone_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_AtLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AtLocation, AdvKitCharacterMovementComponent_eventGetDesiredRotationInZone_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, AdvKitCharacterMovementComponent_eventGetDesiredRotationInZone_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query what rotation the character should have at a specified location inside the current zone.\n@param       Zone                    Zone to get the desired rotation\n@param       AtLocation      Location inside the current zone\n@return      Desired rotation of the character"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetGlobalLocationInZone()
	{
		struct AdvKitCharacterMovementComponent_eventGetGlobalLocationInZone_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGlobalLocationInZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetGlobalLocationInZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetGlobalLocationInZone_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the location inside the current zone in world space.\n@return      World space location inside the current zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetHalfExtentForZone()
	{
		struct AdvKitCharacterMovementComponent_eventGetHalfExtentForZone_Parms
		{
			AAdvKitZone* Zone;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHalfExtentForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetHalfExtentForZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetHalfExtentForZone_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, AdvKitCharacterMovementComponent_eventGetHalfExtentForZone_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query how \"big\" the character for a specific movement mode in local space.\n@param       Zone            Zone to get extent for\n@return Half extent of the character e.g (Radius, Radius, Capsule Half Height)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetPossibleTransition()
	{
		struct AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms
		{
			AAdvKitZone* ForZone;
			FVector ForWorldPosition;
			FVector InWorldDirection;
			bool bIsJump;
			UAdvKitTransitionComponent* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPossibleTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitTransitionComponent_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsJump, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms, bool);
			UProperty* NewProp_bIsJump = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsJump, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsJump, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms), sizeof(bool), true);
			UProperty* NewProp_InWorldDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWorldDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InWorldDirection, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForWorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForWorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ForWorldPosition, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitCharacterMovementComponent_eventGetPossibleTransition_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bIsJump"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Queries all possible transitions a zone has for the character\n@param       ForZone         Zone to get transitions from\n@param       ForWorldPosition        Where to start the transition\n@param       InWorldDirection        The direction the player wants to transition in\n@param       bIsJump         True if the character attempts to jump during the transition\n@return      List of possible transitions"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZone()
	{
		struct AdvKitCharacterMovementComponent_eventGetZone_Parms
		{
			AAdvKitZone* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetZone_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query the current zone of the character\n@return      Zone the character is currently in"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZoneLocation()
	{
		struct AdvKitCharacterMovementComponent_eventGetZoneLocation_Parms
		{
			UAdvKitZoneLocation* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZoneLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacterMovementComponent_eventGetZoneLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterMovementComponent_eventGetZoneLocation_Parms), 0x0010000000000580, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current zone location of the character\n@return      Current zone location"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_JumpUpZone()
	{
		struct AdvKitCharacterMovementComponent_eventJumpUpZone_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("JumpUpZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacterMovementComponent_eventJumpUpZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterMovementComponent_eventJumpUpZone_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterMovementComponent_eventJumpUpZone_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterMovementComponent_eventJumpUpZone_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tries to transition upwards on a zone\n@return      True if a transition happened"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_LetGoOfZone()
	{
		struct AdvKitCharacterMovementComponent_eventLetGoOfZone_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LetGoOfZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacterMovementComponent_eventLetGoOfZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterMovementComponent_eventLetGoOfZone_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterMovementComponent_eventLetGoOfZone_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterMovementComponent_eventLetGoOfZone_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tries to let go of a zone (transition downwards or leaving a wall)\n@return      True if a transition happened"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_MoveLocationInZone()
	{
		struct AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms
		{
			FVector GlobalAcceleration;
			float DeltaSeconds;
			FVector HalfExtent;
			bool bAutoTransition;
			bool ConstrainAcceleration;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MoveLocationInZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ConstrainAcceleration, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms, bool);
			UProperty* NewProp_ConstrainAcceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstrainAcceleration"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ConstrainAcceleration, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(ConstrainAcceleration, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoTransition, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms, bool);
			UProperty* NewProp_bAutoTransition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAutoTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoTransition, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bAutoTransition, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), sizeof(bool), true);
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DeltaSeconds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaSeconds"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DeltaSeconds, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), 0x0010000000000080);
			UProperty* NewProp_GlobalAcceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GlobalAcceleration"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GlobalAcceleration, AdvKitCharacterMovementComponent_eventMoveLocationInZone_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAutoTransition"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_ConstrainAcceleration"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Moves the character's zone location object with the given parameters\n@param       GlobalAcceleration      Acceleration to use for the intended moving direction\n@param       DeltaSeconds            Delta time since last tick\n@param       HalfExtent                      Size of the character in the zone (e.g. FVector(Radius,Radius,HalfHeight))\n@param       bAutoTransition         True to try to transition if the character cannot move\n@param       ConstrainAcceleration   True to restrict the acceleration vector to the zone\n@return      True if location was moved"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_PhysMoveInZone()
	{
		struct AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms
		{
			FVector GlobalAcceleration;
			FVector WorldOffset;
			float DeltaSeconds;
			FVector HalfExtent;
			bool bAutoTransition;
			bool ConstrainAcceleration;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PhysMoveInZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ConstrainAcceleration, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms, bool);
			UProperty* NewProp_ConstrainAcceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ConstrainAcceleration"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ConstrainAcceleration, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(ConstrainAcceleration, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoTransition, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms, bool);
			UProperty* NewProp_bAutoTransition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAutoTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoTransition, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bAutoTransition, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), sizeof(bool), true);
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DeltaSeconds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaSeconds"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DeltaSeconds, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000000000080);
			UProperty* NewProp_WorldOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldOffset, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_GlobalAcceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GlobalAcceleration"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GlobalAcceleration, AdvKitCharacterMovementComponent_eventPhysMoveInZone_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAutoTransition"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_ConstrainAcceleration"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Moves the character inside the current zone with the given parameters\n@param       GlobalAcceleration      Acceleration to use for the intended moving direction\n@param       DeltaSeconds            Delta time since last tick\n@param       HalfExtent                      Size of the character in the zone (e.g. FVector(Radius,Radius,HalfHeight))\n@param       bAutoTransition         True to try to transition if the character cannot move\n@param       ConstrainAcceleration   True to restrict the acceleration vector to the zone\n@return      True if location was moved"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_SetAdvMovementMode()
	{
		struct AdvKitCharacterMovementComponent_eventSetAdvMovementMode_Parms
		{
			TEnumAsByte<EAdvKitMovementMode> NewMovementMode;
			uint8 NewCustomMode;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetAdvMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacterMovementComponent_eventSetAdvMovementMode_Parms));
			UProperty* NewProp_NewCustomMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewCustomMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewCustomMode, AdvKitCharacterMovementComponent_eventSetAdvMovementMode_Parms), 0x0010000000000080);
			UProperty* NewProp_NewMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewMovementMode, AdvKitCharacterMovementComponent_eventSetAdvMovementMode_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_NewCustomMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new movement mode\n@param       NewMovementMode The new movement mode to set\n@param       NewCustomMode   A custom movement mode to set"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterMovementComponent_TryToTransition()
	{
		struct AdvKitCharacterMovementComponent_eventTryToTransition_Parms
		{
			AAdvKitZone* ForZone;
			FVector ForWorldPosition;
			FVector InWorldDirection;
			bool bIsJump;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TryToTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitCharacterMovementComponent_eventTryToTransition_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterMovementComponent_eventTryToTransition_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsJump, AdvKitCharacterMovementComponent_eventTryToTransition_Parms, bool);
			UProperty* NewProp_bIsJump = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsJump, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsJump, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), sizeof(bool), true);
			UProperty* NewProp_InWorldDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InWorldDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InWorldDirection, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForWorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForWorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ForWorldPosition, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitCharacterMovementComponent_eventTryToTransition_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bIsJump"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Attempts to do a transition inside a zone to a given direction\n@param       ForZone         Zone to start transition in\n@param       ForWorldPosition        Where to start the transition\n@param       InWorldDirection        The direction the player wants to transition in\n@param       bIsJump         True if the character attempts to jump during the transition\n@return      True if a transition happened"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterMovementComponent_NoRegister()
	{
		return UAdvKitCharacterMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UCharacterMovementComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00280;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_AccumulateRootMotion());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_CanTransition());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_ChangeTargetBalance());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvCustomMovementMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvMovementMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredOffsetFromZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredRotationInZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetGlobalLocationInZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetHalfExtentForZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetPossibleTransition());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZoneLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_JumpUpZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_LetGoOfZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_MoveLocationInZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_PhysMoveInZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_SetAdvMovementMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_TryToTransition());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_AdvKitCharacterOwner = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AdvKitCharacterOwner"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AdvKitCharacterOwner, UAdvKitCharacterMovementComponent), 0x0020080000000000, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
				UProperty* NewProp_BalanceChangeTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BalanceChangeTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BalanceChangeTime, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_MaxBalance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxBalance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxBalance, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_MaxBalanceChangePerSecond = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxBalanceChangePerSecond"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxBalanceChangePerSecond, UAdvKitCharacterMovementComponent), 0x0010000000000015);
				UProperty* NewProp_MinBalanceChangePerSecond = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinBalanceChangePerSecond"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinBalanceChangePerSecond, UAdvKitCharacterMovementComponent), 0x0010000000000015);
				UProperty* NewProp_BalanceChangePerSecond = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BalanceChangePerSecond"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BalanceChangePerSecond, UAdvKitCharacterMovementComponent), 0x0010000000002004);
				UProperty* NewProp_MaxBalanceTurnAroundDot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxBalanceTurnAroundDot"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxBalanceTurnAroundDot, UAdvKitCharacterMovementComponent), 0x0010000000002015);
				UProperty* NewProp_MinCounterBalanceDot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinCounterBalanceDot"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinCounterBalanceDot, UAdvKitCharacterMovementComponent), 0x0010000000002015);
				UProperty* NewProp_CounterBalanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CounterBalanceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(CounterBalanceMultiplier, UAdvKitCharacterMovementComponent), 0x0010000000002015);
				UProperty* NewProp_CurrentBalance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentBalance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(CurrentBalance, UAdvKitCharacterMovementComponent), 0x0010000000022805);
				UProperty* NewProp_BalanceRotationRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BalanceRotationRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BalanceRotationRate, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_BalanceOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BalanceOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(BalanceOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_MaxBalanceWalkSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxBalanceWalkSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxBalanceWalkSpeed, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_MaxTightSpaceWalkSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxTightSpaceWalkSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxTightSpaceWalkSpeed, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_TightSpaceOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TightSpaceOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TightSpaceOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_CeilingMinTransitionDot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CeilingMinTransitionDot"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(CeilingMinTransitionDot, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_CeilingOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CeilingOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(CeilingOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_MaxCeilingClimbSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxCeilingClimbSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxCeilingClimbSpeed, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_MaxWallClimbSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxWallClimbSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxWallClimbSpeed, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_WallOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WallOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WallOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_LadderOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LadderOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LadderOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_MaxLadderClimbSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxLadderClimbSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxLadderClimbSpeed, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LadderJumpDistanceHorizontal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LadderJumpDistanceHorizontal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LadderJumpDistanceHorizontal, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LedgeOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgeOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LedgeOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_MaxLedgeClimbSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxLedgeClimbSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxLedgeClimbSpeed, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LedgeJumpDistanceHorizontal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgeJumpDistanceHorizontal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LedgeJumpDistanceHorizontal, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LedgeJumpDistanceVertical = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgeJumpDistanceVertical"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LedgeJumpDistanceVertical, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LedgeSmallHeightOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgeSmallHeightOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LedgeSmallHeightOffset, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LedgeDownTraceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgeDownTraceDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LedgeDownTraceDistance, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_LedgePrecognitionDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LedgePrecognitionDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LedgePrecognitionDistance, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_JumpDistanceLedgeLadderHorizontal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("JumpDistanceLedgeLadderHorizontal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(JumpDistanceLedgeLadderHorizontal, UAdvKitCharacterMovementComponent), 0x0010000000000005);
				UProperty* NewProp_AdvMovementProps = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AdvMovementProps"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AdvMovementProps, UAdvKitCharacterMovementComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FAdvKitMovementProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_AccumulateRootMotion(), "AccumulateRootMotion"); // 3119250175
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_CanTransition(), "CanTransition"); // 3072741873
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_ChangeTargetBalance(), "ChangeTargetBalance"); // 209951591
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvCustomMovementMode(), "GetAdvCustomMovementMode"); // 3811371476
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetAdvMovementMode(), "GetAdvMovementMode"); // 4187804638
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredOffsetFromZone(), "GetDesiredOffsetFromZone"); // 4258421818
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetDesiredRotationInZone(), "GetDesiredRotationInZone"); // 2775258223
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetGlobalLocationInZone(), "GetGlobalLocationInZone"); // 1481738900
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetHalfExtentForZone(), "GetHalfExtentForZone"); // 3781343849
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetPossibleTransition(), "GetPossibleTransition"); // 2373675375
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZone(), "GetZone"); // 3793034553
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_GetZoneLocation(), "GetZoneLocation"); // 719953541
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_JumpUpZone(), "JumpUpZone"); // 2637466255
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_LetGoOfZone(), "LetGoOfZone"); // 716089948
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_MoveLocationInZone(), "MoveLocationInZone"); // 2865331571
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_PhysMoveInZone(), "PhysMoveInZone"); // 2957960113
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_SetAdvMovementMode(), "SetAdvMovementMode"); // 2006303909
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterMovementComponent_TryToTransition(), "TryToTransition"); // 2671114644
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Default movement component for the @see AAdvKitCharacter. This handles zone movement and target locking."));
				MetaData->SetValue(NewProp_AdvKitCharacterOwner, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AdvKitCharacterOwner, TEXT("ToolTip"), TEXT("AdvKitCharacter movement component belongs to"));
				MetaData->SetValue(NewProp_BalanceChangeTime, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_BalanceChangeTime, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BalanceChangeTime, TEXT("ToolTip"), TEXT("How fast to change the target balance"));
				MetaData->SetValue(NewProp_MaxBalance, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_MaxBalance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxBalance, TEXT("ToolTip"), TEXT("Max balance, if Abs(Balance) is bigger or equals to this the character falls off"));
				MetaData->SetValue(NewProp_MaxBalanceChangePerSecond, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_MaxBalanceChangePerSecond, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxBalanceChangePerSecond, TEXT("ToolTip"), TEXT("How fast to change the balance to the target balance at maximum"));
				MetaData->SetValue(NewProp_MinBalanceChangePerSecond, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_MinBalanceChangePerSecond, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MinBalanceChangePerSecond, TEXT("ToolTip"), TEXT("How fast to change the balance to the target balance at minimum"));
				MetaData->SetValue(NewProp_BalanceChangePerSecond, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_BalanceChangePerSecond, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BalanceChangePerSecond, TEXT("ToolTip"), TEXT("How fast to change the balance to the target balance"));
				MetaData->SetValue(NewProp_MaxBalanceTurnAroundDot, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_MaxBalanceTurnAroundDot, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxBalanceTurnAroundDot, TEXT("ToolTip"), TEXT("How much the current forward and input directions need to differ in order for the character to turn around"));
				MetaData->SetValue(NewProp_MinCounterBalanceDot, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_MinCounterBalanceDot, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MinCounterBalanceDot, TEXT("ToolTip"), TEXT("If input does not align correctly with balance direction, this is the min dot required for input to count as counter balance"));
				MetaData->SetValue(NewProp_CounterBalanceMultiplier, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_CounterBalanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CounterBalanceMultiplier, TEXT("ToolTip"), TEXT("Scale to apply to player input trying to restore balance"));
				MetaData->SetValue(NewProp_CurrentBalance, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_CurrentBalance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CurrentBalance, TEXT("ToolTip"), TEXT("The balance the character has when in a balancing zone"));
				MetaData->SetValue(NewProp_BalanceRotationRate, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_BalanceRotationRate, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BalanceRotationRate, TEXT("ToolTip"), TEXT("How fast the character turns inside a balance zone in degrees per second"));
				MetaData->SetValue(NewProp_BalanceOffset, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_BalanceOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_BalanceOffset, TEXT("ToolTip"), TEXT("What offset to keep from a balance zone"));
				MetaData->SetValue(NewProp_MaxBalanceWalkSpeed, TEXT("Category"), TEXT("Adv Character Movement: Balance"));
				MetaData->SetValue(NewProp_MaxBalanceWalkSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxBalanceWalkSpeed, TEXT("ToolTip"), TEXT("How fast the character moves when balancing"));
				MetaData->SetValue(NewProp_MaxTightSpaceWalkSpeed, TEXT("Category"), TEXT("Adv Character Movement: Tight Space"));
				MetaData->SetValue(NewProp_MaxTightSpaceWalkSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxTightSpaceWalkSpeed, TEXT("ToolTip"), TEXT("How fast the character moves inside a tight space"));
				MetaData->SetValue(NewProp_TightSpaceOffset, TEXT("Category"), TEXT("Adv Character Movement: Tight Space"));
				MetaData->SetValue(NewProp_TightSpaceOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_TightSpaceOffset, TEXT("ToolTip"), TEXT("What offset to keep from it when in a tight space"));
				MetaData->SetValue(NewProp_CeilingMinTransitionDot, TEXT("Category"), TEXT("Adv Character Movement: Ceiling"));
				MetaData->SetValue(NewProp_CeilingMinTransitionDot, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CeilingMinTransitionDot, TEXT("ToolTip"), TEXT("The minimum orientation difference betweeen the character and a wall to start transitioning"));
				MetaData->SetValue(NewProp_CeilingOffset, TEXT("Category"), TEXT("Adv Character Movement: Ceiling"));
				MetaData->SetValue(NewProp_CeilingOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_CeilingOffset, TEXT("ToolTip"), TEXT("What offset to keep from the ceiling if the character is climbing on it"));
				MetaData->SetValue(NewProp_MaxCeilingClimbSpeed, TEXT("Category"), TEXT("Adv Character Movement: Ceiling"));
				MetaData->SetValue(NewProp_MaxCeilingClimbSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxCeilingClimbSpeed, TEXT("ToolTip"), TEXT("How fast the character can climb on a ceiling"));
				MetaData->SetValue(NewProp_MaxWallClimbSpeed, TEXT("Category"), TEXT("Adv Character Movement: Wall"));
				MetaData->SetValue(NewProp_MaxWallClimbSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxWallClimbSpeed, TEXT("ToolTip"), TEXT("How fast the character can climb on a wall"));
				MetaData->SetValue(NewProp_WallOffset, TEXT("Category"), TEXT("Adv Character Movement: Wall"));
				MetaData->SetValue(NewProp_WallOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_WallOffset, TEXT("ToolTip"), TEXT("What offset to keep from it when climbing a wall"));
				MetaData->SetValue(NewProp_LadderOffset, TEXT("Category"), TEXT("Adv Character Movement: Ladder"));
				MetaData->SetValue(NewProp_LadderOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LadderOffset, TEXT("ToolTip"), TEXT("What offset to have from the ladder the character is climbing on"));
				MetaData->SetValue(NewProp_MaxLadderClimbSpeed, TEXT("Category"), TEXT("Adv Character Movement: Ladder"));
				MetaData->SetValue(NewProp_MaxLadderClimbSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxLadderClimbSpeed, TEXT("ToolTip"), TEXT("How fast the character climbs a ladder"));
				MetaData->SetValue(NewProp_LadderJumpDistanceHorizontal, TEXT("Category"), TEXT("Adv Character Movement: Ladder"));
				MetaData->SetValue(NewProp_LadderJumpDistanceHorizontal, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LadderJumpDistanceHorizontal, TEXT("ToolTip"), TEXT("How far the character can jump horizontally from a ladder"));
				MetaData->SetValue(NewProp_LedgeOffset, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_LedgeOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgeOffset, TEXT("ToolTip"), TEXT("What local offset to keep from a ledge while climbing it"));
				MetaData->SetValue(NewProp_MaxLedgeClimbSpeed, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_MaxLedgeClimbSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_MaxLedgeClimbSpeed, TEXT("ToolTip"), TEXT("How fast the character can climb on a ledge"));
				MetaData->SetValue(NewProp_LedgeJumpDistanceHorizontal, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_LedgeJumpDistanceHorizontal, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgeJumpDistanceHorizontal, TEXT("ToolTip"), TEXT("How far the character can jump horizontally from a ledge"));
				MetaData->SetValue(NewProp_LedgeJumpDistanceVertical, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_LedgeJumpDistanceVertical, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgeJumpDistanceVertical, TEXT("ToolTip"), TEXT("How far the character can jump vertically from a ledge"));
				MetaData->SetValue(NewProp_LedgeSmallHeightOffset, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_LedgeSmallHeightOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgeSmallHeightOffset, TEXT("ToolTip"), TEXT("How far above the ground to start tracing"));
				MetaData->SetValue(NewProp_LedgeDownTraceDistance, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_LedgeDownTraceDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgeDownTraceDistance, TEXT("ToolTip"), TEXT("How far down to trace to consider a cliff for ledges"));
				MetaData->SetValue(NewProp_LedgePrecognitionDistance, TEXT("Category"), TEXT("Adv Character Movement: Ledge"));
				MetaData->SetValue(NewProp_LedgePrecognitionDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_LedgePrecognitionDistance, TEXT("ToolTip"), TEXT("How far ahead to trace for a ledge below when walking"));
				MetaData->SetValue(NewProp_JumpDistanceLedgeLadderHorizontal, TEXT("Category"), TEXT("Adv Character Movement: Transitions"));
				MetaData->SetValue(NewProp_JumpDistanceLedgeLadderHorizontal, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_JumpDistanceLedgeLadderHorizontal, TEXT("ToolTip"), TEXT("How far the character can jump horizontally between ladder and ledge"));
				MetaData->SetValue(NewProp_AdvMovementProps, TEXT("Category"), TEXT("Movement Capabilities"));
				MetaData->SetValue(NewProp_AdvMovementProps, TEXT("DisplayName"), TEXT("Adv Movement Capabilities"));
				MetaData->SetValue(NewProp_AdvMovementProps, TEXT("Keywords"), TEXT("Nav Agent"));
				MetaData->SetValue(NewProp_AdvMovementProps, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_AdvMovementProps, TEXT("ToolTip"), TEXT("Movement properties for the adventure kit"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterMovementComponent(Z_Construct_UClass_UAdvKitCharacterMovementComponent, &UAdvKitCharacterMovementComponent::StaticClass, TEXT("UAdvKitCharacterMovementComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterMovementComponent);
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Arguments_CreateArguments()
	{
		struct AdvKitCharacterAction_Arguments_eventCreateArguments_Parms
		{
			UObject* WorldContextObject;
			TSubclassOf<UAdvKitCharacterAction_Arguments>  ArgumentClass;
			UAdvKitCharacterAction_Arguments* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction_Arguments();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateArguments"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(AdvKitCharacterAction_Arguments_eventCreateArguments_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_Arguments_eventCreateArguments_Parms), 0x0010000000000580, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			UProperty* NewProp_ArgumentClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ArgumentClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ArgumentClass, AdvKitCharacterAction_Arguments_eventCreateArguments_Parms), 0x0014000000000080, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_WorldContextObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContextObject"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WorldContextObject, AdvKitCharacterAction_Arguments_eventCreateArguments_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit|Actions"));
			MetaData->SetValue(ReturnFunction, TEXT("DefaultToSelf"), TEXT("WorldContextObject"));
			MetaData->SetValue(ReturnFunction, TEXT("HidePin"), TEXT("WorldContextObject"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_Arguments.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Blueprint hook to create an argument object.\n@param       WorldContextObject      Context object of the call\n@param       ArgumentClass   Class of argument to instantiate\n@return      The new argument object."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister()
	{
		return UAdvKitCharacterAction_Arguments::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_Arguments()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterAction_Arguments::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000081;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_Arguments_CreateArguments());

				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_Arguments_CreateArguments(), "CreateArguments"); // 2107678528
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AdvKitCharacterAction_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class to provide argument values to actions."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterAction_Arguments(Z_Construct_UClass_UAdvKitCharacterAction_Arguments, &UAdvKitCharacterAction_Arguments::StaticClass, TEXT("UAdvKitCharacterAction_Arguments"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterAction_Arguments);
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitActionResponseType"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdvKitActionResponseType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitActionResponseType::Success")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitActionResponseType::Failure")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitActionResponseType::Redirect")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitActionResponseType::NotFound")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitActionResponseType::EAdvKitActionResponseType_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EAdvKitActionResponseType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@brief Enumeration of possible response states for actions"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType_CRC() { return 2631359513U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAdvKitActionResponse()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FAdvKitActionResponse_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AdvKitActionResponse"), sizeof(FAdvKitActionResponse), Get_Z_Construct_UScriptStruct_FAdvKitActionResponse_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdvKitActionResponse"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAdvKitActionResponse>, EStructFlags(0x00000201));
			UProperty* NewProp_RedirectArguments = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RedirectArguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(RedirectArguments, FAdvKitActionResponse), 0x0010000000000014, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			UProperty* NewProp_RedirectAction = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RedirectAction"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(RedirectAction, FAdvKitActionResponse), 0x0014000000000014, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, FAdvKitActionResponse), 0x0010000000000014, Z_Construct_UEnum_AdvKitRuntime_EAdvKitActionResponseType());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Response struct when trying to start an action."));
			MetaData->SetValue(NewProp_RedirectArguments, TEXT("Category"), TEXT("AdvKitActionResponse"));
			MetaData->SetValue(NewProp_RedirectArguments, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(NewProp_RedirectArguments, TEXT("ToolTip"), TEXT("Arguments for the redirect action"));
			MetaData->SetValue(NewProp_RedirectAction, TEXT("Category"), TEXT("AdvKitActionResponse"));
			MetaData->SetValue(NewProp_RedirectAction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(NewProp_RedirectAction, TEXT("ToolTip"), TEXT("In case response is a redirect, this is the target action"));
			MetaData->SetValue(NewProp_Type, TEXT("Category"), TEXT("AdvKitActionResponse"));
			MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(NewProp_Type, TEXT("ToolTip"), TEXT("Type of response"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAdvKitActionResponse_CRC() { return 2221087215U; }
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_CanBeInterruptedBy()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanBeInterruptedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x48020C00, 65535, sizeof(AdvKitCharacterAction_eventCanBeInterruptedBy_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterAction_eventCanBeInterruptedBy_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterAction_eventCanBeInterruptedBy_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterAction_eventCanBeInterruptedBy_Parms), sizeof(bool), true);
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Other, AdvKitCharacterAction_eventCanBeInterruptedBy_Parms), 0x0010000000080082, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can this action be interrupted by another?\n@note This returning false does not make an action uninterruptible, since another action can\nreturn true in its CanInterrupt method. This is for easy extendability of action combinations\n@param       Other   The action that might be able to interrupt this action.\n@return                      true in case this action can be interrupted, false otherwise"));
			MetaData->SetValue(NewProp_Other, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_CanInterrupt()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanInterrupt"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x48020C00, 65535, sizeof(AdvKitCharacterAction_eventCanInterrupt_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacterAction_eventCanInterrupt_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacterAction_eventCanInterrupt_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacterAction_eventCanInterrupt_Parms), sizeof(bool), true);
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Other, AdvKitCharacterAction_eventCanInterrupt_Parms), 0x0010000000080082, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can this action interrupt another action?\n@param       Other   The action that might be interruptible\n@return                      true in case the other action can be interrupted, false otherwise"));
			MetaData->SetValue(NewProp_Other, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Failed()
	{
		struct AdvKitCharacterAction_eventFailed_Parms
		{
			FAdvKitActionResponse ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Failed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(AdvKitCharacterAction_eventFailed_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_eventFailed_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FAdvKitActionResponse());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a fail response\n@return      Response struct with fail flags"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_GetAdditionalRequiredActions()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAdditionalRequiredActions"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020C00, 65535, sizeof(AdvKitCharacterAction_eventGetAdditionalRequiredActions_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_eventGetAdditionalRequiredActions_Parms), 0x0014000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If this action requires sub actions to work, it can return the required actions as classes to\nbe instantiated by the action manager.\n@returns     List of required actions"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_OnMontageEnded()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnMontageEnded"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitCharacterAction_eventOnMontageEnded_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInterrupted, AdvKitCharacterAction_eventOnMontageEnded_Parms, bool);
			UProperty* NewProp_bInterrupted = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInterrupted"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInterrupted, AdvKitCharacterAction_eventOnMontageEnded_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInterrupted, AdvKitCharacterAction_eventOnMontageEnded_Parms), sizeof(bool), true);
			UProperty* NewProp_EndedMontage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EndedMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(EndedMontage, AdvKitCharacterAction_eventOnMontageEnded_Parms), 0x0010000000000080, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when a montage played on the CharacterOwner has ended"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_PlayAnimMontage()
	{
		struct AdvKitCharacterAction_eventPlayAnimMontage_Parms
		{
			UAnimMontage* Montage;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayAnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04080400, 65535, sizeof(AdvKitCharacterAction_eventPlayAnimMontage_Parms));
			UProperty* NewProp_Montage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Montage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Montage, AdvKitCharacterAction_eventPlayAnimMontage_Parms), 0x0010000000000080, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Plays an AnimMontage on the CharacterOwner."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Redirect()
	{
		struct AdvKitCharacterAction_eventRedirect_Parms
		{
			TSubclassOf<UAdvKitCharacterAction>  ToAction;
			UAdvKitCharacterAction_Arguments* WithArguments;
			FAdvKitActionResponse ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Redirect"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(AdvKitCharacterAction_eventRedirect_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_eventRedirect_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FAdvKitActionResponse());
			UProperty* NewProp_WithArguments = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithArguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithArguments, AdvKitCharacterAction_eventRedirect_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			UProperty* NewProp_ToAction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ToAction"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ToAction, AdvKitCharacterAction_eventRedirect_Parms), 0x0014000000000080, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Redirect to another action\n@param       ToAction                Action class to redirect to\n@param       WithArguments   Arguments to pass to the redirected action\n@return      Response struct with redirection"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Start()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Start"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitCharacterAction_eventStart_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_eventStart_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FAdvKitActionResponse());
			UProperty* NewProp_InterruptedOther = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InterruptedOther"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InterruptedOther, AdvKitCharacterAction_eventStart_Parms), 0x0010000000080080, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
			UProperty* NewProp_Arguments = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Arguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Arguments, AdvKitCharacterAction_eventStart_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Starts the action.\n@param       Arguments       Optional arguments for the action.\n@param       InterruptedOther        Optional action that was interrupted when starting this action\n@return      Response containing more information about the state of the action."));
			MetaData->SetValue(NewProp_InterruptedOther, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Stop()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Stop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitCharacterAction_eventStop_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_eventStop_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FAdvKitActionResponse());
			UProperty* NewProp_InterruptedBy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InterruptedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InterruptedBy, AdvKitCharacterAction_eventStop_Parms), 0x0010000000080082, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops the action\n@note Every action can potentially be interrupted, an action cannot revoke interrupts.\n@param       InterruptedBy   (Optional) The action that caused to stop this action prematurely.\n@return      Response containing more information about the state of the action."));
			MetaData->SetValue(NewProp_InterruptedBy, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitCharacterAction_Succeeded()
	{
		struct AdvKitCharacterAction_eventSucceeded_Parms
		{
			FAdvKitActionResponse ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitCharacterAction();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Succeeded"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(AdvKitCharacterAction_eventSucceeded_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacterAction_eventSucceeded_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FAdvKitActionResponse());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a success response\n@return      Response struct with success flags"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_NoRegister()
	{
		return UAdvKitCharacterAction::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterAction()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterAction::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_CanBeInterruptedBy());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_CanInterrupt());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_Failed());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_GetAdditionalRequiredActions());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_OnMontageEnded());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_PlayAnimMontage());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_Redirect());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_Start());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_Stop());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCharacterAction_Succeeded());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MovementComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(MovementComponent, UAdvKitCharacterAction), 0x00200800000a083d, Z_Construct_UClass_UAdvKitCharacterMovementComponent_NoRegister());
				UProperty* NewProp_CharacterOwner = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CharacterOwner"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CharacterOwner, UAdvKitCharacterAction), 0x0020080000020835, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
				UProperty* NewProp_StopModifiers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StopModifiers"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(StopModifiers, UAdvKitCharacterAction), 0x002008800001001d);
				UProperty* NewProp_StopModifiers_Inner = new(EC_InternalUseOnlyConstructor, NewProp_StopModifiers, TEXT("StopModifiers"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier_NoRegister());
				UProperty* NewProp_StartModifiers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StartModifiers"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(StartModifiers, UAdvKitCharacterAction), 0x002008800001001d);
				UProperty* NewProp_StartModifiers_Inner = new(EC_InternalUseOnlyConstructor, NewProp_StartModifiers, TEXT("StartModifiers"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_CanBeInterruptedBy(), "CanBeInterruptedBy"); // 1544845336
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_CanInterrupt(), "CanInterrupt"); // 1393141841
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_Failed(), "Failed"); // 174116134
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_GetAdditionalRequiredActions(), "GetAdditionalRequiredActions"); // 1234655558
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_OnMontageEnded(), "OnMontageEnded"); // 1228498042
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_PlayAnimMontage(), "PlayAnimMontage"); // 792632484
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_Redirect(), "Redirect"); // 816100243
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_Start(), "Start"); // 3943531729
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_Stop(), "Stop"); // 1270330786
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCharacterAction_Succeeded(), "Succeeded"); // 1321288707
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT(", Within = AdvKitCharacterActionManager"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("ToolTip"), TEXT("MovementComponent of the CharacterOwner"));
				MetaData->SetValue(NewProp_CharacterOwner, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_CharacterOwner, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(NewProp_CharacterOwner, TEXT("ToolTip"), TEXT("Character that is executing this action"));
				MetaData->SetValue(NewProp_StopModifiers, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_StopModifiers, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_StopModifiers, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(NewProp_StopModifiers, TEXT("Tooltip"), TEXT("Configurations for the character once the action stops."));
				MetaData->SetValue(NewProp_StopModifiers_Inner, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_StopModifiers_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_StopModifiers_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(NewProp_StopModifiers_Inner, TEXT("Tooltip"), TEXT("Configurations for the character once the action stops."));
				MetaData->SetValue(NewProp_StartModifiers, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_StartModifiers, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_StartModifiers, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(NewProp_StartModifiers, TEXT("Tooltip"), TEXT("Configurations for the character once the action starts."));
				MetaData->SetValue(NewProp_StartModifiers_Inner, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_StartModifiers_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_StartModifiers_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction.h"));
				MetaData->SetValue(NewProp_StartModifiers_Inner, TEXT("Tooltip"), TEXT("Configurations for the character once the action starts."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterAction(Z_Construct_UClass_UAdvKitCharacterAction, &UAdvKitCharacterAction::StaticClass, TEXT("UAdvKitCharacterAction"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterAction);
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitCameraType"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdvKitCameraType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitCameraType::FirstPerson")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitCameraType::ThirdPerson")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitCameraType::Shoulder")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitCameraType::TargetLocked")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitCameraType::Unkown")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitCameraType::EAdvKitCameraType_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EAdvKitCameraType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@brief Enumeration to distinguish the integrated camera modes of the kit."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType_CRC() { return 3124901160U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRepAdvKitAnimMontage()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FRepAdvKitAnimMontage_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RepAdvKitAnimMontage"), sizeof(FRepAdvKitAnimMontage), Get_Z_Construct_UScriptStruct_FRepAdvKitAnimMontage_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RepAdvKitAnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRepAdvKitAnimMontage>, EStructFlags(0x00000001));
			UProperty* NewProp_StartSectionName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("StartSectionName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(StartSectionName, FRepAdvKitAnimMontage), 0x0010000000000000);
			UProperty* NewProp_PlayRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PlayRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PlayRate, FRepAdvKitAnimMontage), 0x0010000000000000);
			UProperty* NewProp_AnimCounter = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AnimCounter"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(AnimCounter, FRepAdvKitAnimMontage), 0x0010000000000000);
			UProperty* NewProp_Montage = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Montage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Montage, FRepAdvKitAnimMontage), 0x0010000000000000, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Helper struct to replicated @see UAnimMontage on the character"));
			MetaData->SetValue(NewProp_StartSectionName, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(NewProp_StartSectionName, TEXT("ToolTip"), TEXT("Which section to start playing"));
			MetaData->SetValue(NewProp_PlayRate, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(NewProp_PlayRate, TEXT("ToolTip"), TEXT("How fast to play the montage"));
			MetaData->SetValue(NewProp_AnimCounter, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(NewProp_AnimCounter, TEXT("ToolTip"), TEXT("Counter to make sure each new play of a montage is replicated"));
			MetaData->SetValue(NewProp_Montage, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(NewProp_Montage, TEXT("ToolTip"), TEXT("Anim montage that is being replicated"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRepAdvKitAnimMontage_CRC() { return 1667797831U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAdvKitInventoryConfig()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FAdvKitInventoryConfig_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AdvKitInventoryConfig"), sizeof(FAdvKitInventoryConfig), Get_Z_Construct_UScriptStruct_FAdvKitInventoryConfig_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdvKitInventoryConfig"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAdvKitInventoryConfig>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEquip, FAdvKitInventoryConfig, bool);
			UProperty* NewProp_bEquip = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEquip, FAdvKitInventoryConfig), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bEquip, FAdvKitInventoryConfig), sizeof(bool), true);
			UProperty* NewProp_InventoryClass = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InventoryClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(InventoryClass, FAdvKitInventoryConfig), 0x0014000000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Utility struct to allow configuring an inventory item on the character."));
			MetaData->SetValue(NewProp_bEquip, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(NewProp_bEquip, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(NewProp_bEquip, TEXT("ToolTip"), TEXT("Whether or not this item will be equipped on start"));
			MetaData->SetValue(NewProp_InventoryClass, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(NewProp_InventoryClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(NewProp_InventoryClass, TEXT("ToolTip"), TEXT("Class of the item to create"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAdvKitInventoryConfig_CRC() { return 3000526189U; }
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_AddConditionalMovementInput()
	{
		struct AdvKitCharacter_eventAddConditionalMovementInput_Parms
		{
			FVector WorldDirection;
			FVector LocalDirection;
			float ScaleValue;
			bool bForce;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddConditionalMovementInput"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitCharacter_eventAddConditionalMovementInput_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForce, AdvKitCharacter_eventAddConditionalMovementInput_Parms, bool);
			UProperty* NewProp_bForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForce"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForce, AdvKitCharacter_eventAddConditionalMovementInput_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bForce, AdvKitCharacter_eventAddConditionalMovementInput_Parms), sizeof(bool), true);
			UProperty* NewProp_ScaleValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ScaleValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ScaleValue, AdvKitCharacter_eventAddConditionalMovementInput_Parms), 0x0010000000000080);
			UProperty* NewProp_LocalDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LocalDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalDirection, AdvKitCharacter_eventAddConditionalMovementInput_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldDirection, AdvKitCharacter_eventAddConditionalMovementInput_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Character|Input"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bForce"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_ScaleValue"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("AddInput"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Wraps AddMovementInput and transforms local direction in case of certain zone movement modes (Wall, Ledge and Ladder) instead of using world direction.\n\n@param       WorldDirection  Direction in world space to apply input\n@param       LocalDirection  Direction of input in character space\n@param       ScaleValue              Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value, while -1.0 would reverse the direction.\n@param       bForce                  If true always add the input, ignoring the result of IsMoveInputIgnored().\n@see AddMovementInput"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockAnyDamage()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlockAnyDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020C04, 65535, sizeof(AdvKitCharacter_eventBlockAnyDamage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventBlockAnyDamage_Parms), 0x0010000000000580);
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, AdvKitCharacter_eventBlockAnyDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_InstigatedBy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstigatedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InstigatedBy, AdvKitCharacter_eventBlockAnyDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_DamageType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageType"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageType, AdvKitCharacter_eventBlockAnyDamage_Parms), 0x0010000000000082, Z_Construct_UClass_UDamageType_NoRegister());
			UProperty* NewProp_DamageReceived = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageReceived"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DamageReceived, AdvKitCharacter_eventBlockAnyDamage_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Hook method to block any incoming damage.\n@param       DamageReceived  How much damage to apply\n@param       DamageType              Type of damage\n@param       InstigatedBy    The Controller responsible for the damage\n@param       DamageCauser    The Actor that directly caused the damage(e.g.the projectile that exploded, the rock that landed on you)\n@return      The amount of damage remaining after it was blocked"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockDamage()
	{
		struct AdvKitCharacter_eventBlockDamage_Parms
		{
			float Damage;
			FDamageEvent DamageEvent;
			AController* EventInstigator;
			AActor* DamageCauser;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlockDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00420401, 65535, sizeof(AdvKitCharacter_eventBlockDamage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventBlockDamage_Parms), 0x0010000000000580);
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, AdvKitCharacter_eventBlockDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_EventInstigator = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EventInstigator"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(EventInstigator, AdvKitCharacter_eventBlockDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_DamageEvent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageEvent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DamageEvent, AdvKitCharacter_eventBlockDamage_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FDamageEvent());
			UProperty* NewProp_Damage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Damage"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Damage, AdvKitCharacter_eventBlockDamage_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Hook method to block incoming damage.\n@param       Damage  How much damage to apply\n@param       DamageEvent             Data package that fully describes the damage received\n@param       EventInstigator The Controller responsible for the damage\n@param       DamageCauser    The Actor that directly caused the damage(e.g.the projectile that exploded, the rock that landed on you)\n@return      The amount of damage remaining after it was blocked"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockPointDamage()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlockPointDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08820C04, 65535, sizeof(AdvKitCharacter_eventBlockPointDamage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000580);
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_InstigatedBy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstigatedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InstigatedBy, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_ShotFromDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ShotFromDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ShotFromDirection, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(BoneName, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080);
			UProperty* NewProp_HitComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(HitComponent, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_HitNormal = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitNormal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HitNormal, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_HitLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HitLocation, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DamageType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageType"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageType, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000082, Z_Construct_UClass_UDamageType_NoRegister());
			UProperty* NewProp_DamageReceived = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageReceived"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DamageReceived, AdvKitCharacter_eventBlockPointDamage_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Hook method to block any incoming point damage.\n@param       DamageReceived  How much damage to apply\n@param       DamageType              Type of damage\n@param       HitLocation             Where the damage hit the character\n@param       HitNormal               Normal of the hit on the character\n@param       HitComponent    Which component was hit\n@param       BoneName                Which bone in the component was hit\n@param       ShotDirection   Where the damage came from\n@param       InstigatedBy    The Controller responsible for the damage\n@param       DamageCauser    The Actor that directly caused the damage(e.g.the projectile that exploded, the rock that landed on you)\n@return      The amount of damage remaining after it was blocked"));
			MetaData->SetValue(NewProp_HitComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_BlockRadialDamage()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlockRadialDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08C20C04, 65535, sizeof(AdvKitCharacter_eventBlockRadialDamage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010000000000580);
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_InstigatedBy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InstigatedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InstigatedBy, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_HitInfo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitInfo"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HitInfo, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Origin, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DamageType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageType"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageType, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010000000000082, Z_Construct_UClass_UDamageType_NoRegister());
			UProperty* NewProp_DamageReceived = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageReceived"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DamageReceived, AdvKitCharacter_eventBlockRadialDamage_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Hook method to block any incoming radial damage.\n@param       DamageReceived  How much damage to apply\n@param       DamageType              Type of damage\n@param       Origin                  Origin of the radial damage\n@param       HitInfo                 Where the damage actually hit the character\n@param       InstigatedBy    The Controller responsible for the damage\n@param       DamageCauser    The Actor that directly caused the damage(e.g.the projectile that exploded, the rock that landed on you)\n@return      The amount of damage remaining after it was blocked"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_CanEnterZone()
	{
		struct AdvKitCharacter_eventCanEnterZone_Parms
		{
			AAdvKitZone* Zone;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanEnterZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventCanEnterZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventCanEnterZone_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventCanEnterZone_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventCanEnterZone_Parms), sizeof(bool), true);
			UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, AdvKitCharacter_eventCanEnterZone_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Zones"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if character can enter a zone\n@param       Zone    Zone to enter\n@return      True if zone can be entered"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_Died()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Died"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08C20C00, 65535, sizeof(AdvKitCharacter_eventDied_Parms));
			UProperty* NewProp_HitLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HitLocation, AdvKitCharacter_eventDied_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_DamageEvent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageEvent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DamageEvent, AdvKitCharacter_eventDied_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FDamageEvent());
			UProperty* NewProp_Killer = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Killer"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Killer, AdvKitCharacter_eventDied_Parms), 0x0010000000000080, Z_Construct_UClass_AController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when the character died\n@param       Killer          Who killed the character\n@param       DamageEvent     The damage event responsible for the kill\n@param       HitLocation     Where the damage that killed came from"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_Dodge()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Dodge"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Make the character dodge"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_DodgeServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DodgeServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to make the character dodge"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_EnterZone()
	{
		struct AdvKitCharacter_eventEnterZone_Parms
		{
			AAdvKitZone* Zone;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnterZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventEnterZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventEnterZone_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventEnterZone_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventEnterZone_Parms), sizeof(bool), true);
			UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, AdvKitCharacter_eventEnterZone_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Zones"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Attempts to enter a given zone\n@param       Zone    Zone to enter\n@return      True if zone was entered"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_EnterZoneServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnterZoneServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventEnterZoneServer_Parms));
			UProperty* NewProp_NewZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewZone, AdvKitCharacter_eventEnterZoneServer_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetActiveAction()
	{
		struct AdvKitCharacter_eventGetActiveAction_Parms
		{
			UAdvKitCharacterAction* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetActiveAction"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(AdvKitCharacter_eventGetActiveAction_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetActiveAction_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit|Actions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the action that the character is currently executing.\n@return      Action that is currently executed"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetAdvMovementComponent()
	{
		struct AdvKitCharacter_eventGetAdvMovementComponent_Parms
		{
			UAdvKitCharacterMovementComponent* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAdvMovementComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(AdvKitCharacter_eventGetAdvMovementComponent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetAdvMovementComponent_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitCharacterMovementComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the character's adv kit movement component.\n@return The character's adv kit movement component."));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetAimOffsets()
	{
		struct AdvKitCharacter_eventGetAimOffsets_Parms
		{
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAimOffsets"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54820400, 65535, sizeof(AdvKitCharacter_eventGetAimOffsets_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetAimOffsets_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get Aim direction offset from character rotation\n@return      Aim offset rotation"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetAllAvailableTargets()
	{
		struct AdvKitCharacter_eventGetAllAvailableTargets_Parms
		{
			TArray<AAdvKitTargetPoint*> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAllAvailableTargets"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventGetAllAvailableTargets_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetAllAvailableTargets_Parms), 0x0010000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AAdvKitTargetPoint_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Target"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets all targets the player can reach and lock on to.\n@return      Reachable targets"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetCameraMode()
	{
		struct AdvKitCharacter_eventGetCameraMode_Parms
		{
			TEnumAsByte<EAdvKitCameraType> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCameraMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventGetCameraMode_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetCameraMode_Parms), 0x0010000000000580, Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current camera mode\n@return      Current camera mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetZone()
	{
		struct AdvKitCharacter_eventGetZone_Parms
		{
			AAdvKitZone* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(AdvKitCharacter_eventGetZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetZone_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the zone the character is currently in.\n@return      Current zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_GetZoneLocation()
	{
		struct AdvKitCharacter_eventGetZoneLocation_Parms
		{
			UAdvKitZoneLocation* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZoneLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventGetZoneLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCharacter_eventGetZoneLocation_Parms), 0x0010000000000580, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the current zone location of the character\n@return      Current zone location"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsAlive()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsAlive"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitCharacter_eventIsAlive_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventIsAlive_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventIsAlive_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventIsAlive_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the character is still alive\n@return      True if still alive"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsDodging()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsDodging"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x5C020C00, 65535, sizeof(AdvKitCharacter_eventIsDodging_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventIsDodging_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventIsDodging_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventIsDodging_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the character is dodging\n@return      True if dodging"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsFirstPerson()
	{
		struct AdvKitCharacter_eventIsFirstPerson_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsFirstPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(AdvKitCharacter_eventIsFirstPerson_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventIsFirstPerson_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventIsFirstPerson_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventIsFirstPerson_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Is the character currently in first person mode?\n@return True if in first person mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsShoulderCam()
	{
		struct AdvKitCharacter_eventIsShoulderCam_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsShoulderCam"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(AdvKitCharacter_eventIsShoulderCam_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventIsShoulderCam_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventIsShoulderCam_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventIsShoulderCam_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Is the character currently in shoulder camera mode?\n@return True if in shoulder camera mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_IsThirdPerson()
	{
		struct AdvKitCharacter_eventIsThirdPerson_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsThirdPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020400, 65535, sizeof(AdvKitCharacter_eventIsThirdPerson_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventIsThirdPerson_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventIsThirdPerson_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventIsThirdPerson_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Is the character currently in third person mode?\n@return True if in third person mode"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_NextCamera()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NextCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("If the character has multiple cameras, switch to the next one"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_NextItem()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NextItem"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Equip the next item in the character's inventory"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_OnRep_RepAnimMontage()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_RepAnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback when anim montage was replicated."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_PlayAnimMontageServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayAnimMontageServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventPlayAnimMontageServer_Parms));
			UProperty* NewProp_StartSectionName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartSectionName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(StartSectionName, AdvKitCharacter_eventPlayAnimMontageServer_Parms), 0x0010000000000080);
			UProperty* NewProp_InPlayRate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InPlayRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InPlayRate, AdvKitCharacter_eventPlayAnimMontageServer_Parms), 0x0010000000000080);
			UProperty* NewProp_AnimMontage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AnimMontage, AdvKitCharacter_eventPlayAnimMontageServer_Parms), 0x0010000000000080, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to play an AnimMontage.\n@param       AnimMontage     Montage to play\n@param       InPlayRate      Speed at which to play montage\n@param       StartSectionName        Where to start playing"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_PreviousItem()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PreviousItem"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Equip the previous item in the character's inventory"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_Reload()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Reload"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Reloads the character's current weapon"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_ServerUse()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerUse"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventServerUse_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, AdvKitCharacter_eventServerUse_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_Useable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Useable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Useable, AdvKitCharacter_eventServerUse_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitUsable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to use a usable with a given item (e.g. a lock with a key)\n@param       Useable         Usable to use with optional item\n@param       WithItem        Optional item to use usable with"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetCameraMode()
	{
		struct AdvKitCharacter_eventSetCameraMode_Parms
		{
			TEnumAsByte<EAdvKitCameraType> NewMode;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCameraMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventSetCameraMode_Parms));
			UProperty* NewProp_NewMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewMode, AdvKitCharacter_eventSetCameraMode_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a specific camera mode.\n@param       Camera mode to set"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetCameraModeServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCameraModeServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventSetCameraModeServer_Parms));
			UProperty* NewProp_NewMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewMode, AdvKitCharacter_eventSetCameraModeServer_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to set a specific camera mode.\n@param       Camera mode to set"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetFirstPersonEnabledServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFirstPersonEnabledServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventSetFirstPersonEnabledServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnabled, AdvKitCharacter_eventSetFirstPersonEnabledServer_Parms, bool);
			UProperty* NewProp_bEnabled = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnabled, AdvKitCharacter_eventSetFirstPersonEnabledServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnabled, AdvKitCharacter_eventSetFirstPersonEnabledServer_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to set camera style to first person\n@param       True to enable first person, false to disable it"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetMouseCursorEnabled()
	{
		struct AdvKitCharacter_eventSetMouseCursorEnabled_Parms
		{
			bool bEnabled;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMouseCursorEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AdvKitCharacter_eventSetMouseCursorEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnabled, AdvKitCharacter_eventSetMouseCursorEnabled_Parms, bool);
			UProperty* NewProp_bEnabled = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnabled, AdvKitCharacter_eventSetMouseCursorEnabled_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bEnabled, AdvKitCharacter_eventSetMouseCursorEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bEnabled"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enable the mouse cursor for point and click\n@param       bEnabled        True to enable, false to disable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetTarget()
	{
		struct AdvKitCharacter_eventSetTarget_Parms
		{
			AAdvKitTargetPoint* NewTarget;
			bool bLock;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetTarget"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventSetTarget_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLock, AdvKitCharacter_eventSetTarget_Parms, bool);
			UProperty* NewProp_bLock = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bLock"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLock, AdvKitCharacter_eventSetTarget_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bLock, AdvKitCharacter_eventSetTarget_Parms), sizeof(bool), true);
			UProperty* NewProp_NewTarget = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTarget"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewTarget, AdvKitCharacter_eventSetTarget_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitTargetPoint_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bLock"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new target for the character\n@param       NewTarget       The target to set\n@param       bLock   True to lock onto the target"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZone()
	{
		struct AdvKitCharacter_eventSetZone_Parms
		{
			AAdvKitZone* NewZone;
			bool bSnap;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventSetZone_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSnap, AdvKitCharacter_eventSetZone_Parms, bool);
			UProperty* NewProp_bSnap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSnap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSnap, AdvKitCharacter_eventSetZone_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSnap, AdvKitCharacter_eventSetZone_Parms), sizeof(bool), true);
			UProperty* NewProp_NewZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewZone, AdvKitCharacter_eventSetZone_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSnap"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new zone for the character\n@param       NewZone         The new zone to set\n@param       bSnap           Snap character to the new zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocation()
	{
		struct AdvKitCharacter_eventSetZoneLocation_Parms
		{
			UAdvKitZoneLocation* NewLocation;
			bool bSnap;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetZoneLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventSetZoneLocation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSnap, AdvKitCharacter_eventSetZoneLocation_Parms, bool);
			UProperty* NewProp_bSnap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSnap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSnap, AdvKitCharacter_eventSetZoneLocation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSnap, AdvKitCharacter_eventSetZoneLocation_Parms), sizeof(bool), true);
			UProperty* NewProp_NewLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewLocation, AdvKitCharacter_eventSetZoneLocation_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSnap"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new zone and zone location for the character\n@param       NewLocation             New zone location to set\n@param       bSnap           Snap character to the new zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocationServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetZoneLocationServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventSetZoneLocationServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSnap, AdvKitCharacter_eventSetZoneLocationServer_Parms, bool);
			UProperty* NewProp_bSnap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSnap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSnap, AdvKitCharacter_eventSetZoneLocationServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSnap, AdvKitCharacter_eventSetZoneLocationServer_Parms), sizeof(bool), true);
			UProperty* NewProp_NewLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewLocation, AdvKitCharacter_eventSetZoneLocationServer_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to set a new zone and zone location for the character\n@param       NewLocation             New zone location to set\n@param       bSnap           Snap character to the new zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_SetZoneServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetZoneServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitCharacter_eventSetZoneServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSnap, AdvKitCharacter_eventSetZoneServer_Parms, bool);
			UProperty* NewProp_bSnap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSnap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSnap, AdvKitCharacter_eventSetZoneServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSnap, AdvKitCharacter_eventSetZoneServer_Parms), sizeof(bool), true);
			UProperty* NewProp_NewZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewZone, AdvKitCharacter_eventSetZoneServer_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to a new zone for the character\n@param       NewZone The new zone to set\n@param       bSnap           Snap character to the new zone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_StartAction()
	{
		struct AdvKitCharacter_eventStartAction_Parms
		{
			TSubclassOf<UAdvKitCharacterAction>  ActionClass;
			UAdvKitCharacterAction_Arguments* Arguments;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartAction"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventStartAction_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventStartAction_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventStartAction_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventStartAction_Parms), sizeof(bool), true);
			UProperty* NewProp_Arguments = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Arguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Arguments, AdvKitCharacter_eventStartAction_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			UProperty* NewProp_ActionClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActionClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ActionClass, AdvKitCharacter_eventStartAction_Parms), 0x0014000000000080, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tries to start a new character action on this character\n\n@param       ActionClass     Class of the action to start\n@param       Arguments       Arguments to supply when starting the action.\n@return      True if the given action was started"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_StartFire()
	{
		struct AdvKitCharacter_eventStartFire_Parms
		{
			uint8 FireMode;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartFire"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventStartFire_Parms));
			UProperty* NewProp_FireMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireMode, AdvKitCharacter_eventStartFire_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Starts firing with the currently equipped weapon\n@param       FireMode        Index of fire mode to start firing"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_StartTransitionActionTo()
	{
		struct AdvKitCharacter_eventStartTransitionActionTo_Parms
		{
			TEnumAsByte<EAdvKitMovementMode> NewMode;
			UAdvKitCharacterAction_Arguments* Arguments;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartTransitionActionTo"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventStartTransitionActionTo_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventStartTransitionActionTo_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventStartTransitionActionTo_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventStartTransitionActionTo_Parms), sizeof(bool), true);
			UProperty* NewProp_Arguments = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Arguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Arguments, AdvKitCharacter_eventStartTransitionActionTo_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			UProperty* NewProp_NewMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewMode, AdvKitCharacter_eventStartTransitionActionTo_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tries to start a transition action to a given movement mode\n\n@param       NewMode Target movement mode of the transition\n@param       Arguments       Arguments to supply when starting the action.\n@return      True if a transition was started"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_StopFire()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopFire"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops firing the currently equipped weapon"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_Use()
	{
		struct AdvKitCharacter_eventUse_Parms
		{
			AAdvKitUsable* Usable;
			AAdvKitInventoryItem* WithItem;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Use"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020401, 65535, sizeof(AdvKitCharacter_eventUse_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, AdvKitCharacter_eventUse_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_Usable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Usable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Usable, AdvKitCharacter_eventUse_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitUsable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Use a usable with a given item (e.g. a lock with a key)\n@param       Useable         Usable to use with optional item\n@param       WithItem        Optional item to use usable with"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitCharacter_UseClosestUseable()
	{
		struct AdvKitCharacter_eventUseClosestUseable_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UseClosestUseable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitCharacter_eventUseClosestUseable_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitCharacter_eventUseClosestUseable_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitCharacter_eventUseClosestUseable_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitCharacter_eventUseClosestUseable_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Use the usable closest to the character"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitCharacter_NoRegister()
	{
		return AAdvKitCharacter::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitCharacter()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ACharacter();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitCharacter::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_AddConditionalMovementInput());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_BlockAnyDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_BlockDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_BlockPointDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_BlockRadialDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_CanEnterZone());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_Died());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_Dodge());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_DodgeServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_EnterZone());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_EnterZoneServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetActiveAction());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetAdvMovementComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetAimOffsets());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetAllAvailableTargets());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetCameraMode());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetZone());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_GetZoneLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_IsAlive());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_IsDodging());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_IsFirstPerson());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_IsShoulderCam());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_IsThirdPerson());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_NextCamera());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_NextItem());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_OnRep_RepAnimMontage());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_PlayAnimMontageServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_PreviousItem());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_Reload());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_ServerUse());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetCameraMode());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetCameraModeServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetFirstPersonEnabledServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetMouseCursorEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetTarget());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetZone());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocationServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_SetZoneServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_StartAction());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_StartFire());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_StartTransitionActionTo());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_StopFire());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_Use());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacter_UseClosestUseable());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_RepAnimMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RepAnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(RepAnimMontage, AAdvKitCharacter), 0x0010000100000020, Z_Construct_UScriptStruct_FRepAdvKitAnimMontage());
				NewProp_RepAnimMontage->RepNotifyFunc = FName(TEXT("OnRep_RepAnimMontage"));
				UProperty* NewProp_LocationInZone = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocationInZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(LocationInZone, AAdvKitCharacter), 0x0020080000020825, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
				UProperty* NewProp_CameraType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CameraType, AAdvKitCharacter), 0x0010000000000015, Z_Construct_UEnum_AdvKitRuntime_EAdvKitCameraType());
				UProperty* NewProp_BaseLookUpRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BaseLookUpRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BaseLookUpRate, AAdvKitCharacter), 0x0010000000020015);
				UProperty* NewProp_BaseTurnRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BaseTurnRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BaseTurnRate, AAdvKitCharacter), 0x0010000000020015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFaceLockedTarget, AAdvKitCharacter, bool);
				UProperty* NewProp_bFaceLockedTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFaceLockedTarget"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFaceLockedTarget, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bFaceLockedTarget, AAdvKitCharacter), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLockTarget, AAdvKitCharacter, bool);
				UProperty* NewProp_bLockTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLockTarget"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLockTarget, AAdvKitCharacter), 0x0010000000020815, CPP_BOOL_PROPERTY_BITMASK(bLockTarget, AAdvKitCharacter), sizeof(bool), true);
				UProperty* NewProp_CurrentTarget = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentTarget"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CurrentTarget, AAdvKitCharacter), 0x0010000000020815, Z_Construct_UClass_AAdvKitTargetPoint_NoRegister());
				UProperty* NewProp_MaxTargetDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxTargetDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxTargetDistance, AAdvKitCharacter), 0x0010000000000015);
				UProperty* NewProp_InventoryManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InventoryManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InventoryManager, AAdvKitCharacter), 0x0010000000020835, Z_Construct_UClass_AAdvKitInventoryManager_NoRegister());
				UProperty* NewProp_InventoryManagerClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InventoryManagerClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(InventoryManagerClass, AAdvKitCharacter), 0x0014000000010015, Z_Construct_UClass_AAdvKitInventoryManager_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_DefaultInventory = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(DefaultInventory, AAdvKitCharacter), 0x0010000000000015);
				UProperty* NewProp_DefaultInventory_Inner = new(EC_InternalUseOnlyConstructor, NewProp_DefaultInventory, TEXT("DefaultInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAdvKitInventoryConfig());
				UProperty* NewProp_PointAndClickTraceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PointAndClickTraceDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PointAndClickTraceDistance, AAdvKitCharacter), 0x0010000000000015);
				UProperty* NewProp_ActionManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActionManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActionManager, AAdvKitCharacter), 0x0010000000020835, Z_Construct_UClass_AAdvKitCharacterActionManager_NoRegister());
				UProperty* NewProp_ActionManagerClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActionManagerClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ActionManagerClass, AAdvKitCharacter), 0x0014000000010015, Z_Construct_UClass_AAdvKitCharacterActionManager_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_DefaultActions = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultActions"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(DefaultActions, AAdvKitCharacter), 0x0014000000000015);
				UProperty* NewProp_DefaultActions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_DefaultActions, TEXT("DefaultActions"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_MaxHealth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxHealth"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxHealth, AAdvKitCharacter), 0x0010000000000025);
				UProperty* NewProp_Health = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Health"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Health, AAdvKitCharacter), 0x0010000000000025);
				UProperty* NewProp_TargetLockCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetLockCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetLockCamera, AAdvKitCharacter), 0x00100000000a001d, Z_Construct_UClass_UCameraComponent_NoRegister());
				UProperty* NewProp_ShoulderCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShoulderCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ShoulderCamera, AAdvKitCharacter), 0x00100000000a001d, Z_Construct_UClass_UCameraComponent_NoRegister());
				UProperty* NewProp_FirstPersonCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(FirstPersonCamera, AAdvKitCharacter), 0x00100000000a001d, Z_Construct_UClass_UCameraComponent_NoRegister());
				UProperty* NewProp_ThirdPersonCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ThirdPersonCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ThirdPersonCamera, AAdvKitCharacter), 0x00100000000a001d, Z_Construct_UClass_UCameraComponent_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInvincibleDuringDodge, AAdvKitCharacter, bool);
				UProperty* NewProp_bInvincibleDuringDodge = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInvincibleDuringDodge"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInvincibleDuringDodge, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bInvincibleDuringDodge, AAdvKitCharacter), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerRotationRollInFirstPerson, AAdvKitCharacter, bool);
				UProperty* NewProp_bUseControllerRotationRollInFirstPerson = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerRotationRollInFirstPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerRotationRollInFirstPerson, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseControllerRotationRollInFirstPerson, AAdvKitCharacter), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerRotationYawInFirstPerson, AAdvKitCharacter, bool);
				UProperty* NewProp_bUseControllerRotationYawInFirstPerson = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerRotationYawInFirstPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerRotationYawInFirstPerson, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseControllerRotationYawInFirstPerson, AAdvKitCharacter), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerRotationPitchInFirstPerson, AAdvKitCharacter, bool);
				UProperty* NewProp_bUseControllerRotationPitchInFirstPerson = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerRotationPitchInFirstPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerRotationPitchInFirstPerson, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseControllerRotationPitchInFirstPerson, AAdvKitCharacter), sizeof(bool), true);
				UProperty* NewProp_FirstPersonMaxCameraRoll = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonMaxCameraRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FirstPersonMaxCameraRoll, AAdvKitCharacter), 0x0010000000000005);
				UProperty* NewProp_FirstPersonMinCameraRoll = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonMinCameraRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FirstPersonMinCameraRoll, AAdvKitCharacter), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFirstPersonClampCameraRoll, AAdvKitCharacter, bool);
				UProperty* NewProp_bFirstPersonClampCameraRoll = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFirstPersonClampCameraRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFirstPersonClampCameraRoll, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bFirstPersonClampCameraRoll, AAdvKitCharacter), sizeof(bool), true);
				UProperty* NewProp_FirstPersonMaxCameraYaw = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonMaxCameraYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FirstPersonMaxCameraYaw, AAdvKitCharacter), 0x0010000000000005);
				UProperty* NewProp_FirstPersonMinCameraYaw = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonMinCameraYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FirstPersonMinCameraYaw, AAdvKitCharacter), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFirstPersonClampCameraYaw, AAdvKitCharacter, bool);
				UProperty* NewProp_bFirstPersonClampCameraYaw = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFirstPersonClampCameraYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFirstPersonClampCameraYaw, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bFirstPersonClampCameraYaw, AAdvKitCharacter), sizeof(bool), true);
				UProperty* NewProp_FirstPersonMaxCameraPitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonMaxCameraPitch"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FirstPersonMaxCameraPitch, AAdvKitCharacter), 0x0010000000000005);
				UProperty* NewProp_FirstPersonMinCameraPitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FirstPersonMinCameraPitch"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FirstPersonMinCameraPitch, AAdvKitCharacter), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFirstPersonClampCameraPitch, AAdvKitCharacter, bool);
				UProperty* NewProp_bFirstPersonClampCameraPitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFirstPersonClampCameraPitch"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFirstPersonClampCameraPitch, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bFirstPersonClampCameraPitch, AAdvKitCharacter), sizeof(bool), true);
				UProperty* NewProp_HeadSocket = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HeadSocket"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(HeadSocket, AAdvKitCharacter), 0x0010000000000005);
				UProperty* NewProp_CollisionChannelsToIgnoreInZones = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionChannelsToIgnoreInZones"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(CollisionChannelsToIgnoreInZones, AAdvKitCharacter), 0x0010000000000005);
				UProperty* NewProp_CollisionChannelsToIgnoreInZones_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CollisionChannelsToIgnoreInZones, TEXT("CollisionChannelsToIgnoreInZones"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_ECollisionChannel());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnterZonesFromOverlapAutomatically, AAdvKitCharacter, bool);
				UProperty* NewProp_bEnterZonesFromOverlapAutomatically = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnterZonesFromOverlapAutomatically"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnterZonesFromOverlapAutomatically, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnterZonesFromOverlapAutomatically, AAdvKitCharacter), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnterZonesFromHitAutomatically, AAdvKitCharacter, bool);
				UProperty* NewProp_bEnterZonesFromHitAutomatically = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnterZonesFromHitAutomatically"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnterZonesFromHitAutomatically, AAdvKitCharacter), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnterZonesFromHitAutomatically, AAdvKitCharacter), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_AddConditionalMovementInput(), "AddConditionalMovementInput"); // 2879599880
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_BlockAnyDamage(), "BlockAnyDamage"); // 177812144
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_BlockDamage(), "BlockDamage"); // 2691535869
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_BlockPointDamage(), "BlockPointDamage"); // 1884866227
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_BlockRadialDamage(), "BlockRadialDamage"); // 3789312270
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_CanEnterZone(), "CanEnterZone"); // 2280413108
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_Died(), "Died"); // 75133184
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_Dodge(), "Dodge"); // 2089159942
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_DodgeServer(), "DodgeServer"); // 26734771
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_EnterZone(), "EnterZone"); // 7863348
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_EnterZoneServer(), "EnterZoneServer"); // 3322977573
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetActiveAction(), "GetActiveAction"); // 297148812
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetAdvMovementComponent(), "GetAdvMovementComponent"); // 420855605
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetAimOffsets(), "GetAimOffsets"); // 2180920934
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetAllAvailableTargets(), "GetAllAvailableTargets"); // 123270540
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetCameraMode(), "GetCameraMode"); // 3939064542
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetZone(), "GetZone"); // 3999934157
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_GetZoneLocation(), "GetZoneLocation"); // 423010713
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_IsAlive(), "IsAlive"); // 719519380
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_IsDodging(), "IsDodging"); // 877171505
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_IsFirstPerson(), "IsFirstPerson"); // 1707226191
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_IsShoulderCam(), "IsShoulderCam"); // 3937561794
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_IsThirdPerson(), "IsThirdPerson"); // 3589259414
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_NextCamera(), "NextCamera"); // 3026185017
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_NextItem(), "NextItem"); // 590185469
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_OnRep_RepAnimMontage(), "OnRep_RepAnimMontage"); // 853110543
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_PlayAnimMontageServer(), "PlayAnimMontageServer"); // 382971863
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_PreviousItem(), "PreviousItem"); // 1762616038
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_Reload(), "Reload"); // 2821583014
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_ServerUse(), "ServerUse"); // 2119467004
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetCameraMode(), "SetCameraMode"); // 2272663419
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetCameraModeServer(), "SetCameraModeServer"); // 2652158648
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetFirstPersonEnabledServer(), "SetFirstPersonEnabledServer"); // 3794561515
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetMouseCursorEnabled(), "SetMouseCursorEnabled"); // 4270663328
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetTarget(), "SetTarget"); // 150561864
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetZone(), "SetZone"); // 1340982352
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocation(), "SetZoneLocation"); // 3610598542
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetZoneLocationServer(), "SetZoneLocationServer"); // 3537117069
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_SetZoneServer(), "SetZoneServer"); // 1521636855
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_StartAction(), "StartAction"); // 1316899856
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_StartFire(), "StartFire"); // 511261434
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_StartTransitionActionTo(), "StartTransitionActionTo"); // 1600597592
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_StopFire(), "StopFire"); // 3645975846
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_Use(), "Use"); // 1806956323
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacter_UseClosestUseable(), "UseClosestUseable"); // 3964872342
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base character class of the Adventure Kit.\n\nThis character can use zones, inventory items and execute character actions.\nIt also provides functionality for several different camera styles and locking onto a target."));
				MetaData->SetValue(NewProp_RepAnimMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_RepAnimMontage, TEXT("ToolTip"), TEXT("Property that contains all required values for replicated the played AnimMontage"));
				MetaData->SetValue(NewProp_LocationInZone, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_LocationInZone, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_LocationInZone, TEXT("ToolTip"), TEXT("Current location in the zone the character currently is in"));
				MetaData->SetValue(NewProp_CameraType, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_CameraType, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_CameraType, TEXT("ToolTip"), TEXT("Active camera mode"));
				MetaData->SetValue(NewProp_BaseLookUpRate, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_BaseLookUpRate, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_BaseLookUpRate, TEXT("ToolTip"), TEXT("Base look up/down rate, in deg/sec. Other scaling may affect final rate."));
				MetaData->SetValue(NewProp_BaseTurnRate, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_BaseTurnRate, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_BaseTurnRate, TEXT("ToolTip"), TEXT("Base turn rate, in deg/sec. Other scaling may affect final turn rate."));
				MetaData->SetValue(NewProp_bFaceLockedTarget, TEXT("Category"), TEXT("Target"));
				MetaData->SetValue(NewProp_bFaceLockedTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bFaceLockedTarget, TEXT("ToolTip"), TEXT("Whether or not to face a target that has been locked"));
				MetaData->SetValue(NewProp_bLockTarget, TEXT("Category"), TEXT("Target"));
				MetaData->SetValue(NewProp_bLockTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bLockTarget, TEXT("ToolTip"), TEXT("Whether the target is locked in"));
				MetaData->SetValue(NewProp_CurrentTarget, TEXT("Category"), TEXT("Target"));
				MetaData->SetValue(NewProp_CurrentTarget, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_CurrentTarget, TEXT("ToolTip"), TEXT("Currently targeted component"));
				MetaData->SetValue(NewProp_MaxTargetDistance, TEXT("Category"), TEXT("Target"));
				MetaData->SetValue(NewProp_MaxTargetDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_MaxTargetDistance, TEXT("ToolTip"), TEXT("How far away targets can be for auto targeting"));
				MetaData->SetValue(NewProp_InventoryManager, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_InventoryManager, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_InventoryManager, TEXT("ToolTip"), TEXT("Inventory manager this character uses"));
				MetaData->SetValue(NewProp_InventoryManagerClass, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_InventoryManagerClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_InventoryManagerClass, TEXT("ToolTip"), TEXT("Class of the inventory manager for this character"));
				MetaData->SetValue(NewProp_DefaultInventory, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_DefaultInventory, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_DefaultInventory, TEXT("ToolTip"), TEXT("Configuration of items to create for the character by default"));
				MetaData->SetValue(NewProp_PointAndClickTraceDistance, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_PointAndClickTraceDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_PointAndClickTraceDistance, TEXT("ToolTip"), TEXT("How far away items and switches can be from the camera to be found with clicking"));
				MetaData->SetValue(NewProp_ActionManager, TEXT("Category"), TEXT("AdvKit|Actions"));
				MetaData->SetValue(NewProp_ActionManager, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_ActionManager, TEXT("ToolTip"), TEXT("Action manager used by this character"));
				MetaData->SetValue(NewProp_ActionManagerClass, TEXT("Category"), TEXT("AdvKit|Actions"));
				MetaData->SetValue(NewProp_ActionManagerClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_ActionManagerClass, TEXT("ToolTip"), TEXT("Class of action manager to be used by this character"));
				MetaData->SetValue(NewProp_DefaultActions, TEXT("Category"), TEXT("AdvKit|Actions"));
				MetaData->SetValue(NewProp_DefaultActions, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_DefaultActions, TEXT("ToolTip"), TEXT("Configurable array of actions to instantiate for the character"));
				MetaData->SetValue(NewProp_MaxHealth, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_MaxHealth, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_MaxHealth, TEXT("ToolTip"), TEXT("Max health of the character"));
				MetaData->SetValue(NewProp_Health, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_Health, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_Health, TEXT("ToolTip"), TEXT("Health points of the character"));
				MetaData->SetValue(NewProp_TargetLockCamera, TEXT("Category"), TEXT("AdvKit|Camera"));
				MetaData->SetValue(NewProp_TargetLockCamera, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_TargetLockCamera, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_TargetLockCamera, TEXT("ToolTip"), TEXT("Camera used when in target lock mode. Tag camera component with \"Target Lock\" auto assign this property."));
				MetaData->SetValue(NewProp_ShoulderCamera, TEXT("Category"), TEXT("AdvKit|Camera"));
				MetaData->SetValue(NewProp_ShoulderCamera, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ShoulderCamera, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_ShoulderCamera, TEXT("ToolTip"), TEXT("Shoulder camera. Tag camera component with \"Shoulder\" auto assign this property."));
				MetaData->SetValue(NewProp_FirstPersonCamera, TEXT("Category"), TEXT("AdvKit|Camera"));
				MetaData->SetValue(NewProp_FirstPersonCamera, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_FirstPersonCamera, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonCamera, TEXT("ToolTip"), TEXT("First person camera. Tag camera component with \"First Person\" auto assign this property."));
				MetaData->SetValue(NewProp_ThirdPersonCamera, TEXT("Category"), TEXT("AdvKit|Camera"));
				MetaData->SetValue(NewProp_ThirdPersonCamera, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ThirdPersonCamera, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_ThirdPersonCamera, TEXT("ToolTip"), TEXT("Follow camera. Tag camera component with \"Third Person\" auto assign this property."));
				MetaData->SetValue(NewProp_bInvincibleDuringDodge, TEXT("Category"), TEXT("AdvKit | Dodge"));
				MetaData->SetValue(NewProp_bInvincibleDuringDodge, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bInvincibleDuringDodge, TEXT("ToolTip"), TEXT("If true the character takes no damage if it is dodging"));
				MetaData->SetValue(NewProp_bUseControllerRotationRollInFirstPerson, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_bUseControllerRotationRollInFirstPerson, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bUseControllerRotationRollInFirstPerson, TEXT("ToolTip"), TEXT("If true, this Pawn's roll will be updated to match the Controller's ControlRotation roll, if controlled by a PlayerController."));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("ToolTip"), TEXT("If true, this Pawn's yaw will be updated to match the Controller's ControlRotation yaw, if controlled by a PlayerController."));
				MetaData->SetValue(NewProp_bUseControllerRotationPitchInFirstPerson, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_bUseControllerRotationPitchInFirstPerson, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bUseControllerRotationPitchInFirstPerson, TEXT("ToolTip"), TEXT("If true, this Pawn's pitch will be updated to match the Controller's ControlRotation pitch, if controlled by a PlayerController."));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraRoll, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraRoll, TEXT("EditCondition"), TEXT("bFirstPersonClampCameraRoll"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraRoll, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraRoll, TEXT("ToolTip"), TEXT("Maximum angle to clamp roll to in first person"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraRoll, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraRoll, TEXT("EditCondition"), TEXT("bFirstPersonClampCameraRoll"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraRoll, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraRoll, TEXT("ToolTip"), TEXT("Minimum angle to clamp roll to in first person"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraRoll, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraRoll, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraRoll, TEXT("ToolTip"), TEXT("Restrict the camera roll to the head socket's orientation in first person view"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraYaw, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraYaw, TEXT("EditCondition"), TEXT("bFirstPersonClampCameraYaw"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraYaw, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraYaw, TEXT("ToolTip"), TEXT("Maximum angle to clamp yaw to in first person"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraYaw, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraYaw, TEXT("EditCondition"), TEXT("bFirstPersonClampCameraYaw"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraYaw, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraYaw, TEXT("ToolTip"), TEXT("Minimum angle to clamp yaw to in first person"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraYaw, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraYaw, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraYaw, TEXT("ToolTip"), TEXT("Restrict the camera yaw to the head socket's orientation in first person view"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraPitch, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraPitch, TEXT("EditCondition"), TEXT("bFirstPersonClampCameraPitch"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraPitch, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonMaxCameraPitch, TEXT("ToolTip"), TEXT("Maximum angle to clamp pitch to in first person"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraPitch, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraPitch, TEXT("EditCondition"), TEXT("bFirstPersonClampCameraPitch"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraPitch, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_FirstPersonMinCameraPitch, TEXT("ToolTip"), TEXT("Minimum angle to clamp pitch to in first person"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraPitch, TEXT("Category"), TEXT("AdvKit | First Person"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraPitch, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bFirstPersonClampCameraPitch, TEXT("ToolTip"), TEXT("Restrict the camera pitch to the head socket's orientation in first person view"));
				MetaData->SetValue(NewProp_HeadSocket, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_HeadSocket, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_HeadSocket, TEXT("ToolTip"), TEXT("Name of the socket which represents the character's head. Used for first person camera and weapon targeting."));
				MetaData->SetValue(NewProp_CollisionChannelsToIgnoreInZones, TEXT("Category"), TEXT("Zones"));
				MetaData->SetValue(NewProp_CollisionChannelsToIgnoreInZones, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_CollisionChannelsToIgnoreInZones, TEXT("ToolTip"), TEXT("List of collision channels to ignore while moving inside a zone"));
				MetaData->SetValue(NewProp_bEnterZonesFromOverlapAutomatically, TEXT("Category"), TEXT("Zones"));
				MetaData->SetValue(NewProp_bEnterZonesFromOverlapAutomatically, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bEnterZonesFromOverlapAutomatically, TEXT("ToolTip"), TEXT("Whether or not to automatically enter a zone when the character overlaps it"));
				MetaData->SetValue(NewProp_bEnterZonesFromHitAutomatically, TEXT("Category"), TEXT("Zones"));
				MetaData->SetValue(NewProp_bEnterZonesFromHitAutomatically, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacter.h"));
				MetaData->SetValue(NewProp_bEnterZonesFromHitAutomatically, TEXT("ToolTip"), TEXT("Whether or not to automatically enter a zone when the character hits it"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitCharacter(Z_Construct_UClass_AAdvKitCharacter, &AAdvKitCharacter::StaticClass, TEXT("AAdvKitCharacter"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitCharacter);
	UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_CanWallWalkOn()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitGravityCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanWallWalkOn"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020C00, 65535, sizeof(AdvKitGravityCharacter_eventCanWallWalkOn_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitGravityCharacter_eventCanWallWalkOn_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitGravityCharacter_eventCanWallWalkOn_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitGravityCharacter_eventCanWallWalkOn_Parms), sizeof(bool), true);
			UProperty* NewProp_NewFloor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFloor"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewFloor, AdvKitGravityCharacter_eventCanWallWalkOn_Parms), 0x0010008000000080, Z_Construct_UScriptStruct_FFindFloorResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Checks if a hit result is a valid floor for wall walking\n@param       NewFloor        The floor to test\n@return      True if it is valid for wall walking"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_GetAdvGravityMovementComponent()
	{
		struct AdvKitGravityCharacter_eventGetAdvGravityMovementComponent_Parms
		{
			UAdvKitGravityCharacterMovementComponent* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitGravityCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAdvGravityMovementComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(AdvKitGravityCharacter_eventGetAdvGravityMovementComponent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitGravityCharacter_eventGetAdvGravityMovementComponent_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the gravity movement component of the character.\n@return      The gravity movement component of the character."));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientation()
	{
		struct AdvKitGravityCharacter_eventSetNewOrientation_Parms
		{
			FVector GravityUpVector;
			FVector Origin;
			bool bForce;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitGravityCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNewOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitGravityCharacter_eventSetNewOrientation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForce, AdvKitGravityCharacter_eventSetNewOrientation_Parms, bool);
			UProperty* NewProp_bForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForce"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForce, AdvKitGravityCharacter_eventSetNewOrientation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bForce, AdvKitGravityCharacter_eventSetNewOrientation_Parms), sizeof(bool), true);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Origin, AdvKitGravityCharacter_eventSetNewOrientation_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_GravityUpVector = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GravityUpVector"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GravityUpVector, AdvKitGravityCharacter_eventSetNewOrientation_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bForce"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set a new gravity orientation on the orientation component\n@param       GravityUpVector         New Up vector for the gravity\n@param       Origin  Origin of the gravitational pull\n@param       bForce  Hard set new gravity instead of interpolating"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientationServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitGravityCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNewOrientationServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80A20C40, 65535, sizeof(AdvKitGravityCharacter_eventSetNewOrientationServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForce, AdvKitGravityCharacter_eventSetNewOrientationServer_Parms, bool);
			UProperty* NewProp_bForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForce"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForce, AdvKitGravityCharacter_eventSetNewOrientationServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bForce, AdvKitGravityCharacter_eventSetNewOrientationServer_Parms), sizeof(bool), true);
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Origin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Origin, AdvKitGravityCharacter_eventSetNewOrientationServer_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_GravityUpVector = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GravityUpVector"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GravityUpVector, AdvKitGravityCharacter_eventSetNewOrientationServer_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to set a new gravity orientation on the orientation component\n@param       GravityUpVector         New Up vector for the gravity\n@param       Origin  Origin of the gravitational pull\n@param       bForce  Hard set new gravity instead of interpolating"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitGravityCharacter_NoRegister()
	{
		return AAdvKitGravityCharacter::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitGravityCharacter()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitCharacter();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitGravityCharacter::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitGravityCharacter_CanWallWalkOn());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitGravityCharacter_GetAdvGravityMovementComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientation());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientationServer());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TraceWorldOrientation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TraceWorldOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TraceWorldOrientation, AAdvKitGravityCharacter), 0x00100000000a001d, Z_Construct_UClass_UAdvKitTraceUtilityComponent_NoRegister());
				UProperty* NewProp_WorldOrientationComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WorldOrientationComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WorldOrientationComponent, AAdvKitGravityCharacter), 0x00100000000a083d, Z_Construct_UClass_UAdvKitOrientationComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitGravityCharacter_CanWallWalkOn(), "CanWallWalkOn"); // 2463126368
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitGravityCharacter_GetAdvGravityMovementComponent(), "GetAdvGravityMovementComponent"); // 614073967
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientation(), "SetNewOrientation"); // 3781578327
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitGravityCharacter_SetNewOrientationServer(), "SetNewOrientationServer"); // 3172257549
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitGravityCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Character class that supports arbitrary gravity provided by an orientation component."));
				MetaData->SetValue(NewProp_TraceWorldOrientation, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_TraceWorldOrientation, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_TraceWorldOrientation, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
				MetaData->SetValue(NewProp_TraceWorldOrientation, TEXT("ToolTip"), TEXT("Component that traces down when orientation should be updated by trace"));
				MetaData->SetValue(NewProp_WorldOrientationComponent, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_WorldOrientationComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_WorldOrientationComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacter.h"));
				MetaData->SetValue(NewProp_WorldOrientationComponent, TEXT("ToolTip"), TEXT("Orientation component that provides gravity methods"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitGravityCharacter(Z_Construct_UClass_AAdvKitGravityCharacter, &AAdvKitGravityCharacter::StaticClass, TEXT("AAdvKitGravityCharacter"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitGravityCharacter);
	UClass* Z_Construct_UClass_UAdvKitCA_Dodge_NoRegister()
	{
		return UAdvKitCA_Dodge::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Dodge()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Dodge::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DodgeSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DodgeSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DodgeSpeed, UAdvKitCA_Dodge), 0x0010000000010005);
				UProperty* NewProp_DodgeAlpha = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DodgeAlpha"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DodgeAlpha, UAdvKitCA_Dodge), 0x0010000000000004);
				UProperty* NewProp_DodgeDuration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DodgeDuration"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DodgeDuration, UAdvKitCA_Dodge), 0x0010000000010005);
				UProperty* NewProp_DodgeDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DodgeDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DodgeDirection, UAdvKitCA_Dodge), 0x0010000000000004, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_DodgeSpeedCurve = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DodgeSpeedCurve"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DodgeSpeedCurve, UAdvKitCA_Dodge), 0x0010000000010015, Z_Construct_UScriptStruct_FRuntimeFloatCurve());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Action that makes the character dodge in a given direction."));
				MetaData->SetValue(NewProp_DodgeSpeed, TEXT("Category"), TEXT("AdvKitCA_Dodge"));
				MetaData->SetValue(NewProp_DodgeSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(NewProp_DodgeSpeed, TEXT("ToolTip"), TEXT("How fast to dodge (gets multiplied by the dodge speed curve)"));
				MetaData->SetValue(NewProp_DodgeAlpha, TEXT("Category"), TEXT("AdvKitCA_Dodge"));
				MetaData->SetValue(NewProp_DodgeAlpha, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(NewProp_DodgeAlpha, TEXT("ToolTip"), TEXT("Current progress of the dodging"));
				MetaData->SetValue(NewProp_DodgeDuration, TEXT("Category"), TEXT("AdvKitCA_Dodge"));
				MetaData->SetValue(NewProp_DodgeDuration, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(NewProp_DodgeDuration, TEXT("ToolTip"), TEXT("How long to dodge in seconds"));
				MetaData->SetValue(NewProp_DodgeDirection, TEXT("Category"), TEXT("AdvKitCA_Dodge"));
				MetaData->SetValue(NewProp_DodgeDirection, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(NewProp_DodgeDirection, TEXT("ToolTip"), TEXT("Direction in which to dodge"));
				MetaData->SetValue(NewProp_DodgeSpeedCurve, TEXT("Category"), TEXT("AdvKitCA_Dodge"));
				MetaData->SetValue(NewProp_DodgeSpeedCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge.h"));
				MetaData->SetValue(NewProp_DodgeSpeedCurve, TEXT("ToolTip"), TEXT("This curve handles the percentage of dodge speed at which to dodge at a given time"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Dodge(Z_Construct_UClass_UAdvKitCA_Dodge, &UAdvKitCA_Dodge::StaticClass, TEXT("UAdvKitCA_Dodge"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Dodge);
	UClass* Z_Construct_UClass_UAdvKitCharacterActionSingleAnimation_NoRegister()
	{
		return UAdvKitCharacterActionSingleAnimation::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterActionSingleAnimation()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterActionSingleAnimation::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_AnimMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AnimMontage, UAdvKitCharacterActionSingleAnimation), 0x0020080000010015, Z_Construct_UClass_UAnimMontage_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AdvKitCharacterActionSingleAnimation.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterActionSingleAnimation.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief A character action that plays a single animation montage on the character and automatically stops when the animation ends."));
				MetaData->SetValue(NewProp_AnimMontage, TEXT("Category"), TEXT("Animation"));
				MetaData->SetValue(NewProp_AnimMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterActionSingleAnimation.h"));
				MetaData->SetValue(NewProp_AnimMontage, TEXT("Tooltip"), TEXT("Animation Montage to play during the action."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterActionSingleAnimation(Z_Construct_UClass_UAdvKitCharacterActionSingleAnimation, &UAdvKitCharacterActionSingleAnimation::StaticClass, TEXT("UAdvKitCharacterActionSingleAnimation"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterActionSingleAnimation);
	UScriptStruct* Z_Construct_UScriptStruct_FAdvKitPhysicsTransition()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FAdvKitPhysicsTransition_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AdvKitPhysicsTransition"), sizeof(FAdvKitPhysicsTransition), Get_Z_Construct_UScriptStruct_FAdvKitPhysicsTransition_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdvKitPhysicsTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAdvKitPhysicsTransition>, EStructFlags(0x00000001));
			UProperty* NewProp_ReverseAction = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ReverseAction"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ReverseAction, FAdvKitPhysicsTransition), 0x0014000000010015, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_TransitionAction = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TransitionAction"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(TransitionAction, FAdvKitPhysicsTransition), 0x0014000000010015, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_ToMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ToMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ToMode, FAdvKitPhysicsTransition), 0x0010000000010015, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			UProperty* NewProp_FromMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FromMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FromMode, FAdvKitPhysicsTransition), 0x0010000000010015, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Helper struct since UE4 does not support TMap properties. This handles configuring the transition\nmapping to set which actions take care of which physics mode transition."));
			MetaData->SetValue(NewProp_ReverseAction, TEXT("Category"), TEXT("Transitions"));
			MetaData->SetValue(NewProp_ReverseAction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
			MetaData->SetValue(NewProp_ReverseAction, TEXT("ToolTip"), TEXT("Action to take when going ToMode -> FromMode"));
			MetaData->SetValue(NewProp_TransitionAction, TEXT("Category"), TEXT("Transitions"));
			MetaData->SetValue(NewProp_TransitionAction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
			MetaData->SetValue(NewProp_TransitionAction, TEXT("ToolTip"), TEXT("Action to take when going FromMode -> ToMode"));
			MetaData->SetValue(NewProp_ToMode, TEXT("Category"), TEXT("Transitions"));
			MetaData->SetValue(NewProp_ToMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
			MetaData->SetValue(NewProp_ToMode, TEXT("ToolTip"), TEXT("Mode to transition to"));
			MetaData->SetValue(NewProp_FromMode, TEXT("Category"), TEXT("Transitions"));
			MetaData->SetValue(NewProp_FromMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
			MetaData->SetValue(NewProp_FromMode, TEXT("ToolTip"), TEXT("Mode to transition from"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAdvKitPhysicsTransition_CRC() { return 1879616932U; }
	UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition_NoRegister()
	{
		return UAdvKitCA_PhysicsTransition::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_PhysicsTransition::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DefaultTransitionActions = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultTransitionActions"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(DefaultTransitionActions, UAdvKitCA_PhysicsTransition), 0x0020080000010015);
				UProperty* NewProp_DefaultTransitionActions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_DefaultTransitionActions, TEXT("DefaultTransitionActions"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FAdvKitPhysicsTransition());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLogDebug, UAdvKitCA_PhysicsTransition, bool);
				UProperty* NewProp_bLogDebug = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLogDebug"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLogDebug, UAdvKitCA_PhysicsTransition), 0x0020080000010015, CPP_BOOL_PROPERTY_BITMASK(bLogDebug, UAdvKitCA_PhysicsTransition), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Action ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_PhysicsTransition.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief This action is responsible for redirecting to sub actions that take care of movement mode\nchanges."));
				MetaData->SetValue(NewProp_DefaultTransitionActions, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_DefaultTransitionActions, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
				MetaData->SetValue(NewProp_DefaultTransitionActions, TEXT("ToolTip"), TEXT("Configuration map for the transition action"));
				MetaData->SetValue(NewProp_bLogDebug, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_bLogDebug, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition.h"));
				MetaData->SetValue(NewProp_bLogDebug, TEXT("ToolTip"), TEXT("Flag to enable debug output for transitions"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_PhysicsTransition(Z_Construct_UClass_UAdvKitCA_PhysicsTransition, &UAdvKitCA_PhysicsTransition::StaticClass, TEXT("UAdvKitCA_PhysicsTransition"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_PhysicsTransition);
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneLocationSwitch_NoRegister()
	{
		return UAdvKitCA_ZoneLocationSwitch::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneLocationSwitch()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneLocationSwitch::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ActionAtEndPoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActionAtEndPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ActionAtEndPoint, UAdvKitCA_ZoneLocationSwitch), 0x0024080000010015, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_ActionAtStartPoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActionAtStartPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ActionAtStartPoint, UAdvKitCA_ZoneLocationSwitch), 0x0024080000010015, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Animation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneLocationSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneLocationSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Action that plays a different @see UAnimMontage depending on the player being\non the left or right side of a wall in a tight space."));
				MetaData->SetValue(NewProp_ActionAtEndPoint, TEXT("Category"), TEXT("TightSpace"));
				MetaData->SetValue(NewProp_ActionAtEndPoint, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneLocationSwitch.h"));
				MetaData->SetValue(NewProp_ActionAtEndPoint, TEXT("ToolTip"), TEXT("Action to execute if the character is close to the end of the tight space."));
				MetaData->SetValue(NewProp_ActionAtStartPoint, TEXT("Category"), TEXT("TightSpace"));
				MetaData->SetValue(NewProp_ActionAtStartPoint, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneLocationSwitch.h"));
				MetaData->SetValue(NewProp_ActionAtStartPoint, TEXT("ToolTip"), TEXT("Action to execute if the character is close to the start of the tight space."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneLocationSwitch(Z_Construct_UClass_UAdvKitCA_ZoneLocationSwitch, &UAdvKitCA_ZoneLocationSwitch::StaticClass, TEXT("UAdvKitCA_ZoneLocationSwitch"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneLocationSwitch);
	UFunction* Z_Construct_UFunction_UAdvKitCA_ZoneTransition_GetMontageToPlay()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitCA_ZoneTransition();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMontageToPlay"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitCA_ZoneTransition_eventGetMontageToPlay_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitCA_ZoneTransition_eventGetMontageToPlay_Parms), 0x0010000000000580, Z_Construct_UClass_UAnimMontage_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Animation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoRegister()
	{
		return UAdvKitCA_ZoneTransition::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneTransition::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitCA_ZoneTransition_GetMontageToPlay());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CurrentAnimMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentAnimMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CurrentAnimMontage, UAdvKitCA_ZoneTransition), 0x0020080000000014, Z_Construct_UClass_UAnimMontage_NoRegister());
				UProperty* NewProp_CurrentArguments = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentArguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CurrentArguments, UAdvKitCA_ZoneTransition), 0x0020080000000000, Z_Construct_UClass_UAdvKitCA_ZoneTransition_Arguments_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitCA_ZoneTransition_GetMontageToPlay(), "GetMontageToPlay"); // 3725979755
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneTransition.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Action that makes the character change zones. It can play an animation that syncs with the\ntransition and dynamically interpolate between starting and end locations to make the transition\nlook smooth even if the animation does not line up correctly."));
				MetaData->SetValue(NewProp_CurrentAnimMontage, TEXT("Category"), TEXT("AdvKitCA_ZoneTransition"));
				MetaData->SetValue(NewProp_CurrentAnimMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition.h"));
				MetaData->SetValue(NewProp_CurrentAnimMontage, TEXT("ToolTip"), TEXT("Animation Montage to play during the action."));
				MetaData->SetValue(NewProp_CurrentArguments, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition.h"));
				MetaData->SetValue(NewProp_CurrentArguments, TEXT("ToolTip"), TEXT("Arguments for the current transition"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneTransition(Z_Construct_UClass_UAdvKitCA_ZoneTransition, &UAdvKitCA_ZoneTransition::StaticClass, TEXT("UAdvKitCA_ZoneTransition"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneTransition);
	UScriptStruct* Z_Construct_UScriptStruct_FDirectionalMontage()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FDirectionalMontage_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("DirectionalMontage"), sizeof(FDirectionalMontage), Get_Z_Construct_UScriptStruct_FDirectionalMontage_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DirectionalMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FDirectionalMontage>, EStructFlags(0x00000001));
			UProperty* NewProp_Montage = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Montage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Montage, FDirectionalMontage), 0x0010000000000001, Z_Construct_UClass_UAnimMontage_NoRegister());
			UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, FDirectionalMontage), 0x0010000000000001, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Directional.h"));
			MetaData->SetValue(NewProp_Montage, TEXT("Category"), TEXT("DirectionalMontage"));
			MetaData->SetValue(NewProp_Montage, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Directional.h"));
			MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("DirectionalMontage"));
			MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Directional.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FDirectionalMontage_CRC() { return 1181409614U; }
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Directional_NoRegister()
	{
		return UAdvKitCA_ZoneTransition_Directional::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Directional()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCA_ZoneTransition();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneTransition_Directional::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Montages = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Montages"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Montages, UAdvKitCA_ZoneTransition_Directional), 0x0020080000000015);
				UProperty* NewProp_Montages_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Montages, TEXT("Montages"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FDirectionalMontage());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneTransition_Directional.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Directional.h"));
				MetaData->SetValue(NewProp_Montages, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_Montages, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Directional.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneTransition_Directional(Z_Construct_UClass_UAdvKitCA_ZoneTransition_Directional, &UAdvKitCA_ZoneTransition_Directional::StaticClass, TEXT("UAdvKitCA_ZoneTransition_Directional"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneTransition_Directional);
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_LocationSwitch_NoRegister()
	{
		return UAdvKitCA_ZoneTransition_LocationSwitch::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_LocationSwitch()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCA_ZoneTransition();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneTransition_LocationSwitch::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MontageAtEndPoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MontageAtEndPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(MontageAtEndPoint, UAdvKitCA_ZoneTransition_LocationSwitch), 0x0020080000010015, Z_Construct_UClass_UAnimMontage_NoRegister());
				UProperty* NewProp_MontageAtStartPoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MontageAtStartPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(MontageAtStartPoint, UAdvKitCA_ZoneTransition_LocationSwitch), 0x0020080000010015, Z_Construct_UClass_UAnimMontage_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneTransition_LocationSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_LocationSwitch.h"));
				MetaData->SetValue(NewProp_MontageAtEndPoint, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MontageAtEndPoint, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_LocationSwitch.h"));
				MetaData->SetValue(NewProp_MontageAtEndPoint, TEXT("ToolTip"), TEXT("Montage to play if the character is close to the end of the zone."));
				MetaData->SetValue(NewProp_MontageAtStartPoint, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MontageAtStartPoint, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_LocationSwitch.h"));
				MetaData->SetValue(NewProp_MontageAtStartPoint, TEXT("ToolTip"), TEXT("Montage to play if the character is close to the start of the zone."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneTransition_LocationSwitch(Z_Construct_UClass_UAdvKitCA_ZoneTransition_LocationSwitch, &UAdvKitCA_ZoneTransition_LocationSwitch::StaticClass, TEXT("UAdvKitCA_ZoneTransition_LocationSwitch"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneTransition_LocationSwitch);
	UScriptStruct* Z_Construct_UScriptStruct_FTransitionLocation()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FTransitionLocation_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("TransitionLocation"), sizeof(FTransitionLocation), Get_Z_Construct_UScriptStruct_FTransitionLocation_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TransitionLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTransitionLocation>, EStructFlags(0x00000001));
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Rotation, FTransitionLocation), 0x0010000000000000, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Location"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Location, FTransitionLocation), 0x0010000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ZoneLocation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ZoneLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ZoneLocation, FTransitionLocation), 0x0010000000000000, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ToolTip"), TEXT("Rotation if zone location is not valid"));
			MetaData->SetValue(NewProp_Location, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
			MetaData->SetValue(NewProp_Location, TEXT("ToolTip"), TEXT("Location if zone location is not valid"));
			MetaData->SetValue(NewProp_ZoneLocation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
			MetaData->SetValue(NewProp_ZoneLocation, TEXT("ToolTip"), TEXT("Location in zone the transition"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTransitionLocation_CRC() { return 1599394227U; }
	UClass* Z_Construct_UClass_UAnimNotifyState_TransitionCorrection_NoRegister()
	{
		return UAnimNotifyState_TransitionCorrection::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimNotifyState_TransitionCorrection()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimNotifyState();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAnimNotifyState_TransitionCorrection::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20013080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_NextLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NextLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NextLocation, UAnimNotifyState_TransitionCorrection), 0x0020080000000010, Z_Construct_UScriptStruct_FTransitionLocation());
				UProperty* NewProp_PreviousLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviousLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreviousLocation, UAnimNotifyState_TransitionCorrection), 0x0020080000000010, Z_Construct_UScriptStruct_FTransitionLocation());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAbsoluteTransitionCorrection, UAnimNotifyState_TransitionCorrection, bool);
				UProperty* NewProp_bAbsoluteTransitionCorrection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAbsoluteTransitionCorrection"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAbsoluteTransitionCorrection, UAnimNotifyState_TransitionCorrection), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bAbsoluteTransitionCorrection, UAnimNotifyState_TransitionCorrection), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Transiton Correction"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AnimNotifyState_TransitionCorrection.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
				MetaData->SetValue(NewProp_NextLocation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
				MetaData->SetValue(NewProp_NextLocation, TEXT("ToolTip"), TEXT("New location in target zone after the transition"));
				MetaData->SetValue(NewProp_PreviousLocation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
				MetaData->SetValue(NewProp_PreviousLocation, TEXT("ToolTip"), TEXT("Location before the transition"));
				MetaData->SetValue(NewProp_bAbsoluteTransitionCorrection, TEXT("Category"), TEXT("Transition Correction"));
				MetaData->SetValue(NewProp_bAbsoluteTransitionCorrection, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotifyState_TransitionCorrection.h"));
				MetaData->SetValue(NewProp_bAbsoluteTransitionCorrection, TEXT("ToolTip"), TEXT("Use rotation part of transition prediction"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimNotifyState_TransitionCorrection(Z_Construct_UClass_UAnimNotifyState_TransitionCorrection, &UAnimNotifyState_TransitionCorrection::StaticClass, TEXT("UAnimNotifyState_TransitionCorrection"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimNotifyState_TransitionCorrection);
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoAnim_NoRegister()
	{
		return UAdvKitCA_ZoneTransition_NoAnim::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoAnim()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCA_ZoneTransition();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneTransition_NoAnim::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ApplyZoneOnStop, UAdvKitCA_ZoneTransition_NoAnim, bool);
				UProperty* NewProp_ApplyZoneOnStop = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplyZoneOnStop"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ApplyZoneOnStop, UAdvKitCA_ZoneTransition_NoAnim), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(ApplyZoneOnStop, UAdvKitCA_ZoneTransition_NoAnim), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ApplyZoneOnStart, UAdvKitCA_ZoneTransition_NoAnim, bool);
				UProperty* NewProp_ApplyZoneOnStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplyZoneOnStart"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ApplyZoneOnStart, UAdvKitCA_ZoneTransition_NoAnim), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(ApplyZoneOnStart, UAdvKitCA_ZoneTransition_NoAnim), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSetTargetZoneBaseAtStart, UAdvKitCA_ZoneTransition_NoAnim, bool);
				UProperty* NewProp_bSetTargetZoneBaseAtStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSetTargetZoneBaseAtStart"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSetTargetZoneBaseAtStart, UAdvKitCA_ZoneTransition_NoAnim), 0x0020080000000005, CPP_BOOL_PROPERTY_BITMASK(bSetTargetZoneBaseAtStart, UAdvKitCA_ZoneTransition_NoAnim), sizeof(bool), true);
				UProperty* NewProp_NextLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NextLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NextLocation, UAdvKitCA_ZoneTransition_NoAnim), 0x0020080000000000, Z_Construct_UScriptStruct_FTransitionLocation());
				UProperty* NewProp_PreviousLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PreviousLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreviousLocation, UAdvKitCA_ZoneTransition_NoAnim), 0x0020080000000000, Z_Construct_UScriptStruct_FTransitionLocation());
				UProperty* NewProp_TransitionCurve = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TransitionCurve"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TransitionCurve, UAdvKitCA_ZoneTransition_NoAnim), 0x0020080000000015, Z_Construct_UScriptStruct_FRuntimeFloatCurve());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_ApplyZoneOnStop, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_ApplyZoneOnStop, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_ApplyZoneOnStop, TEXT("ToolTip"), TEXT("Set the target zone as the active one of the character at the end of the action"));
				MetaData->SetValue(NewProp_ApplyZoneOnStart, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_ApplyZoneOnStart, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_ApplyZoneOnStart, TEXT("ToolTip"), TEXT("Set the target zone as the active one of the character at the start of the action"));
				MetaData->SetValue(NewProp_bSetTargetZoneBaseAtStart, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_bSetTargetZoneBaseAtStart, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_bSetTargetZoneBaseAtStart, TEXT("ToolTip"), TEXT("Flag to set the zone the character will transition to as the movement base when starting the action."));
				MetaData->SetValue(NewProp_NextLocation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_NextLocation, TEXT("ToolTip"), TEXT("New location in target zone after the transition"));
				MetaData->SetValue(NewProp_PreviousLocation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_PreviousLocation, TEXT("ToolTip"), TEXT("Location before the transition"));
				MetaData->SetValue(NewProp_TransitionCurve, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_TransitionCurve, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_NoAnim.h"));
				MetaData->SetValue(NewProp_TransitionCurve, TEXT("ToolTip"), TEXT("Interpolation curve for the transition prediction"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneTransition_NoAnim(Z_Construct_UClass_UAdvKitCA_ZoneTransition_NoAnim, &UAdvKitCA_ZoneTransition_NoAnim::StaticClass, TEXT("UAdvKitCA_ZoneTransition_NoAnim"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneTransition_NoAnim);
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_SingleAnim_NoRegister()
	{
		return UAdvKitCA_ZoneTransition_SingleAnim::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_SingleAnim()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCA_ZoneTransition();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneTransition_SingleAnim::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Montage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Montage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Montage, UAdvKitCA_ZoneTransition_SingleAnim), 0x0020080000010015, Z_Construct_UClass_UAnimMontage_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneTransition_SingleAnim.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_SingleAnim.h"));
				MetaData->SetValue(NewProp_Montage, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_Montage, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_SingleAnim.h"));
				MetaData->SetValue(NewProp_Montage, TEXT("ToolTip"), TEXT("Montage to play."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneTransition_SingleAnim(Z_Construct_UClass_UAdvKitCA_ZoneTransition_SingleAnim, &UAdvKitCA_ZoneTransition_SingleAnim::StaticClass, TEXT("UAdvKitCA_ZoneTransition_SingleAnim"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneTransition_SingleAnim);
	UClass* Z_Construct_UClass_UAdvKitCharacterActionPhysics_NoRegister()
	{
		return UAdvKitCharacterActionPhysics::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterActionPhysics()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterActionPhysics::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCharacterActionPhysics.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCharacterActionPhysics.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Character action that can be used to implement a custom movement mode."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterActionPhysics(Z_Construct_UClass_UAdvKitCharacterActionPhysics, &UAdvKitCharacterActionPhysics::StaticClass, TEXT("UAdvKitCharacterActionPhysics"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterActionPhysics);
	UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch_NoRegister()
	{
		return UAdvKitCA_UseSwitch::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterActionSingleAnimation();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_UseSwitch::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_UseWithItem = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UseWithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(UseWithItem, UAdvKitCA_UseSwitch), 0x0010000000000000, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
				UProperty* NewProp_UseSwitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UseSwitch"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(UseSwitch, UAdvKitCA_UseSwitch), 0x0010000000000000, Z_Construct_UClass_AAdvKitUsableSimpleSwitch_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Interaction/AdvKitCA_UseSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Interaction/AdvKitCA_UseSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Action that makes the character use a switch. It positions the character in relation to the switch and then\nplays the using animation in sync with the switch."));
				MetaData->SetValue(NewProp_UseWithItem, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Interaction/AdvKitCA_UseSwitch.h"));
				MetaData->SetValue(NewProp_UseWithItem, TEXT("ToolTip"), TEXT("Item the character uses with the switch (e.g. a key)"));
				MetaData->SetValue(NewProp_UseSwitch, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Interaction/AdvKitCA_UseSwitch.h"));
				MetaData->SetValue(NewProp_UseSwitch, TEXT("ToolTip"), TEXT("Switch that is being used (e.g. a lock)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_UseSwitch(Z_Construct_UClass_UAdvKitCA_UseSwitch, &UAdvKitCA_UseSwitch::StaticClass, TEXT("UAdvKitCA_UseSwitch"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_UseSwitch);
	UClass* Z_Construct_UClass_UAdvKitCA_Dodge_Arguments_NoRegister()
	{
		return UAdvKitCA_Dodge_Arguments::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Dodge_Arguments()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_Arguments();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Dodge_Arguments::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DodgeDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DodgeDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DodgeDirection, UAdvKitCA_Dodge_Arguments), 0x0010000000000004, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_Dodge_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Arguments for the @see UAdvKitCA_Dodge action."));
				MetaData->SetValue(NewProp_DodgeDirection, TEXT("Category"), TEXT("AdvKitCA_Dodge_Arguments"));
				MetaData->SetValue(NewProp_DodgeDirection, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_Dodge_Arguments.h"));
				MetaData->SetValue(NewProp_DodgeDirection, TEXT("ToolTip"), TEXT("Direction to dodge towards"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Dodge_Arguments(Z_Construct_UClass_UAdvKitCA_Dodge_Arguments, &UAdvKitCA_Dodge_Arguments::StaticClass, TEXT("UAdvKitCA_Dodge_Arguments"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Dodge_Arguments);
	UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition_Arguments_NoRegister()
	{
		return UAdvKitCA_PhysicsTransition_Arguments::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_PhysicsTransition_Arguments()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_Arguments();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_PhysicsTransition_Arguments::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SubArguments = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SubArguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SubArguments, UAdvKitCA_PhysicsTransition_Arguments), 0x0010000000000004, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
				UProperty* NewProp_ToMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ToMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ToMode, UAdvKitCA_PhysicsTransition_Arguments), 0x0010000000000004, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
				UProperty* NewProp_FromMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FromMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FromMode, UAdvKitCA_PhysicsTransition_Arguments), 0x0010000000000004, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_PhysicsTransition_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Arguments for the UAdvKitCA_PhysicsTransition action. @see UAdvKitCA_PhysicsTransition"));
				MetaData->SetValue(NewProp_SubArguments, TEXT("Category"), TEXT("AdvKitCA_PhysicsTransition_Arguments"));
				MetaData->SetValue(NewProp_SubArguments, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition_Arguments.h"));
				MetaData->SetValue(NewProp_SubArguments, TEXT("ToolTip"), TEXT("Arguments to give to the subsequent action the physics action redirected to"));
				MetaData->SetValue(NewProp_ToMode, TEXT("Category"), TEXT("AdvKitCA_PhysicsTransition_Arguments"));
				MetaData->SetValue(NewProp_ToMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition_Arguments.h"));
				MetaData->SetValue(NewProp_ToMode, TEXT("ToolTip"), TEXT("Mode to transition to"));
				MetaData->SetValue(NewProp_FromMode, TEXT("Category"), TEXT("AdvKitCA_PhysicsTransition_Arguments"));
				MetaData->SetValue(NewProp_FromMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_PhysicsTransition_Arguments.h"));
				MetaData->SetValue(NewProp_FromMode, TEXT("ToolTip"), TEXT("Mode to transition from"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_PhysicsTransition_Arguments(Z_Construct_UClass_UAdvKitCA_PhysicsTransition_Arguments, &UAdvKitCA_PhysicsTransition_Arguments::StaticClass, TEXT("UAdvKitCA_PhysicsTransition_Arguments"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_PhysicsTransition_Arguments);
	UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch_Arguments_NoRegister()
	{
		return UAdvKitCA_UseSwitch_Arguments::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_UseSwitch_Arguments()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_Arguments();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_UseSwitch_Arguments::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_UseWithItem = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UseWithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(UseWithItem, UAdvKitCA_UseSwitch_Arguments), 0x0010000000000000, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
				UProperty* NewProp_UseSwitch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UseSwitch"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(UseSwitch, UAdvKitCA_UseSwitch_Arguments), 0x0010000000000000, Z_Construct_UClass_AAdvKitUsableSimpleSwitch_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Interaction/AdvKitCA_UseSwitch_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Interaction/AdvKitCA_UseSwitch_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Arguments for the UAdvKitCA_UseSwitch action. @see UAdvKitCA_UseSwitch"));
				MetaData->SetValue(NewProp_UseWithItem, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Interaction/AdvKitCA_UseSwitch_Arguments.h"));
				MetaData->SetValue(NewProp_UseWithItem, TEXT("ToolTip"), TEXT("Item to use switch with (e.g. a key)"));
				MetaData->SetValue(NewProp_UseSwitch, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Interaction/AdvKitCA_UseSwitch_Arguments.h"));
				MetaData->SetValue(NewProp_UseSwitch, TEXT("ToolTip"), TEXT("Switch to use (e.g. a lock)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_UseSwitch_Arguments(Z_Construct_UClass_UAdvKitCA_UseSwitch_Arguments, &UAdvKitCA_UseSwitch_Arguments::StaticClass, TEXT("UAdvKitCA_UseSwitch_Arguments"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_UseSwitch_Arguments);
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Arguments_NoRegister()
	{
		return UAdvKitCA_ZoneTransition_Arguments::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_ZoneTransition_Arguments()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_Arguments();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_ZoneTransition_Arguments::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, UAdvKitCA_ZoneTransition_Arguments), 0x0010000000000004, Z_Construct_UClass_AAdvKitZone_NoRegister());
				UProperty* NewProp_Transition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Transition"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Transition, UAdvKitCA_ZoneTransition_Arguments), 0x001000000008000c, Z_Construct_UClass_UAdvKitTransitionComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AdvKitCA_ZoneTransition_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Arguments.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Arguments for a UAdvKitCA_ZoneTransition action.\n\n@see UAdvKitCA_ZoneTransition"));
				MetaData->SetValue(NewProp_Zone, TEXT("Category"), TEXT("AdvKitCA_ZoneTransition_Arguments"));
				MetaData->SetValue(NewProp_Zone, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Arguments.h"));
				MetaData->SetValue(NewProp_Zone, TEXT("ToolTip"), TEXT("Target zone of the transition"));
				MetaData->SetValue(NewProp_Transition, TEXT("Category"), TEXT("AdvKitCA_ZoneTransition_Arguments"));
				MetaData->SetValue(NewProp_Transition, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Transition, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AdvKitCA_ZoneTransition_Arguments.h"));
				MetaData->SetValue(NewProp_Transition, TEXT("ToolTip"), TEXT("Transition component along which the transition happens."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_ZoneTransition_Arguments(Z_Construct_UClass_UAdvKitCA_ZoneTransition_Arguments, &UAdvKitCA_ZoneTransition_Arguments::StaticClass, TEXT("UAdvKitCA_ZoneTransition_Arguments"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_ZoneTransition_Arguments);
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier_NoRegister()
	{
		return UAdvKitCharacterAction_CharacterModifier::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterAction_CharacterModifier::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103081;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AdvKitCharacterAction_CharacterModifier.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_CharacterModifier.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Every action can change the state of their respective owner character. This class works as\nan utility to encapsulate configuration parameters."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterAction_CharacterModifier(Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier, &UAdvKitCharacterAction_CharacterModifier::StaticClass, TEXT("UAdvKitCharacterAction_CharacterModifier"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterAction_CharacterModifier);
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_Auto_MovementMode_NoRegister()
	{
		return UAdvKitCA_Mod_Auto_MovementMode::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_Auto_MovementMode()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Mod_Auto_MovementMode::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Apply Transition Movement Mode"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Modifiers/AdvKitCA_Mod_Auto_MovementMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Auto_MovementMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Changes the character's movement mode automatically based on the new zone"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Mod_Auto_MovementMode(Z_Construct_UClass_UAdvKitCA_Mod_Auto_MovementMode, &UAdvKitCA_Mod_Auto_MovementMode::StaticClass, TEXT("UAdvKitCA_Mod_Auto_MovementMode"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Mod_Auto_MovementMode);
	UScriptStruct* Z_Construct_UScriptStruct_FResponseConfig()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FResponseConfig_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("ResponseConfig"), sizeof(FResponseConfig), Get_Z_Construct_UScriptStruct_FResponseConfig_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ResponseConfig"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FResponseConfig>, EStructFlags(0x00000001));
			UProperty* NewProp_Response = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Response"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Response, FResponseConfig), 0x0010000000000001, Z_Construct_UEnum_Engine_ECollisionResponse());
			UProperty* NewProp_Channel = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Channel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Channel, FResponseConfig), 0x0010000000000001, Z_Construct_UEnum_Engine_ECollisionChannel());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Helper struct to configure responses to channels."));
			MetaData->SetValue(NewProp_Response, TEXT("Category"), TEXT("ResponseConfig"));
			MetaData->SetValue(NewProp_Response, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
			MetaData->SetValue(NewProp_Channel, TEXT("Category"), TEXT("ResponseConfig"));
			MetaData->SetValue(NewProp_Channel, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FResponseConfig_CRC() { return 2222102662U; }
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_Collision_NoRegister()
	{
		return UAdvKitCA_Mod_Collision::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_Collision()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Mod_Collision::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableCollision, UAdvKitCA_Mod_Collision, bool);
				UProperty* NewProp_bEnableCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableCollision, UAdvKitCA_Mod_Collision), 0x0010000000000001, CPP_BOOL_PROPERTY_BITMASK(bEnableCollision, UAdvKitCA_Mod_Collision), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bChangeCollision, UAdvKitCA_Mod_Collision, bool);
				UProperty* NewProp_bChangeCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bChangeCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bChangeCollision, UAdvKitCA_Mod_Collision), 0x0010000000000001, CPP_BOOL_PROPERTY_BITMASK(bChangeCollision, UAdvKitCA_Mod_Collision), sizeof(bool), true);
				UProperty* NewProp_ResponseChanges = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ResponseChanges"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ResponseChanges, UAdvKitCA_Mod_Collision), 0x0010000000000001);
				UProperty* NewProp_ResponseChanges_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ResponseChanges, TEXT("ResponseChanges"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FResponseConfig());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Modify Collision"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
				MetaData->SetValue(OuterClass, TEXT("OnlyDefaultConstructorDeclared"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Changes the characters collision in an action"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("EditCondition"), TEXT("bChangeCollision"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("Tooltip"), TEXT("Enable or disable collision."));
				MetaData->SetValue(NewProp_bChangeCollision, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bChangeCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
				MetaData->SetValue(NewProp_bChangeCollision, TEXT("Tooltip"), TEXT("Toggle whether or not to change collision."));
				MetaData->SetValue(NewProp_ResponseChanges, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_ResponseChanges, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Collision.h"));
				MetaData->SetValue(NewProp_ResponseChanges, TEXT("Tooltip"), TEXT("Changes to make regarding the character capsule's collision response."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Mod_Collision(Z_Construct_UClass_UAdvKitCA_Mod_Collision, &UAdvKitCA_Mod_Collision::StaticClass, TEXT("UAdvKitCA_Mod_Collision"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Mod_Collision);
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_Item_NoRegister()
	{
		return UAdvKitCA_Mod_Item::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_Item()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Mod_Item::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstantItemChange, UAdvKitCA_Mod_Item, bool);
				UProperty* NewProp_bInstantItemChange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInstantItemChange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstantItemChange, UAdvKitCA_Mod_Item), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bInstantItemChange, UAdvKitCA_Mod_Item), sizeof(bool), true);
				UProperty* NewProp_ItemClassToEquip = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ItemClassToEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ItemClassToEquip, UAdvKitCA_Mod_Item), 0x0014000000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Modify Item"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Modifiers/AdvKitCA_Mod_Item.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Item.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Changes the character's equipped item"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("DisplayName"), TEXT("Change Item instantly"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("EditCondition"), TEXT("bChangeEquippedItem"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Item.h"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("Tooltip"), TEXT("The new item to equip (or unequip current if value is None)."));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("DisplayName"), TEXT("Item to equip"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("EditCondition"), TEXT("bChangeEquippedItem"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_Item.h"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("Tooltip"), TEXT("The new item to equip (or unequip current if value is None)."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Mod_Item(Z_Construct_UClass_UAdvKitCA_Mod_Item, &UAdvKitCA_Mod_Item::StaticClass, TEXT("UAdvKitCA_Mod_Item"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Mod_Item);
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_MovementMode_NoRegister()
	{
		return UAdvKitCA_Mod_MovementMode::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_MovementMode()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Mod_MovementMode::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, UAdvKitCA_Mod_MovementMode), 0x0010000000000015);
				UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementMode, UAdvKitCA_Mod_MovementMode), 0x0010000000000015, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Modify Movement Mode"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Modifiers/AdvKitCA_Mod_MovementMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_MovementMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Changes the character's movement mode"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("EditCondition"), TEXT("bChangeMovementMode"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_MovementMode.h"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("Tooltip"), TEXT("The new custom movement mode."));
				MetaData->SetValue(NewProp_MovementMode, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("EditCondition"), TEXT("bChangeMovementMode"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_MovementMode.h"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("Tooltip"), TEXT("The new movement mode."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Mod_MovementMode(Z_Construct_UClass_UAdvKitCA_Mod_MovementMode, &UAdvKitCA_Mod_MovementMode::StaticClass, TEXT("UAdvKitCA_Mod_MovementMode"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Mod_MovementMode);
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_OrientationToZone_NoRegister()
	{
		return UAdvKitCA_Mod_OrientationToZone::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_OrientationToZone()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Mod_OrientationToZone::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Rotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Rotation, UAdvKitCA_Mod_OrientationToZone), 0x0020080000000015, Z_Construct_UScriptStruct_FRotator());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSetRotation, UAdvKitCA_Mod_OrientationToZone, bool);
				UProperty* NewProp_bSetRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSetRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSetRotation, UAdvKitCA_Mod_OrientationToZone), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bSetRotation, UAdvKitCA_Mod_OrientationToZone), sizeof(bool), true);
				UProperty* NewProp_Location = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Location"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Location, UAdvKitCA_Mod_OrientationToZone), 0x0020080000000015, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSetLocation, UAdvKitCA_Mod_OrientationToZone, bool);
				UProperty* NewProp_bSetLocation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSetLocation, UAdvKitCA_Mod_OrientationToZone), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bSetLocation, UAdvKitCA_Mod_OrientationToZone), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Orient To Zone"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Modifiers/AdvKitCA_Mod_OrientationToZone.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_OrientationToZone.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Changes the character's transform relative to the zone it transitions to/from"));
				MetaData->SetValue(NewProp_Rotation, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_Rotation, TEXT("EditCondition"), TEXT("bSetRotation"));
				MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_OrientationToZone.h"));
				MetaData->SetValue(NewProp_Rotation, TEXT("ToolTip"), TEXT("Relative rotation to set"));
				MetaData->SetValue(NewProp_bSetRotation, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bSetRotation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_OrientationToZone.h"));
				MetaData->SetValue(NewProp_bSetRotation, TEXT("ToolTip"), TEXT("Whether to set a relative rotation"));
				MetaData->SetValue(NewProp_Location, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_Location, TEXT("EditCondition"), TEXT("bSetLocation"));
				MetaData->SetValue(NewProp_Location, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_OrientationToZone.h"));
				MetaData->SetValue(NewProp_Location, TEXT("ToolTip"), TEXT("Relative location to set"));
				MetaData->SetValue(NewProp_bSetLocation, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bSetLocation, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_OrientationToZone.h"));
				MetaData->SetValue(NewProp_bSetLocation, TEXT("ToolTip"), TEXT("Whether to set a relative location"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Mod_OrientationToZone(Z_Construct_UClass_UAdvKitCA_Mod_OrientationToZone, &UAdvKitCA_Mod_OrientationToZone::StaticClass, TEXT("UAdvKitCA_Mod_OrientationToZone"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Mod_OrientationToZone);
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_YawRotationBind_NoRegister()
	{
		return UAdvKitCA_Mod_YawRotationBind::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCA_Mod_YawRotationBind()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCA_Mod_YawRotationBind::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20103080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerRotationYawInFirstPerson, UAdvKitCA_Mod_YawRotationBind, bool);
				UProperty* NewProp_bUseControllerRotationYawInFirstPerson = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerRotationYawInFirstPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerRotationYawInFirstPerson, UAdvKitCA_Mod_YawRotationBind), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bUseControllerRotationYawInFirstPerson, UAdvKitCA_Mod_YawRotationBind), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Modify Controller Yaw Usage"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Modifiers/AdvKitCA_Mod_YawRotationBind.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_YawRotationBind.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Changes the character's rotation binding"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("EditCondition"), TEXT("bChangeYawRotationBind"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Modifiers/AdvKitCA_Mod_YawRotationBind.h"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("ToolTip"), TEXT("Whether or not to use the controller rotation when in first person."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCA_Mod_YawRotationBind(Z_Construct_UClass_UAdvKitCA_Mod_YawRotationBind, &UAdvKitCA_Mod_YawRotationBind::StaticClass, TEXT("UAdvKitCA_Mod_YawRotationBind"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCA_Mod_YawRotationBind);
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_StateConfiguration_NoRegister()
	{
		return UAdvKitCharacterAction_StateConfiguration::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitCharacterAction_StateConfiguration()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitCharacterAction_StateConfiguration::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseControllerRotationYawInFirstPerson, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bUseControllerRotationYawInFirstPerson = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseControllerRotationYawInFirstPerson"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseControllerRotationYawInFirstPerson, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bUseControllerRotationYawInFirstPerson, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bChangeYawRotationBind, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bChangeYawRotationBind = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bChangeYawRotationBind"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bChangeYawRotationBind, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bChangeYawRotationBind, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstantItemChange, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bInstantItemChange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInstantItemChange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstantItemChange, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bInstantItemChange, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
				UProperty* NewProp_ItemClassToEquip = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ItemClassToEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ItemClassToEquip, UAdvKitCharacterAction_StateConfiguration), 0x0014000000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bChangeEquippedItem, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bChangeEquippedItem = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bChangeEquippedItem"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bChangeEquippedItem, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bChangeEquippedItem, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
				UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015);
				UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementMode, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bChangeMovementMode, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bChangeMovementMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bChangeMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bChangeMovementMode, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bChangeMovementMode, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableCollision, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bEnableCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableCollision, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bEnableCollision, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bChangeCollision, UAdvKitCharacterAction_StateConfiguration, bool);
				UProperty* NewProp_bChangeCollision = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bChangeCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bChangeCollision, UAdvKitCharacterAction_StateConfiguration), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bChangeCollision, UAdvKitCharacterAction_StateConfiguration), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(OuterClass, TEXT("OnlyDefaultConstructorDeclared"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Every action can change the state of their respective owner character. This class works as\nan utility to encapsulate configuration parameters."));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("EditCondition"), TEXT("bChangeYawRotationBind"));
				MetaData->SetValue(NewProp_bUseControllerRotationYawInFirstPerson, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bChangeYawRotationBind, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bChangeYawRotationBind, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("DisplayName"), TEXT("Change Item instantly"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("EditCondition"), TEXT("bChangeEquippedItem"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bInstantItemChange, TEXT("Tooltip"), TEXT("The new item to equip (or unequip current if value is None)."));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("DisplayName"), TEXT("Item to equip"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("EditCondition"), TEXT("bChangeEquippedItem"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_ItemClassToEquip, TEXT("Tooltip"), TEXT("The new item to equip (or unequip current if value is None)."));
				MetaData->SetValue(NewProp_bChangeEquippedItem, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bChangeEquippedItem, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bChangeEquippedItem, TEXT("Tooltip"), TEXT("Whether or not to change the equipped item (or unequip current in case 'Item to equip' is None)."));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("EditCondition"), TEXT("bChangeMovementMode"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_CustomMovementMode, TEXT("Tooltip"), TEXT("The new custom movement mode."));
				MetaData->SetValue(NewProp_MovementMode, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("EditCondition"), TEXT("bChangeMovementMode"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_MovementMode, TEXT("Tooltip"), TEXT("The new movement mode."));
				MetaData->SetValue(NewProp_bChangeMovementMode, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bChangeMovementMode, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bChangeMovementMode, TEXT("Tooltip"), TEXT("Whether or not to change the movement mode."));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("EditCondition"), TEXT("bChangeCollision"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bEnableCollision, TEXT("Tooltip"), TEXT("Enable or disable collision."));
				MetaData->SetValue(NewProp_bChangeCollision, TEXT("Category"), TEXT("Configuration"));
				MetaData->SetValue(NewProp_bChangeCollision, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AdvKitCharacterAction_StateConfiguration.h"));
				MetaData->SetValue(NewProp_bChangeCollision, TEXT("Tooltip"), TEXT("Whether or not to change the collision."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitCharacterAction_StateConfiguration(Z_Construct_UClass_UAdvKitCharacterAction_StateConfiguration, &UAdvKitCharacterAction_StateConfiguration::StaticClass, TEXT("UAdvKitCharacterAction_StateConfiguration"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitCharacterAction_StateConfiguration);
	UFunction* Z_Construct_UFunction_AAdvKitCharacterActionManager_StartActionServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitCharacterActionManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartActionServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80280CC0, 65535, sizeof(AdvKitCharacterActionManager_eventStartActionServer_Parms));
			UProperty* NewProp_Arguments = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Arguments"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Arguments, AdvKitCharacterActionManager_eventStartActionServer_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitCharacterAction_Arguments_NoRegister());
			UProperty* NewProp_ActionClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActionClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ActionClass, AdvKitCharacterActionManager_eventStartActionServer_Parms), 0x0014000000000080, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterActionManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to start an action\n@param       ActionClass             Class of the action to start\n@param       Arguments       Arguments passed to the started action"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitCharacterActionManager_NoRegister()
	{
		return AAdvKitCharacterActionManager::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitCharacterActionManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitCharacterActionManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitCharacterActionManager_StartActionServer());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLogDebugInfo, AAdvKitCharacterActionManager, bool);
				UProperty* NewProp_bLogDebugInfo = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bLogDebugInfo"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLogDebugInfo, AAdvKitCharacterActionManager), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bLogDebugInfo, AAdvKitCharacterActionManager), sizeof(bool), true);
				UProperty* NewProp_CurrentAction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentAction"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CurrentAction, AAdvKitCharacterActionManager), 0x00200800000a003d, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
				UProperty* NewProp_Actions = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Actions"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Actions, AAdvKitCharacterActionManager), 0x002008800002003d);
				UProperty* NewProp_Actions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Actions, TEXT("Actions"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x00000000000a0008, Z_Construct_UClass_UAdvKitCharacterAction_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitCharacterActionManager_StartActionServer(), "StartActionServer"); // 2574100855
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitCharacterActionManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterActionManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Within = AdvKitCharacter"));
				MetaData->SetValue(NewProp_bLogDebugInfo, TEXT("Category"), TEXT("Actions"));
				MetaData->SetValue(NewProp_bLogDebugInfo, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterActionManager.h"));
				MetaData->SetValue(NewProp_bLogDebugInfo, TEXT("ToolTip"), TEXT("Flag to make action manager log debug messages when executing actions"));
				MetaData->SetValue(NewProp_CurrentAction, TEXT("Category"), TEXT("Actions"));
				MetaData->SetValue(NewProp_CurrentAction, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CurrentAction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterActionManager.h"));
				MetaData->SetValue(NewProp_CurrentAction, TEXT("ToolTip"), TEXT("The currently active action."));
				MetaData->SetValue(NewProp_Actions, TEXT("Category"), TEXT("Actions"));
				MetaData->SetValue(NewProp_Actions, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Actions, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitCharacterActionManager.h"));
				MetaData->SetValue(NewProp_Actions, TEXT("ToolTip"), TEXT("List holding all actions that are currently handled by the manager."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitCharacterActionManager(Z_Construct_UClass_AAdvKitCharacterActionManager, &AAdvKitCharacterActionManager::StaticClass, TEXT("AAdvKitCharacterActionManager"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitCharacterActionManager);
	UFunction* Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_OnOrientationChanged()
	{
		struct AdvKitGravityCharacterMovementComponent_eventOnOrientationChanged_Parms
		{
			FTransform OldOrientation;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnOrientationChanged"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00C20400, 65535, sizeof(AdvKitGravityCharacterMovementComponent_eventOnOrientationChanged_Parms));
			UProperty* NewProp_OldOrientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldOrientation, AdvKitGravityCharacterMovementComponent_eventOnOrientationChanged_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacterMovementComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_SetGravityVector()
	{
		struct AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms
		{
			FVector GravityDirection;
			FVector GravityOrigin;
			bool bForce;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGravityVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bForce, AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms, bool);
			UProperty* NewProp_bForce = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bForce"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bForce, AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bForce, AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms), sizeof(bool), true);
			UProperty* NewProp_GravityOrigin = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GravityOrigin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GravityOrigin, AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_GravityDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GravityDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GravityDirection, AdvKitGravityCharacterMovementComponent_eventSetGravityVector_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Gravity"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bForce"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Checks if a hit result is a valid floor for wall walking\n@param       GravityDirection        New direction of gravity\n@param       GravityOrigin           New origin of gravity\n@param       bForce                          Set new gravity immediately, false to interpolate slowly"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent_NoRegister()
	{
		return UAdvKitGravityCharacterMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitCharacterMovementComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitGravityCharacterMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00280;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_OnOrientationChanged());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_SetGravityVector());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bResetOrientationWhenFalling, UAdvKitGravityCharacterMovementComponent, bool);
				UProperty* NewProp_bResetOrientationWhenFalling = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bResetOrientationWhenFalling"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bResetOrientationWhenFalling, UAdvKitGravityCharacterMovementComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bResetOrientationWhenFalling, UAdvKitGravityCharacterMovementComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateWorldOrientationByFloorResult, UAdvKitGravityCharacterMovementComponent, bool);
				UProperty* NewProp_bUpdateWorldOrientationByFloorResult = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUpdateWorldOrientationByFloorResult"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateWorldOrientationByFloorResult, UAdvKitGravityCharacterMovementComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUpdateWorldOrientationByFloorResult, UAdvKitGravityCharacterMovementComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUpdateWorldOrientationByTracing, UAdvKitGravityCharacterMovementComponent, bool);
				UProperty* NewProp_bUpdateWorldOrientationByTracing = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUpdateWorldOrientationByTracing"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUpdateWorldOrientationByTracing, UAdvKitGravityCharacterMovementComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUpdateWorldOrientationByTracing, UAdvKitGravityCharacterMovementComponent), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_OnOrientationChanged(), "OnOrientationChanged"); // 932536470
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitGravityCharacterMovementComponent_SetGravityVector(), "SetGravityVector"); // 3734646561
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitGravityCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Movement component that handles gravity set by the character's orientation component."));
				MetaData->SetValue(NewProp_bResetOrientationWhenFalling, TEXT("Category"), TEXT("Gravity"));
				MetaData->SetValue(NewProp_bResetOrientationWhenFalling, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bResetOrientationWhenFalling, TEXT("ToolTip"), TEXT("Reset gravity orientation when the character is falling (useful for things like magnetic boots)"));
				MetaData->SetValue(NewProp_bUpdateWorldOrientationByFloorResult, TEXT("Category"), TEXT("Gravity"));
				MetaData->SetValue(NewProp_bUpdateWorldOrientationByFloorResult, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bUpdateWorldOrientationByFloorResult, TEXT("ToolTip"), TEXT("Update the gravity orientation with the floor the character is walking on"));
				MetaData->SetValue(NewProp_bUpdateWorldOrientationByTracing, TEXT("Category"), TEXT("Gravity"));
				MetaData->SetValue(NewProp_bUpdateWorldOrientationByTracing, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bUpdateWorldOrientationByTracing, TEXT("ToolTip"), TEXT("Update the gravity orientation with the floor that is hit by the character's tracing component"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitGravityCharacterMovementComponent(Z_Construct_UClass_UAdvKitGravityCharacterMovementComponent, &UAdvKitGravityCharacterMovementComponent::StaticClass, TEXT("UAdvKitGravityCharacterMovementComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitGravityCharacterMovementComponent);
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitRifleFireType"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdvKitRifleFireType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitRifleFireType::InstantHit")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitRifleFireType::Projectile")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitRifleFireType::Custom")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitRifleFireType::EAdvKitRifleFireType_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EAdvKitRifleFireType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@brief Types of firing that are handled"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType_CRC() { return 3562317776U; }
	UClass* Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister()
	{
		return UAdvKitFireModeConfiguration::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitFireModeConfiguration()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UDataAsset();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitFireModeConfiguration::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_FireType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FireType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireType, UAdvKitFireModeConfiguration), 0x0010000000010001, Z_Construct_UEnum_AdvKitRuntime_EAdvKitRifleFireType());
				UProperty* NewProp_InstantDamageTypeClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstantDamageTypeClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(InstantDamageTypeClass, UAdvKitFireModeConfiguration), 0x0014000000010001, Z_Construct_UClass_UDamageType_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_InstantDamage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("InstantDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InstantDamage, UAdvKitFireModeConfiguration), 0x0010000000010015);
				UProperty* NewProp_TraceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TraceDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TraceDistance, UAdvKitFireModeConfiguration), 0x0010000000010015);
				UProperty* NewProp_ProjectileClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProjectileClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ProjectileClass, UAdvKitFireModeConfiguration), 0x0014000000010001, Z_Construct_UClass_AAdvKitProjectile_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_CharacterFireMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CharacterFireMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CharacterFireMontage, UAdvKitFireModeConfiguration), 0x0010000000010001, Z_Construct_UClass_UAnimMontage_NoRegister());
				UProperty* NewProp_RefireTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RefireTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RefireTime, UAdvKitFireModeConfiguration), 0x0010000000010015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShouldRefire, UAdvKitFireModeConfiguration, bool);
				UProperty* NewProp_bShouldRefire = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShouldRefire"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShouldRefire, UAdvKitFireModeConfiguration), 0x0010000000010015, CPP_BOOL_PROPERTY_BITMASK(bShouldRefire, UAdvKitFireModeConfiguration), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToFire, UAdvKitFireModeConfiguration, bool);
				UProperty* NewProp_bWantsToFire = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bWantsToFire"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToFire, UAdvKitFireModeConfiguration), 0x0010000000020815, CPP_BOOL_PROPERTY_BITMASK(bWantsToFire, UAdvKitFireModeConfiguration), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFireOnStop, UAdvKitFireModeConfiguration, bool);
				UProperty* NewProp_bFireOnStop = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bFireOnStop"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFireOnStop, UAdvKitFireModeConfiguration), 0x0010000000010015, CPP_BOOL_PROPERTY_BITMASK(bFireOnStop, UAdvKitFireModeConfiguration), sizeof(bool), true);
				UProperty* NewProp_Spread = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Spread"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Spread, UAdvKitFireModeConfiguration), 0x0010000000010015);
				UProperty* NewProp_AmmunitionPerShot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AmmunitionPerShot"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(AmmunitionPerShot, UAdvKitFireModeConfiguration), 0x0010000000010015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Configuration to hold values for firing @see AAdvKitWeapon."));
				MetaData->SetValue(NewProp_FireType, TEXT("Category"), TEXT("Fire"));
				MetaData->SetValue(NewProp_FireType, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_FireType, TEXT("ToolTip"), TEXT("Which fire type this mode is"));
				MetaData->SetValue(NewProp_InstantDamageTypeClass, TEXT("Category"), TEXT("Fire | Instant"));
				MetaData->SetValue(NewProp_InstantDamageTypeClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_InstantDamageTypeClass, TEXT("ToolTip"), TEXT("The type of damage to apply for instant hits"));
				MetaData->SetValue(NewProp_InstantDamage, TEXT("Category"), TEXT("Fire | Instant"));
				MetaData->SetValue(NewProp_InstantDamage, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_InstantDamage, TEXT("ToolTip"), TEXT("How much damage is caused per instant hit"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("Category"), TEXT("Fire | Instant"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_TraceDistance, TEXT("ToolTip"), TEXT("Trace length for projectile and instant hit mode"));
				MetaData->SetValue(NewProp_ProjectileClass, TEXT("Category"), TEXT("Fire | Projectile"));
				MetaData->SetValue(NewProp_ProjectileClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_ProjectileClass, TEXT("ToolTip"), TEXT("Montage to play on the character that is firing the weapon"));
				MetaData->SetValue(NewProp_CharacterFireMontage, TEXT("Category"), TEXT("Fire"));
				MetaData->SetValue(NewProp_CharacterFireMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_CharacterFireMontage, TEXT("ToolTip"), TEXT("Montage to play on the character that is firing the weapon"));
				MetaData->SetValue(NewProp_RefireTime, TEXT("Category"), TEXT("State"));
				MetaData->SetValue(NewProp_RefireTime, TEXT("EditCondition"), TEXT("!bFireOnStop"));
				MetaData->SetValue(NewProp_RefireTime, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_RefireTime, TEXT("ToolTip"), TEXT("How long to wait between firing (in Seconds)"));
				MetaData->SetValue(NewProp_bShouldRefire, TEXT("Category"), TEXT("State"));
				MetaData->SetValue(NewProp_bShouldRefire, TEXT("EditCondition"), TEXT("!bFireOnStop"));
				MetaData->SetValue(NewProp_bShouldRefire, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_bShouldRefire, TEXT("ToolTip"), TEXT("Can this weapon refire?"));
				MetaData->SetValue(NewProp_bWantsToFire, TEXT("Category"), TEXT("State"));
				MetaData->SetValue(NewProp_bWantsToFire, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_bWantsToFire, TEXT("ToolTip"), TEXT("Does this mode want to fire, even if it cannot yet?"));
				MetaData->SetValue(NewProp_bFireOnStop, TEXT("Category"), TEXT("State"));
				MetaData->SetValue(NewProp_bFireOnStop, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_bFireOnStop, TEXT("ToolTip"), TEXT("Only fire for this mode when the trigger is released"));
				MetaData->SetValue(NewProp_Spread, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_Spread, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_Spread, TEXT("ToolTip"), TEXT("How much to spread (in degrees) when shooting"));
				MetaData->SetValue(NewProp_AmmunitionPerShot, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_AmmunitionPerShot, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitFireModeConfiguration.h"));
				MetaData->SetValue(NewProp_AmmunitionPerShot, TEXT("ToolTip"), TEXT("How much ammunition is consumed per shot"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitFireModeConfiguration(Z_Construct_UClass_UAdvKitFireModeConfiguration, &UAdvKitFireModeConfiguration::StaticClass, TEXT("UAdvKitFireModeConfiguration"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitFireModeConfiguration);
	UScriptStruct* Z_Construct_UScriptStruct_FFootStepSound()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FFootStepSound_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FootStepSound"), sizeof(FFootStepSound), Get_Z_Construct_UScriptStruct_FFootStepSound_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FootStepSound"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FFootStepSound>, EStructFlags(0x00000001));
			UProperty* NewProp_Sound = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Sound"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Sound, FFootStepSound), 0x0010000000000001, Z_Construct_UClass_USoundCue_NoRegister());
			UProperty* NewProp_Surface = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Surface"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Surface, FFootStepSound), 0x0010000000000001, Z_Construct_UEnum_Engine_EPhysicalSurface());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Configuration struct to assign a sound cue to a specific surface"));
			MetaData->SetValue(NewProp_Sound, TEXT("Category"), TEXT("FootStepSound"));
			MetaData->SetValue(NewProp_Sound, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
			MetaData->SetValue(NewProp_Sound, TEXT("ToolTip"), TEXT("Sound cue that is played on configured surface"));
			MetaData->SetValue(NewProp_Surface, TEXT("Category"), TEXT("FootStepSound"));
			MetaData->SetValue(NewProp_Surface, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
			MetaData->SetValue(NewProp_Surface, TEXT("ToolTip"), TEXT("Physical surface to play sound for"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFootStepSound_CRC() { return 2528291014U; }
	UFunction* Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstep()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitFootstepComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayFootstep"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitFootstepComponent_eventPlayFootstep_Parms));
			UProperty* NewProp_Foot = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Foot"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Foot, AdvKitFootstepComponent_eventPlayFootstep_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tries to play a footstep sound for a configured foot.\n@param       Foot    Index (in Socket Array) of foot socket to play sound for"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstepAttached()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitFootstepComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PlayFootstepAttached"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitFootstepComponent_eventPlayFootstepAttached_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitFootstepComponent_eventPlayFootstepAttached_Parms), 0x0010000000080588, Z_Construct_UClass_UAudioComponent_NoRegister());
			UProperty* NewProp_Foot = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Foot"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Foot, AdvKitFootstepComponent_eventPlayFootstepAttached_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tries to play a footstep sound for a configured foot.\n@param       Foot    Index (in Socket Array) of foot socket to play sound for\n@return      Audio component playing the sound of the footstep"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitFootstepComponent_NoRegister()
	{
		return UAdvKitFootstepComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitFootstepComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitFootstepComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstep());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstepAttached());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_FootStepTraceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FootStepTraceDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FootStepTraceDistance, UAdvKitFootstepComponent), 0x0020080000000001);
				UProperty* NewProp_FootSocketNames = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FootSocketNames"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(FootSocketNames, UAdvKitFootstepComponent), 0x0020080000000015);
				UProperty* NewProp_FootSocketNames_Inner = new(EC_InternalUseOnlyConstructor, NewProp_FootSocketNames, TEXT("FootSocketNames"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_FootStepSounds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FootStepSounds"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(FootStepSounds, UAdvKitFootstepComponent), 0x0020080000000015);
				UProperty* NewProp_FootStepSounds_Inner = new(EC_InternalUseOnlyConstructor, NewProp_FootStepSounds, TEXT("FootStepSounds"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FFootStepSound());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstep(), "PlayFootstep"); // 1346977604
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitFootstepComponent_PlayFootstepAttached(), "PlayFootstepAttached"); // 1718554579
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility LOD Events Collision Physics Rendering Rendering | Material TextureStreaming Input Lighting Base Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitFootstepComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Utility component to play foot step sounds depending on what surface is beneath a\nfoot of the owning character"));
				MetaData->SetValue(NewProp_FootStepTraceDistance, TEXT("Category"), TEXT("AdvKitFootstepComponent"));
				MetaData->SetValue(NewProp_FootStepTraceDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
				MetaData->SetValue(NewProp_FootStepTraceDistance, TEXT("ToolTip"), TEXT("How far down to trace below a foot socket to detect the surface"));
				MetaData->SetValue(NewProp_FootSocketNames, TEXT("Category"), TEXT("AdvKitFootstepComponent"));
				MetaData->SetValue(NewProp_FootSocketNames, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
				MetaData->SetValue(NewProp_FootSocketNames, TEXT("ToolTip"), TEXT("List of foot sockets on the character"));
				MetaData->SetValue(NewProp_FootStepSounds, TEXT("Category"), TEXT("AdvKitFootstepComponent"));
				MetaData->SetValue(NewProp_FootStepSounds, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitFootstepComponent.h"));
				MetaData->SetValue(NewProp_FootStepSounds, TEXT("ToolTip"), TEXT("List of sounds configured for surfaces"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitFootstepComponent(Z_Construct_UClass_UAdvKitFootstepComponent, &UAdvKitFootstepComponent::StaticClass, TEXT("UAdvKitFootstepComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitFootstepComponent);
	UClass* Z_Construct_UClass_AAdvKitGameMode_NoRegister()
	{
		return AAdvKitGameMode::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitGameMode()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AGameMode();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitGameMode::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x2090028C;


				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Info Rendering MovementReplication Replication Actor Input Movement Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AdvKitGameMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/AdvKitGameMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Fairly rudimentary game mode extension, simply to set the AdvKit classes as defaults\n\nNote: May be removed in the future"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitGameMode(Z_Construct_UClass_AAdvKitGameMode, &AAdvKitGameMode::StaticClass, TEXT("AAdvKitGameMode"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitGameMode);
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitInventoryState"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdvKitInventoryState"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitInventoryState::Inactive")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitInventoryState::Equipping")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitInventoryState::Active")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitInventoryState::Uneqiupping")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitInventoryState::Unknown")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitInventoryState::EAdvKitInventoryState_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EAdvKitInventoryState");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@brief Enumeration to specify state of item"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState_CRC() { return 4172612036U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRepAdvKitInventoryState()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FRepAdvKitInventoryState_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RepAdvKitInventoryState"), sizeof(FRepAdvKitInventoryState), Get_Z_Construct_UScriptStruct_FRepAdvKitInventoryState_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RepAdvKitInventoryState"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FRepAdvKitInventoryState>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToUnequip, FRepAdvKitInventoryState, bool);
			UProperty* NewProp_bWantsToUnequip = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bWantsToUnequip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToUnequip, FRepAdvKitInventoryState), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bWantsToUnequip, FRepAdvKitInventoryState), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToEquip, FRepAdvKitInventoryState, bool);
			UProperty* NewProp_bWantsToEquip = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bWantsToEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToEquip, FRepAdvKitInventoryState), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bWantsToEquip, FRepAdvKitInventoryState), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstantChange, FRepAdvKitInventoryState, bool);
			UProperty* NewProp_bInstantChange = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bInstantChange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstantChange, FRepAdvKitInventoryState), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bInstantChange, FRepAdvKitInventoryState), sizeof(bool), true);
			UProperty* NewProp_State = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("State"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(State, FRepAdvKitInventoryState), 0x0010000000000000, Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Struct to handle all replicated state variables of an item."));
			MetaData->SetValue(NewProp_bWantsToUnequip, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(NewProp_bWantsToUnequip, TEXT("ToolTip"), TEXT("Item should be unequipped as soon as possible"));
			MetaData->SetValue(NewProp_bWantsToEquip, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(NewProp_bWantsToEquip, TEXT("ToolTip"), TEXT("Item should be equipped as soon as possible"));
			MetaData->SetValue(NewProp_bInstantChange, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(NewProp_bInstantChange, TEXT("ToolTip"), TEXT("Whether or not the state change is instant"));
			MetaData->SetValue(NewProp_State, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(NewProp_State, TEXT("ToolTip"), TEXT("Current state of the item"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRepAdvKitInventoryState_CRC() { return 3595208859U; }
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_AttachToCharacter()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AttachToCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Attaches this item to the character (e.g. a weapon to the hand).\nCalled when item is being equipped."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CanBeCombinedWith()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanBeCombinedWith"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitInventoryItem_eventCanBeCombinedWith_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitInventoryItem_eventCanBeCombinedWith_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitInventoryItem_eventCanBeCombinedWith_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitInventoryItem_eventCanBeCombinedWith_Parms), sizeof(bool), true);
			UProperty* NewProp_With = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("With"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(With, AdvKitInventoryItem_eventCanBeCombinedWith_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can this item be combined with another?\n\n@param       With    The other item to combine with.\n@return                      True if combinable."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CanEquip()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitInventoryItem_eventCanEquip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitInventoryItem_eventCanEquip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitInventoryItem_eventCanEquip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitInventoryItem_eventCanEquip_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventCanEquip_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventCanEquip_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventCanEquip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the item can be equipped.\n@param       bInstant        Can it be equipped instantly.\n@return      True if item can be equipped."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CanUneqiup()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanUneqiup"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitInventoryItem_eventCanUneqiup_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitInventoryItem_eventCanUneqiup_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitInventoryItem_eventCanUneqiup_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitInventoryItem_eventCanUneqiup_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventCanUneqiup_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventCanUneqiup_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventCanUneqiup_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the item can be unequipped.\n@param       bInstant        Can it be unequipped instantly.\n@return      True if item can be unequipped."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_CombinedWith()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CombinedWith"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitInventoryItem_eventCombinedWith_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryItem_eventCombinedWith_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_With = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("With"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(With, AdvKitInventoryItem_eventCombinedWith_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Combine this item with another.\n\n@param       With    The other item to combine with.\n@return                      The result of the combination."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_DetachFromCharacter()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DetachFromCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Detaches this item from the character (e.g. a weapon frmo the hand).\nCalled when item is being unequipped."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_Equip()
	{
		struct AdvKitInventoryItem_eventEquip_Parms
		{
			bool bInstant;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Equip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryItem_eventEquip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventEquip_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventEquip_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventEquip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tell the item to equip.\n@param       bInstant        True to equip instantly, otherwise regular equipment time and animations"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_EquipServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EquipServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80280CC0, 65535, sizeof(AdvKitInventoryItem_eventEquipServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventEquipServer_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventEquipServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventEquipServer_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to tell the item to equip.\n@param       bInstant        True to equip instantly, otherwise regular equipment time and animations"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_GetItemState()
	{
		struct AdvKitInventoryItem_eventGetItemState_Parms
		{
			TEnumAsByte<EAdvKitInventoryState> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetItemState"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AdvKitInventoryItem_eventGetItemState_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryItem_eventGetItemState_Parms), 0x0010000000000580, Z_Construct_UEnum_AdvKitRuntime_EAdvKitInventoryState());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Getter for the inventory item state.\n@return      State struct of the item."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnEquip()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitInventoryItem_eventOnEquip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventOnEquip_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventOnEquip_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventOnEquip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("On Equip Begin"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event called when item starts to equip.\n@param       bInstant        Whether equipping is instant or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnEquipped()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEquipped"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitInventoryItem_eventOnEquipped_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventOnEquipped_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventOnEquipped_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventOnEquipped_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("On Equip Finished"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event called when item finished equipping.\n@param       bInstant        Whether equipping was instant or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnRep_ItemState()
	{
		struct AdvKitInventoryItem_eventOnRep_ItemState_Parms
		{
			FRepAdvKitInventoryState PreviousRepItemState;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ItemState"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00080400, 65535, sizeof(AdvKitInventoryItem_eventOnRep_ItemState_Parms));
			UProperty* NewProp_PreviousRepItemState = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreviousRepItemState"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreviousRepItemState, AdvKitInventoryItem_eventOnRep_ItemState_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRepAdvKitInventoryState());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback when item state changed remotely.\n@param       PreviousRepItemState    State value before the change."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiup()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnUneqiup"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitInventoryItem_eventOnUneqiup_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventOnUneqiup_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventOnUneqiup_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventOnUneqiup_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("On Uneqiup Begin"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event called when item starts to unequip.\n@param       bInstant        Whether unequipping is instant or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiupped()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnUneqiupped"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitInventoryItem_eventOnUneqiupped_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventOnUneqiupped_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventOnUneqiupped_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventOnUneqiupped_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("On Uneqiup Finished"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event called when item finished unequipping.\n@param       bInstant        Whether unequipping was instant or not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_Uneqiup()
	{
		struct AdvKitInventoryItem_eventUneqiup_Parms
		{
			bool bInstant;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Uneqiup"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryItem_eventUneqiup_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventUneqiup_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventUneqiup_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventUneqiup_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tell the item to unequip.\n@param       bInstant        True to unequip instantly, otherwise regular unequipment time and animations"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryItem_UneqiupServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryItem();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UneqiupServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80280CC0, 65535, sizeof(AdvKitInventoryItem_eventUneqiupServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryItem_eventUneqiupServer_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryItem_eventUneqiupServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryItem_eventUneqiupServer_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to tell the item to unequip.\n@param       bInstant        True to equip instantly, otherwise regular unequipment time and animations"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitInventoryItem_NoRegister()
	{
		return AAdvKitInventoryItem::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitInventoryItem()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitInventoryItem::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_AttachToCharacter());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_CanBeCombinedWith());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_CanEquip());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_CanUneqiup());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_CombinedWith());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_DetachFromCharacter());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_Equip());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_EquipServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_GetItemState());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_OnEquip());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_OnEquipped());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_OnRep_ItemState());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiup());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiupped());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_Uneqiup());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryItem_UneqiupServer());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_RepItemState = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RepItemState"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(RepItemState, AAdvKitInventoryItem), 0x0020080100000020, Z_Construct_UScriptStruct_FRepAdvKitInventoryState());
				NewProp_RepItemState->RepNotifyFunc = FName(TEXT("OnRep_ItemState"));
				UProperty* NewProp_AttachmentSocketName = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AttachmentSocketName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(AttachmentSocketName, AAdvKitInventoryItem), 0x0010000000000015);
				UProperty* NewProp_UneqiupMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UneqiupMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(UneqiupMontage, AAdvKitInventoryItem), 0x0010000000000015, Z_Construct_UClass_UAnimMontage_NoRegister());
				UProperty* NewProp_UneqiupTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UneqiupTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(UneqiupTime, AAdvKitInventoryItem), 0x0010000000000015);
				UProperty* NewProp_EquipMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EquipMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(EquipMontage, AAdvKitInventoryItem), 0x0010000000000015, Z_Construct_UClass_UAnimMontage_NoRegister());
				UProperty* NewProp_EquipTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EquipTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(EquipTime, AAdvKitInventoryItem), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseAimOffset, AAdvKitInventoryItem, bool);
				UProperty* NewProp_bUseAimOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseAimOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseAimOffset, AAdvKitInventoryItem), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bUseAimOffset, AAdvKitInventoryItem), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDropOnDeath, AAdvKitInventoryItem, bool);
				UProperty* NewProp_bDropOnDeath = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDropOnDeath"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDropOnDeath, AAdvKitInventoryItem), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bDropOnDeath, AAdvKitInventoryItem), sizeof(bool), true);
				UProperty* NewProp_DroppedPickupClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DroppedPickupClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(DroppedPickupClass, AAdvKitInventoryItem), 0x0014000000000015, Z_Construct_UClass_AAdvKitPickup_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_Icon = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Icon"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Icon, AAdvKitInventoryItem), 0x0010000000010005, Z_Construct_UClass_UTexture_NoRegister());
				UProperty* NewProp_ItemDescription = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ItemDescription"), RF_Public|RF_Transient|RF_MarkAsNative) UTextProperty(CPP_PROPERTY_BASE(ItemDescription, AAdvKitInventoryItem), 0x0010000000000005);
				UProperty* NewProp_ItemName = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ItemName"), RF_Public|RF_Transient|RF_MarkAsNative) UTextProperty(CPP_PROPERTY_BASE(ItemName, AAdvKitInventoryItem), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_AttachToCharacter(), "AttachToCharacter"); // 3459414641
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_CanBeCombinedWith(), "CanBeCombinedWith"); // 2187760831
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_CanEquip(), "CanEquip"); // 1536354428
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_CanUneqiup(), "CanUneqiup"); // 1005298428
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_CombinedWith(), "CombinedWith"); // 344698855
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_DetachFromCharacter(), "DetachFromCharacter"); // 1864939785
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_Equip(), "Equip"); // 2486746517
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_EquipServer(), "EquipServer"); // 944727330
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_GetItemState(), "GetItemState"); // 2581485842
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_OnEquip(), "OnEquip"); // 3917453335
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_OnEquipped(), "OnEquipped"); // 3327187812
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_OnRep_ItemState(), "OnRep_ItemState"); // 217477554
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiup(), "OnUneqiup"); // 3153795759
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_OnUneqiupped(), "OnUneqiupped"); // 3675858017
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_Uneqiup(), "Uneqiup"); // 25051905
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryItem_UneqiupServer(), "UneqiupServer"); // 2688354178
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base item class that defines objects that the character can use\nand store in its inventory. Items can be equipped and unequipped."));
				MetaData->SetValue(NewProp_RepItemState, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_RepItemState, TEXT("ToolTip"), TEXT("Replicated state of the item."));
				MetaData->SetValue(NewProp_AttachmentSocketName, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_AttachmentSocketName, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_AttachmentSocketName, TEXT("ToolTip"), TEXT("Name of the socket on the character mesh to attach the inventory to when equipping."));
				MetaData->SetValue(NewProp_UneqiupMontage, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_UneqiupMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_UneqiupMontage, TEXT("ToolTip"), TEXT("Montage to play on the character when unequipping this item."));
				MetaData->SetValue(NewProp_UneqiupTime, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_UneqiupTime, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_UneqiupTime, TEXT("ToolTip"), TEXT("How long does it take to unequip this item (in Seconds)"));
				MetaData->SetValue(NewProp_EquipMontage, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_EquipMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_EquipMontage, TEXT("ToolTip"), TEXT("Montage to play on the character when equipping this item."));
				MetaData->SetValue(NewProp_EquipTime, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_EquipTime, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_EquipTime, TEXT("ToolTip"), TEXT("How long does it equip this item (in Seconds)"));
				MetaData->SetValue(NewProp_bUseAimOffset, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_bUseAimOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_bUseAimOffset, TEXT("ToolTip"), TEXT("Whether or not this item needs aim offsets (e.g. guns for targeting)"));
				MetaData->SetValue(NewProp_bDropOnDeath, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_bDropOnDeath, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_bDropOnDeath, TEXT("ToolTip"), TEXT("Flag to drop item when owner died"));
				MetaData->SetValue(NewProp_DroppedPickupClass, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_DroppedPickupClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_DroppedPickupClass, TEXT("ToolTip"), TEXT("Pickup that is dropped when this item is dropped by the owning character."));
				MetaData->SetValue(NewProp_Icon, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_Icon, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_Icon, TEXT("ToolTip"), TEXT("Icon to draw for this inventory item."));
				MetaData->SetValue(NewProp_ItemDescription, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_ItemDescription, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_ItemDescription, TEXT("ToolTip"), TEXT("Flavor text for the item."));
				MetaData->SetValue(NewProp_ItemName, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_ItemName, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryItem.h"));
				MetaData->SetValue(NewProp_ItemName, TEXT("ToolTip"), TEXT("Name of this inventory item."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitInventoryItem(Z_Construct_UClass_AAdvKitInventoryItem, &AAdvKitInventoryItem::StaticClass, TEXT("AAdvKitInventoryItem"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitInventoryItem);
	UClass* Z_Construct_UClass_AAdvKitInventorySimpleCombinable_NoRegister()
	{
		return AAdvKitInventorySimpleCombinable::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitInventorySimpleCombinable()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitInventoryItem();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitInventorySimpleCombinable::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_CombinationResultClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CombinationResultClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(CombinationResultClass, AAdvKitInventorySimpleCombinable), 0x0024080000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_CombinableWithClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CombinableWithClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(CombinableWithClass, AAdvKitInventorySimpleCombinable), 0x0024080000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitInventorySimpleCombinable.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventorySimpleCombinable.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Simple class for combination of two items. If successful both items are destroyed and a new item will be spawned."));
				MetaData->SetValue(NewProp_CombinationResultClass, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_CombinationResultClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventorySimpleCombinable.h"));
				MetaData->SetValue(NewProp_CombinationResultClass, TEXT("ToolTip"), TEXT("Result of a successful combination of items."));
				MetaData->SetValue(NewProp_CombinableWithClass, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_CombinableWithClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventorySimpleCombinable.h"));
				MetaData->SetValue(NewProp_CombinableWithClass, TEXT("ToolTip"), TEXT("Class of another item that this item can be combined with."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitInventorySimpleCombinable(Z_Construct_UClass_AAdvKitInventorySimpleCombinable, &AAdvKitInventorySimpleCombinable::StaticClass, TEXT("AAdvKitInventorySimpleCombinable"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitInventorySimpleCombinable);
	UFunction* Z_Construct_UFunction_AAdvKitProjectile_Init()
	{
		struct AdvKitProjectile_eventInit_Parms
		{
			FVector Direction;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitProjectile();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Init"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitProjectile_eventInit_Parms));
			UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, AdvKitProjectile_eventInit_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitProjectile.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Initializes the projectile movement into a specified direction.\n@param       Direction       Direction the projectile should fly in"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitProjectile_OnImpact()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitProjectile();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnImpact"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420C00, 65535, sizeof(AdvKitProjectile_eventOnImpact_Parms));
			UProperty* NewProp_Impact = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Impact"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Impact, AdvKitProjectile_eventOnImpact_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitProjectile.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback when projectile hit something.\n@param       Impact  Hit that triggered the event"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitProjectile_NoRegister()
	{
		return AAdvKitProjectile::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitProjectile()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitProjectile::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitProjectile_Init());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitProjectile_OnImpact());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MovementComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MovementComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(MovementComponent, AAdvKitProjectile), 0x00200800000a001d, Z_Construct_UClass_UProjectileMovementComponent_NoRegister());
				UProperty* NewProp_DefaultRootComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultRootComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DefaultRootComponent, AAdvKitProjectile), 0x00200800000a001d, Z_Construct_UClass_USphereComponent_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDestroyOnStop, AAdvKitProjectile, bool);
				UProperty* NewProp_bDestroyOnStop = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDestroyOnStop"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDestroyOnStop, AAdvKitProjectile), 0x0020080000010015, CPP_BOOL_PROPERTY_BITMASK(bDestroyOnStop, AAdvKitProjectile), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitProjectile_Init(), "Init"); // 3778426366
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitProjectile_OnImpact(), "OnImpact"); // 3105297006
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ChildCanTick"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitProjectile.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitProjectile.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Simple projectile class with a sphere root and projectile movement component with\ncallbacks for projectile death."));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitProjectile.h"));
				MetaData->SetValue(NewProp_MovementComponent, TEXT("ToolTip"), TEXT("Movement component for the projectile"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitProjectile.h"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("ToolTip"), TEXT("Root component for collision handling"));
				MetaData->SetValue(NewProp_bDestroyOnStop, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_bDestroyOnStop, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitProjectile.h"));
				MetaData->SetValue(NewProp_bDestroyOnStop, TEXT("ToolTip"), TEXT("Destroy the particle if movement stops"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitProjectile(Z_Construct_UClass_AAdvKitProjectile, &AAdvKitProjectile::StaticClass, TEXT("AAdvKitProjectile"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitProjectile);
	UEnum* Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAdvKitWeaponState"), 0, Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAdvKitWeaponState"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitWeaponState::Idle")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitWeaponState::Firing")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitWeaponState::Reloading")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAdvKitWeaponState::EAdvKitWeaponState_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EAdvKitWeaponState");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@brief States a weapon can be in"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState_CRC() { return 2697746132U; }
	UScriptStruct* Z_Construct_UScriptStruct_FAdvKitWeaponState()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_AdvKitRuntime();
		extern uint32 Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AdvKitWeaponState"), sizeof(FAdvKitWeaponState), Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdvKitWeaponState"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FAdvKitWeaponState>, EStructFlags(0x00000001));
			UProperty* NewProp_BurstCounter = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BurstCounter"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(BurstCounter, FAdvKitWeaponState), 0x0010000000000014);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToReload, FAdvKitWeaponState, bool);
			UProperty* NewProp_bWantsToReload = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bWantsToReload"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToReload, FAdvKitWeaponState), 0x0010000000000014, CPP_BOOL_PROPERTY_BITMASK(bWantsToReload, FAdvKitWeaponState), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWantsToFire, FAdvKitWeaponState, bool);
			UProperty* NewProp_bWantsToFire = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bWantsToFire"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWantsToFire, FAdvKitWeaponState), 0x0010000000000014, CPP_BOOL_PROPERTY_BITMASK(bWantsToFire, FAdvKitWeaponState), sizeof(bool), true);
			UProperty* NewProp_PendingFireMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PendingFireMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PendingFireMode, FAdvKitWeaponState), 0x0010000000000014);
			UProperty* NewProp_ActiveFireMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ActiveFireMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ActiveFireMode, FAdvKitWeaponState), 0x0010000000000014);
			UProperty* NewProp_State = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("State"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(State, FAdvKitWeaponState), 0x0010000000000014, Z_Construct_UEnum_AdvKitRuntime_EAdvKitWeaponState());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("@brief Helper struct to handle replication of all relevant weapon properties"));
			MetaData->SetValue(NewProp_BurstCounter, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(NewProp_BurstCounter, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(NewProp_BurstCounter, TEXT("ToolTip"), TEXT("Shot counter to replicate weapon effects"));
			MetaData->SetValue(NewProp_bWantsToReload, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(NewProp_bWantsToReload, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(NewProp_bWantsToReload, TEXT("ToolTip"), TEXT("Flag to set that weapon wants to reload as soon as possible"));
			MetaData->SetValue(NewProp_bWantsToFire, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(NewProp_bWantsToFire, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(NewProp_bWantsToFire, TEXT("ToolTip"), TEXT("Flag to set that the weapon wants to fire (even if it can't)"));
			MetaData->SetValue(NewProp_PendingFireMode, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(NewProp_PendingFireMode, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(NewProp_PendingFireMode, TEXT("ToolTip"), TEXT("Set in case the weapon wants to change fire modes"));
			MetaData->SetValue(NewProp_ActiveFireMode, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(NewProp_ActiveFireMode, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(NewProp_ActiveFireMode, TEXT("ToolTip"), TEXT("Which fire mode is currently active"));
			MetaData->SetValue(NewProp_State, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(NewProp_State, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(NewProp_State, TEXT("ToolTip"), TEXT("The current weapon state"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAdvKitWeaponState_CRC() { return 4028748475U; }
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitWeapon_eventAddAmmunition_Parms));
			UProperty* NewProp_Amount = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Amount"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Amount, AdvKitWeapon_eventAddAmmunition_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds ammunition to the weapon\n@param       Amount  How much to add."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_AddSpread()
	{
		struct AdvKitWeapon_eventAddSpread_Parms
		{
			FRotator OriginalAim;
			uint8 FireModeIndex;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSpread"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitWeapon_eventAddSpread_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventAddSpread_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventAddSpread_Parms), 0x0010000000000080);
			UProperty* NewProp_OriginalAim = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OriginalAim"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OriginalAim, AdvKitWeapon_eventAddSpread_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireModeIndex"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add spread to a fire orientation.\n@param       OriginalAim     Original fire orientation.\n@param       FireModeIndex   Different fire modes can have different spreads.\n@return Modified aim rotation."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockDamage()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlockDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420C00, 65535, sizeof(AdvKitWeapon_eventBlockDamage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventBlockDamage_Parms), 0x0010000000000580);
			UProperty* NewProp_DamageCauser = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageCauser"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DamageCauser, AdvKitWeapon_eventBlockDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_EventInstigator = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EventInstigator"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(EventInstigator, AdvKitWeapon_eventBlockDamage_Parms), 0x0010000000000080, Z_Construct_UClass_AController_NoRegister());
			UProperty* NewProp_DamageEvent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DamageEvent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DamageEvent, AdvKitWeapon_eventBlockDamage_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FDamageEvent());
			UProperty* NewProp_Damage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Damage"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Damage, AdvKitWeapon_eventBlockDamage_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Weapons like swords have the ability to block damage. The parameters are from the actor's take damage event.\n@param       Damage  Amount of damage taken.\n@param       DamageEvent     Data package that fully describes the damage received\n@param       EventInstigator         The Controller responsible for the damage\n@param       DamageCauser    The Actor that directly caused the damage (e.g. the projectile that exploded, or the enemy's sword)\n@return The remaining amount of damage after it's potential block."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_BlockedBy()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BlockedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitWeapon_eventBlockedBy_Parms));
			UProperty* NewProp_BlockedDamage = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BlockedDamage"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BlockedDamage, AdvKitWeapon_eventBlockedBy_Parms), 0x0010000000000080);
			UProperty* NewProp_By = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("By"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(By, AdvKitWeapon_eventBlockedBy_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback if an attack of this weapon was blocked by something\n@param       By      The actor that blocked the attack\n@param       BlockedDamage   How much damage was blocked"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanFire()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanFire"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitWeapon_eventCanFire_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventCanFire_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventCanFire_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventCanFire_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon can fire.\n@return True if it can, false if not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_CanReload()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanReload"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535, sizeof(AdvKitWeapon_eventCanReload_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventCanReload_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventCanReload_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventCanReload_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if weapon can be reloaded.\n@return True if it can be reloaded."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConsumeAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when a shot is fired to use up ammunition."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FireAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when firing to actually shoot. Depending on the fire type of the active mode it\ndelegates firing to FireInstant, FireProjectile or FireCustom."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireCustom()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FireCustom"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Custom fire hook, for other implementations."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireInstant()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FireInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Fires instant trace, applies damage to hit target."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_FireProjectile()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FireProjectile"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitWeapon_eventFireProjectile_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventFireProjectile_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitProjectile_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Fires a projectile configured by the current firing mode.\n@return The fired projectile, if successful"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim()
	{
		struct AdvKitWeapon_eventGetAdjustedAim_Parms
		{
			FVector StartFireLocation;
			uint8 FireModeIndex;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAdjustedAim"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitWeapon_eventGetAdjustedAim_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventGetAdjustedAim_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventGetAdjustedAim_Parms), 0x0010000000000080);
			UProperty* NewProp_StartFireLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StartFireLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(StartFireLocation, AdvKitWeapon_eventGetAdjustedAim_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireModeIndex"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the direction in which to fire. Adds spread to it.\n@param       StartFireLocation       World space location to fire (bullet) from.\n@param       FireModeIndex   Fire mode might change the direction.\n@return Rotation with X axis facing in direction of fire."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass()
	{
		struct AdvKitWeapon_eventGetFireModeClass_Parms
		{
			uint8 FireModeIndex;
			TSubclassOf<UAdvKitFireModeConfiguration>  ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetFireModeClass"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04080400, 65535, sizeof(AdvKitWeapon_eventGetFireModeClass_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventGetFireModeClass_Parms), 0x0014000000000580, Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventGetFireModeClass_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Get Fire Mode"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query a specific fire mode.\n@param       FireModeIndex   The mode to get\n@return Pointer to the class of the fire mode if it exists, nullptr otherwise"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMuzzleLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C820C00, 65535, sizeof(AdvKitWeapon_eventGetMuzzleLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventGetMuzzleLocation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventGetMuzzleLocation_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireModeIndex"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the muzzle point of the weapon to spawn a projectile\n@param       FireModeIndex   If the weapon has more than one muzzle it can return different ones\n@return World space location of the muzzle"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTraceStart"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C820C00, 65535, sizeof(AdvKitWeapon_eventGetTraceStart_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitWeapon_eventGetTraceStart_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventGetTraceStart_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireModeIndex"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the starting location for a trace for projectile/instant fire mode. The default implementation\ntraces from the character's viewpoint to determine the target and then fires form the muzzle location\nto the hit.\n@param       FireModeIndex   Depending on fire mode the weapon can have different start locations.\n@return World space location of where to begin the trace"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HandleFiringPrerequisites"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called if player wants to but the weapon cannot fire, e.g. to check if it needs to be reloaded."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition()
	{
		struct AdvKitWeapon_eventHasAmmunition_Parms
		{
			int32 Amount;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventHasAmmunition_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventHasAmmunition_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventHasAmmunition_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventHasAmmunition_Parms), sizeof(bool), true);
			UProperty* NewProp_Amount = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Amount"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Amount, AdvKitWeapon_eventHasAmmunition_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Ammunition"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Amount"), TEXT("1"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon has a given amount of ammunition (disregarding if in magazine or not)\n@param       Amount  How much ammunition to ask for\n@return True if the weapon has at least the specified amount, false otherwise"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine()
	{
		struct AdvKitWeapon_eventHasAmmunitionInMagazine_Parms
		{
			int32 Amount;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasAmmunitionInMagazine"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventHasAmmunitionInMagazine_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventHasAmmunitionInMagazine_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventHasAmmunitionInMagazine_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventHasAmmunitionInMagazine_Parms), sizeof(bool), true);
			UProperty* NewProp_Amount = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Amount"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Amount, AdvKitWeapon_eventHasAmmunitionInMagazine_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Ammunition"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Amount"), TEXT("1"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon has a given amount of ammunition in the current magazine\n@param       Amount  How much ammunition to ask for\n@return True if the weapon has at least the specified amount, false otherwise"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_HasFireMode()
	{
		struct AdvKitWeapon_eventHasFireMode_Parms
		{
			uint8 FireModeIndex;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasFireMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04080400, 65535, sizeof(AdvKitWeapon_eventHasFireMode_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventHasFireMode_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventHasFireMode_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventHasFireMode_Parms), sizeof(bool), true);
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventHasFireMode_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon has a specified fire mode.\n@param       FireModeIndex   The mode to check for\n@return True if mode exists, false otherwise"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsFiring()
	{
		struct AdvKitWeapon_eventIsFiring_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsFiring"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventIsFiring_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventIsFiring_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventIsFiring_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventIsFiring_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|State"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon is currently firing\n@return True if firing"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsIdle()
	{
		struct AdvKitWeapon_eventIsIdle_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsIdle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventIsIdle_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventIsIdle_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventIsIdle_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventIsIdle_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|State"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon is currently doing nothing\n@return True if doing nothing"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty()
	{
		struct AdvKitWeapon_eventIsMagazineEmpty_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsMagazineEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventIsMagazineEmpty_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventIsMagazineEmpty_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventIsMagazineEmpty_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventIsMagazineEmpty_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Ammunition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query if the magazine is empty\n@return True if empty"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_IsReloading()
	{
		struct AdvKitWeapon_eventIsReloading_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsReloading"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventIsReloading_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitWeapon_eventIsReloading_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitWeapon_eventIsReloading_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitWeapon_eventIsReloading_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|State"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the weapon is currently reloading\n@return True if reloading"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnFireBegin"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when the weapon starts firing."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnFireEnd"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when firing stops."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnFireShot()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnFireShot"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when FireAmmunition was called."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnMagazineEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Ammunition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when the weapon wants to fire but there is no ammo left in the current magazine."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnReloadBegin"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when the weapon starts to reload."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloaded()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnReloaded"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when the weapon has finished reloading."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnReloadEnd"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when reloading was aborted."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState()
	{
		struct AdvKitWeapon_eventOnRep_WeaponState_Parms
		{
			FAdvKitWeaponState OldState;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_WeaponState"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00080400, 65535, sizeof(AdvKitWeapon_eventOnRep_WeaponState_Parms));
			UProperty* NewProp_OldState = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldState"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldState, AdvKitWeapon_eventOnRep_WeaponState_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FAdvKitWeaponState());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback method when the server state changes\n@param OldState      State before the change"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnWeaponEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Ammunition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback event when the weapon wants to fire but has no mor ammunition."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_RefireTimer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RefireTimer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback method for refire timer"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReloadAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when reloading succeeded. Moves ammunition from store to magazine."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReloadedTimer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00080400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback method for the reload timer."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFire()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartFire"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitWeapon_eventStartFire_Parms));
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventStartFire_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireModeIndex"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tell the weapon to start firing (even though the weapon may not be able to)\n@param       FireModeIndex   Which mode to start firing in"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartFireInternal"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Internal method to actually start firing the pending or current fire mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartFireServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartFireServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x84280CC0, 65535, sizeof(AdvKitWeapon_eventStartFireServer_Parms));
			UProperty* NewProp_FireModeIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FireModeIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FireModeIndex, AdvKitWeapon_eventStartFireServer_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Server"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_FireModeIndex"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to tell the weapon to start firing (even though the weapon may not be able to)\n@param       FireModeIndex   Which mode to start firing in"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer()
	{
		struct AdvKitWeapon_eventStartRefireTimer_Parms
		{
			float Duration;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartRefireTimer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitWeapon_eventStartRefireTimer_Parms));
			UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Duration"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Duration, AdvKitWeapon_eventStartRefireTimer_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Starts the timer to do refires\n@param       Duration        How long to wait between fire calls"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReload()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartReload"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Initiates a reload"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartReloadInternal"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Internal method to start reloading timer and animations."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartReloadServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x84280CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Server"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to initiate a reload"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartReloadTimer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Start the timer for the reloading process. When the timer fires the reload is complete."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFire()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopFire"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stop firing, the weapon may however still continue (e.g. because it needs to calm down first)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopFireInternal"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Internal method to actually stop firing the active mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopFireServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopFireServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x84280CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Server"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to stop firing, the weapon may however still continue (e.g. because it needs to calm down first)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopRefireTimer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Fire"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops refiring"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReload()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopReload"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops a reload in progress without reloading ammo"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopReloadInternal"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Internal method to abort reload."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopReloadServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x84280CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon|Server"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server callback to stop a reload in progress without reloading ammo"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeapon();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopReloadTimer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Weapon Events|Reload"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Stops the reload timer (aborting it)."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitWeapon_NoRegister()
	{
		return AAdvKitWeapon::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitWeapon()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitInventoryItem();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitWeapon::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_AddSpread());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_BlockedBy());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_CanFire());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_CanReload());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_FireCustom());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_FireInstant());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_FireProjectile());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_HasFireMode());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_IsFiring());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_IsIdle());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_IsReloading());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnFireShot());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnReloaded());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_RefireTimer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartFire());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartFireServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartReload());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopFire());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopFireServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopReload());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Crosshair = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Crosshair"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Crosshair, AAdvKitWeapon), 0x0020080000010015, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_ReloadTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReloadTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReloadTime, AAdvKitWeapon), 0x0020080000010001);
				UProperty* NewProp_AmmoByReloading = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AmmoByReloading"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(AmmoByReloading, AAdvKitWeapon), 0x0020080000010001);
				UProperty* NewProp_CharacterReloadMontage = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CharacterReloadMontage"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CharacterReloadMontage, AAdvKitWeapon), 0x0020080000010001, Z_Construct_UClass_UAnimMontage_NoRegister());
				UProperty* NewProp_FireModes_OLD = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FireModes_OLD"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(FireModes_OLD, AAdvKitWeapon), 0x0020080000000034);
				UProperty* NewProp_FireModes_OLD_Inner = new(EC_InternalUseOnlyConstructor, NewProp_FireModes_OLD, TEXT("FireModes_OLD"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister());
				UProperty* NewProp_DefaultFireModes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultFireModes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(DefaultFireModes, AAdvKitWeapon), 0x0024080000010021);
				UProperty* NewProp_DefaultFireModes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_DefaultFireModes, TEXT("DefaultFireModes"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_UAdvKitFireModeConfiguration_NoRegister(), UClass::StaticClass());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasInfiniteAmmunition, AAdvKitWeapon, bool);
				UProperty* NewProp_bHasInfiniteAmmunition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHasInfiniteAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasInfiniteAmmunition, AAdvKitWeapon), 0x0020080000010015, CPP_BOOL_PROPERTY_BITMASK(bHasInfiniteAmmunition, AAdvKitWeapon), sizeof(bool), true);
				UProperty* NewProp_MaxAmmunition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxAmmunition"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(MaxAmmunition, AAdvKitWeapon), 0x0020080000010015);
				UProperty* NewProp_Ammunition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Ammunition"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Ammunition, AAdvKitWeapon), 0x0020080000010035);
				UProperty* NewProp_AmmunitionInMagazine = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AmmunitionInMagazine"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(AmmunitionInMagazine, AAdvKitWeapon), 0x0020080000010015);
				UProperty* NewProp_AmmunitionPerMagazine = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AmmunitionPerMagazine"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(AmmunitionPerMagazine, AAdvKitWeapon), 0x0020080000010015);
				UProperty* NewProp_DefaultRootComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultRootComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(DefaultRootComponent, AAdvKitWeapon), 0x00200800000a001d, Z_Construct_UClass_USceneComponent_NoRegister());
				UProperty* NewProp_WeaponState = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WeaponState"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WeaponState, AAdvKitWeapon), 0x0020080100000034, Z_Construct_UScriptStruct_FAdvKitWeaponState());
				NewProp_WeaponState->RepNotifyFunc = FName(TEXT("OnRep_WeaponState"));
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_AddAmmunition(), "AddAmmunition"); // 612593960
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_AddSpread(), "AddSpread"); // 409302657
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_BlockDamage(), "BlockDamage"); // 1214573657
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_BlockedBy(), "BlockedBy"); // 3079090560
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_CanFire(), "CanFire"); // 3910599251
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_CanReload(), "CanReload"); // 3029537753
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_ConsumeAmmunition(), "ConsumeAmmunition"); // 2861291135
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_FireAmmunition(), "FireAmmunition"); // 3249653180
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_FireCustom(), "FireCustom"); // 447169047
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_FireInstant(), "FireInstant"); // 1814947016
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_FireProjectile(), "FireProjectile"); // 176038957
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_GetAdjustedAim(), "GetAdjustedAim"); // 2774435350
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_GetFireModeClass(), "GetFireModeClass"); // 3983261034
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_GetMuzzleLocation(), "GetMuzzleLocation"); // 2053021192
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_GetTraceStart(), "GetTraceStart"); // 4074123750
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_HandleFiringPrerequisites(), "HandleFiringPrerequisites"); // 1755809777
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunition(), "HasAmmunition"); // 3649479964
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_HasAmmunitionInMagazine(), "HasAmmunitionInMagazine"); // 3997814561
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_HasFireMode(), "HasFireMode"); // 1360051470
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_IsFiring(), "IsFiring"); // 1029295545
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_IsIdle(), "IsIdle"); // 2418228701
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_IsMagazineEmpty(), "IsMagazineEmpty"); // 1176449247
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_IsReloading(), "IsReloading"); // 4134192282
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnFireBegin(), "OnFireBegin"); // 3062081313
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnFireEnd(), "OnFireEnd"); // 4081250027
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnFireShot(), "OnFireShot"); // 4205816551
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnMagazineEmpty(), "OnMagazineEmpty"); // 192653505
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnReloadBegin(), "OnReloadBegin"); // 4102615339
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnReloaded(), "OnReloaded"); // 3769177977
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnReloadEnd(), "OnReloadEnd"); // 2905136833
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnRep_WeaponState(), "OnRep_WeaponState"); // 2546459093
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_OnWeaponEmpty(), "OnWeaponEmpty"); // 3950326250
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_RefireTimer(), "RefireTimer"); // 4291565979
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_ReloadAmmunition(), "ReloadAmmunition"); // 1634266412
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_ReloadedTimer(), "ReloadedTimer"); // 3571065192
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartFire(), "StartFire"); // 1406976658
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartFireInternal(), "StartFireInternal"); // 1610444311
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartFireServer(), "StartFireServer"); // 1257467540
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartRefireTimer(), "StartRefireTimer"); // 4200112986
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartReload(), "StartReload"); // 775871806
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartReloadInternal(), "StartReloadInternal"); // 3710184403
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartReloadServer(), "StartReloadServer"); // 1767100127
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StartReloadTimer(), "StartReloadTimer"); // 2602843306
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopFire(), "StopFire"); // 3402425344
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopFireInternal(), "StopFireInternal"); // 1185635691
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopFireServer(), "StopFireServer"); // 3655318189
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopRefireTimer(), "StopRefireTimer"); // 2241395022
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopReload(), "StopReload"); // 68270118
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopReloadInternal(), "StopReloadInternal"); // 1549901059
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopReloadServer(), "StopReloadServer"); // 28009274
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeapon_StopReloadTimer(), "StopReloadTimer"); // 1748959043
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitWeapon.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base weapon class. Has some basic replicated handling on start-/stop firing and fire modes, as\nwell as base methods to implement custom behaviors.\n\nFor this explanation the weapon is described like a gun, even though the weapon functionality\nis not limited to guns. Calling StartFire implies that the trigger has been pulled. If the gun\nis currently firing on an alternate mode it will stop doing that and start the new mode by calling\nStartFireInternal. Here last checks are done, e.g. if there is enough ammunition and the weapon\nwill be reloaded if there isn't. If all prerequisites are met the weapon will actually fire by\ncalling FireAmmunition and then start a refire timer if configured.\n\nStopFire works in a similar matter. You should see Start-/StopFire as intents of the player, while\nthe corresponding internal methods are the actual clockwork that govern what the weapon does."));
				MetaData->SetValue(NewProp_Crosshair, TEXT("Category"), TEXT("Effects"));
				MetaData->SetValue(NewProp_Crosshair, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_Crosshair, TEXT("ToolTip"), TEXT("Optional texture to display on the HUD"));
				MetaData->SetValue(NewProp_ReloadTime, TEXT("Category"), TEXT("Reload"));
				MetaData->SetValue(NewProp_ReloadTime, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_ReloadTime, TEXT("ToolTip"), TEXT("How long a reload takes."));
				MetaData->SetValue(NewProp_AmmoByReloading, TEXT("Category"), TEXT("Reload"));
				MetaData->SetValue(NewProp_AmmoByReloading, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_AmmoByReloading, TEXT("ToolTip"), TEXT("How much ammunition is added with each reload."));
				MetaData->SetValue(NewProp_CharacterReloadMontage, TEXT("Category"), TEXT("Reload"));
				MetaData->SetValue(NewProp_CharacterReloadMontage, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_CharacterReloadMontage, TEXT("ToolTip"), TEXT("Optional anim montage to play character animation when reloading."));
				MetaData->SetValue(NewProp_FireModes_OLD, TEXT("Category"), TEXT("FireModes"));
				MetaData->SetValue(NewProp_FireModes_OLD, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_FireModes_OLD, TEXT("ToolTip"), TEXT("List of fire modes the weapon has"));
				MetaData->SetValue(NewProp_DefaultFireModes, TEXT("Category"), TEXT("FireModes"));
				MetaData->SetValue(NewProp_DefaultFireModes, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_DefaultFireModes, TEXT("ToolTip"), TEXT("Which fire modes the weapon should have, will be instantiated on startup"));
				MetaData->SetValue(NewProp_bHasInfiniteAmmunition, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_bHasInfiniteAmmunition, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_bHasInfiniteAmmunition, TEXT("ToolTip"), TEXT("This weapon has infinite Ammunition"));
				MetaData->SetValue(NewProp_MaxAmmunition, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_MaxAmmunition, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_MaxAmmunition, TEXT("ToolTip"), TEXT("How much ammunition the weapon can hold"));
				MetaData->SetValue(NewProp_Ammunition, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_Ammunition, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_Ammunition, TEXT("ToolTip"), TEXT("How much ammunition the weapon has"));
				MetaData->SetValue(NewProp_AmmunitionInMagazine, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_AmmunitionInMagazine, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_AmmunitionInMagazine, TEXT("ToolTip"), TEXT("How much ammunition is left in the current magazine"));
				MetaData->SetValue(NewProp_AmmunitionPerMagazine, TEXT("Category"), TEXT("Ammunition"));
				MetaData->SetValue(NewProp_AmmunitionPerMagazine, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_AmmunitionPerMagazine, TEXT("ToolTip"), TEXT("How much ammunition is held in a single magazine"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("Category"), TEXT("Weapon"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DefaultRootComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_WeaponState, TEXT("Category"), TEXT("Weapon"));
				MetaData->SetValue(NewProp_WeaponState, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeapon.h"));
				MetaData->SetValue(NewProp_WeaponState, TEXT("ToolTip"), TEXT("Struct holding all state variables of the weapon"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitWeapon(Z_Construct_UClass_AAdvKitWeapon, &AAdvKitWeapon::StaticClass, TEXT("AAdvKitWeapon"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitWeapon);
	UFunction* Z_Construct_UFunction_AAdvKitWeaponTracing_OnTraceHit()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeaponTracing();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnTraceHit"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020C00, 65535, sizeof(AdvKitWeaponTracing_eventOnTraceHit_Parms));
			UProperty* NewProp_Hit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Hit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Hit, AdvKitWeaponTracing_eventOnTraceHit_Parms), 0x0010008000000080, Z_Construct_UScriptStruct_FHitResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback when the weapon hit anything. Called for each hit.\n@param       Hit     The hit of the trace"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeaponTracing_StartTracing()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeaponTracing();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StartTracing"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enable tracing updates."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitWeaponTracing_StopTracing()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitWeaponTracing();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopTracing"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Disable tracing updates."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitWeaponTracing_NoRegister()
	{
		return AAdvKitWeaponTracing::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitWeaponTracing()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitWeapon();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitWeaponTracing::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeaponTracing_OnTraceHit());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeaponTracing_StartTracing());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitWeaponTracing_StopTracing());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_UnitsPerTrace = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UnitsPerTrace"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(UnitsPerTrace, AAdvKitWeaponTracing), 0x0020080000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsTracing, AAdvKitWeaponTracing, bool);
				UProperty* NewProp_bIsTracing = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsTracing"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsTracing, AAdvKitWeaponTracing), 0x0020080000020015, CPP_BOOL_PROPERTY_BITMASK(bIsTracing, AAdvKitWeaponTracing), sizeof(bool), true);
				UProperty* NewProp_TraceComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TraceComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TraceComponent, AAdvKitWeaponTracing), 0x00200800000a001d, Z_Construct_UClass_UAdvKitTraceUtilityComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeaponTracing_OnTraceHit(), "OnTraceHit"); // 4202212756
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeaponTracing_StartTracing(), "StartTracing"); // 1290127152
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitWeaponTracing_StopTracing(), "StopTracing"); // 3163426243
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitWeaponTracing.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class for sword like weapons.\n\nThis weapon class has a defined line that will hurt anything that intersects it.\nWhen the weapon is moved it will try to hit anything that crossed the path of the\ntrace line during the move."));
				MetaData->SetValue(NewProp_UnitsPerTrace, TEXT("Category"), TEXT("Weapon"));
				MetaData->SetValue(NewProp_UnitsPerTrace, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
				MetaData->SetValue(NewProp_UnitsPerTrace, TEXT("ToolTip"), TEXT("The number of sub traces when the weapon moved is Distance/UnitsPerTrace"));
				MetaData->SetValue(NewProp_bIsTracing, TEXT("Category"), TEXT("Weapon"));
				MetaData->SetValue(NewProp_bIsTracing, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
				MetaData->SetValue(NewProp_bIsTracing, TEXT("ToolTip"), TEXT("Flag to enable tracing updates"));
				MetaData->SetValue(NewProp_TraceComponent, TEXT("Category"), TEXT("Weapon"));
				MetaData->SetValue(NewProp_TraceComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_TraceComponent, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitWeaponTracing.h"));
				MetaData->SetValue(NewProp_TraceComponent, TEXT("ToolTip"), TEXT("Component responsible for handling the tracing."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitWeaponTracing(Z_Construct_UClass_AAdvKitWeaponTracing, &AAdvKitWeaponTracing::StaticClass, TEXT("AAdvKitWeaponTracing"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitWeaponTracing);
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_InventoryItemsChanged__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventInventoryItemsChanged_Parms
		{
			AAdvKitInventoryManager* InInventory;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InventoryItemsChanged__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventInventoryItemsChanged_Parms));
			UProperty* NewProp_InInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InInventory, _Script_AdvKitRuntime_eventInventoryItemsChanged_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryManager_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_ActiveItemChanged__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventActiveItemChanged_Parms
		{
			AAdvKitInventoryManager* InInventory;
			AAdvKitInventoryItem* NewItem;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ActiveItemChanged__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventActiveItemChanged_Parms));
			UProperty* NewProp_NewItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewItem, _Script_AdvKitRuntime_eventActiveItemChanged_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_InInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(InInventory, _Script_AdvKitRuntime_eventActiveItemChanged_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryManager_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_ItemRemovedSignature__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventItemRemovedSignature_Parms
		{
			AAdvKitInventoryManager* FromInventory;
			AAdvKitInventoryItem* Item;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ItemRemovedSignature__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventItemRemovedSignature_Parms));
			UProperty* NewProp_Item = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Item"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Item, _Script_AdvKitRuntime_eventItemRemovedSignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_FromInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FromInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(FromInventory, _Script_AdvKitRuntime_eventItemRemovedSignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryManager_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_ItemAddedSignature__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventItemAddedSignature_Parms
		{
			AAdvKitInventoryManager* ToInventory;
			AAdvKitInventoryItem* Item;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ItemAddedSignature__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventItemAddedSignature_Parms));
			UProperty* NewProp_Item = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Item"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Item, _Script_AdvKitRuntime_eventItemAddedSignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_ToInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ToInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ToInventory, _Script_AdvKitRuntime_eventItemAddedSignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryManager_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_AddInventory()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitInventoryManager_eventAddInventory_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEquip, AdvKitInventoryManager_eventAddInventory_Parms, bool);
			UProperty* NewProp_bEquip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bEquip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEquip, AdvKitInventoryManager_eventAddInventory_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bEquip, AdvKitInventoryManager_eventAddInventory_Parms), sizeof(bool), true);
			UProperty* NewProp_NewInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewInventory, AdvKitInventoryManager_eventAddInventory_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bEquip"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add a new item to the inventory e.g. when the character picks up a weapon.\n@param       NewInventory    New item to add\n@param       bEquip                  Whether or not to equip the new item"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_CanEquipInventory()
	{
		struct AdvKitInventoryManager_eventCanEquipInventory_Parms
		{
			AAdvKitInventoryItem* NewInventory;
			bool bInstant;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanEquipInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryManager_eventCanEquipInventory_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitInventoryManager_eventCanEquipInventory_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitInventoryManager_eventCanEquipInventory_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitInventoryManager_eventCanEquipInventory_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryManager_eventCanEquipInventory_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryManager_eventCanEquipInventory_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryManager_eventCanEquipInventory_Parms), sizeof(bool), true);
			UProperty* NewProp_NewInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewInventory, AdvKitInventoryManager_eventCanEquipInventory_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check to see if an item can be equipped\n@param       NewInventory    The item to equip\n@param       bInstant                False to play un-/equip animation, true to equip without delay\n@return True if it can be equipped, false otherwise"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_GetCurrentInventory()
	{
		struct AdvKitInventoryManager_eventGetCurrentInventory_Parms
		{
			AAdvKitInventoryItem* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCurrentInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(AdvKitInventoryManager_eventGetCurrentInventory_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryManager_eventGetCurrentInventory_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Getter for the currently equipped item.\n@return Current item"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_GetInventoryByClass()
	{
		struct AdvKitInventoryManager_eventGetInventoryByClass_Parms
		{
			TSubclassOf<AAdvKitInventoryItem>  InventoryClass;
			AAdvKitInventoryItem* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInventoryByClass"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryManager_eventGetInventoryByClass_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryManager_eventGetInventoryByClass_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_InventoryClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InventoryClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(InventoryClass, AdvKitInventoryManager_eventGetInventoryByClass_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the first inventory item that is of the given class.\n@param       InventoryClass  Class of item to find\n@return      Item that matches class"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_GetPendingInventory()
	{
		struct AdvKitInventoryManager_eventGetPendingInventory_Parms
		{
			AAdvKitInventoryItem* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPendingInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(AdvKitInventoryManager_eventGetPendingInventory_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryManager_eventGetPendingInventory_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Getter for the pending inventory item that will be equipped next.\n@return Pending item"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_NextItem()
	{
		struct AdvKitInventoryManager_eventNextItem_Parms
		{
			AAdvKitInventoryItem* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NextItem"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryManager_eventNextItem_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryManager_eventNextItem_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Cycle through the inventory array and equip the next item."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_OnRep_InventoryArray()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_InventoryArray"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00080400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Callback when the inventory array changed remotely."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_PreviousItem()
	{
		struct AdvKitInventoryManager_eventPreviousItem_Parms
		{
			AAdvKitInventoryItem* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PreviousItem"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryManager_eventPreviousItem_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitInventoryManager_eventPreviousItem_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Cycle through the inventory array and equip the previous item."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_RemoveInventory()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitInventoryManager_eventRemoveInventory_Parms));
			UProperty* NewProp_RemovedInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("RemovedInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(RemovedInventory, AdvKitInventoryManager_eventRemoveInventory_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Remove an item from the inventory e.g. when the character drops a weapon.\n@param       RemovedInventory        Item to remove"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventory()
	{
		struct AdvKitInventoryManager_eventSetNewInventory_Parms
		{
			AAdvKitInventoryItem* NewInventory;
			bool bInstant;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNewInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryManager_eventSetNewInventory_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryManager_eventSetNewInventory_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryManager_eventSetNewInventory_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryManager_eventSetNewInventory_Parms), sizeof(bool), true);
			UProperty* NewProp_NewInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewInventory, AdvKitInventoryManager_eventSetNewInventory_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Equip an item\n@param       NewInventory    The item to equip\n@param       bInstant                False to play un-/equip animation, true to equip without delay"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryByClass()
	{
		struct AdvKitInventoryManager_eventSetNewInventoryByClass_Parms
		{
			TSubclassOf<AAdvKitInventoryItem>  NewInventoryClass;
			bool bInstant;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNewInventoryByClass"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitInventoryManager_eventSetNewInventoryByClass_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryManager_eventSetNewInventoryByClass_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryManager_eventSetNewInventoryByClass_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryManager_eventSetNewInventoryByClass_Parms), sizeof(bool), true);
			UProperty* NewProp_NewInventoryClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInventoryClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(NewInventoryClass, AdvKitInventoryManager_eventSetNewInventoryByClass_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Inventory"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInstant"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Equip an item that is of the specified class\n@param       NewInventory    The class of the item to equip\n@param       bInstant                False to play un-/equip animation, true to equip without delay"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryServer()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitInventoryManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetNewInventoryServer"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220CC0, 65535, sizeof(AdvKitInventoryManager_eventSetNewInventoryServer_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInstant, AdvKitInventoryManager_eventSetNewInventoryServer_Parms, bool);
			UProperty* NewProp_bInstant = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInstant"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInstant, AdvKitInventoryManager_eventSetNewInventoryServer_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInstant, AdvKitInventoryManager_eventSetNewInventoryServer_Parms), sizeof(bool), true);
			UProperty* NewProp_NewInventory = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewInventory, AdvKitInventoryManager_eventSetNewInventoryServer_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Server call to equip an item that is of the specified class\n@param       NewInventory    The class of the item to equip\n@param       bInstant                False to play un-/equip animation, true to equip without delay"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitInventoryManager_NoRegister()
	{
		return AAdvKitInventoryManager::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitInventoryManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitInventoryManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_AddInventory());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_CanEquipInventory());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_GetCurrentInventory());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_GetInventoryByClass());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_GetPendingInventory());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_NextItem());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_OnRep_InventoryArray());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_PreviousItem());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_RemoveInventory());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventory());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryByClass());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryServer());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnInventoryItemsChanged = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnInventoryItemsChanged"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnInventoryItemsChanged, AAdvKitInventoryManager), 0x0010000010080000, Z_Construct_UDelegateFunction_AdvKitRuntime_InventoryItemsChanged__DelegateSignature());
				UProperty* NewProp_OnActiveItemChanged = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnActiveItemChanged"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnActiveItemChanged, AAdvKitInventoryManager), 0x0010000010080000, Z_Construct_UDelegateFunction_AdvKitRuntime_ActiveItemChanged__DelegateSignature());
				UProperty* NewProp_OnItemRemoved = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnItemRemoved"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnItemRemoved_DEPRECATED, AAdvKitInventoryManager), 0x0010000030080000, Z_Construct_UDelegateFunction_AdvKitRuntime_ItemRemovedSignature__DelegateSignature());
				UProperty* NewProp_OnItemAdded = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnItemAdded"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnItemAdded_DEPRECATED, AAdvKitInventoryManager), 0x0010000030080000, Z_Construct_UDelegateFunction_AdvKitRuntime_ItemAddedSignature__DelegateSignature());
				UProperty* NewProp_CurrentInventory = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CurrentInventory, AAdvKitInventoryManager), 0x0020080000020035, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
				UProperty* NewProp_PendingInventory = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PendingInventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PendingInventory, AAdvKitInventoryManager), 0x0020080000020035, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
				UProperty* NewProp_Inventory = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Inventory"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Inventory, AAdvKitInventoryManager), 0x0020080100020035);
				NewProp_Inventory->RepNotifyFunc = FName(TEXT("OnRep_InventoryArray"));
				UProperty* NewProp_Inventory_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Inventory, TEXT("Inventory"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000020000, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_AddInventory(), "AddInventory"); // 1343314794
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_CanEquipInventory(), "CanEquipInventory"); // 3006235840
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_GetCurrentInventory(), "GetCurrentInventory"); // 20280863
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_GetInventoryByClass(), "GetInventoryByClass"); // 3733137399
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_GetPendingInventory(), "GetPendingInventory"); // 691042206
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_NextItem(), "NextItem"); // 4233880450
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_OnRep_InventoryArray(), "OnRep_InventoryArray"); // 1344995326
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_PreviousItem(), "PreviousItem"); // 2409177443
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_RemoveInventory(), "RemoveInventory"); // 1324715776
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventory(), "SetNewInventory"); // 882765360
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryByClass(), "SetNewInventoryByClass"); // 2945454313
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitInventoryManager_SetNewInventoryServer(), "SetNewInventoryServer"); // 2654555510
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Within = AdvKitCharacter"));
				MetaData->SetValue(NewProp_OnInventoryItemsChanged, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_OnInventoryItemsChanged, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_OnInventoryItemsChanged, TEXT("ToolTip"), TEXT("Delegate that is called when a new item was added or removed"));
				MetaData->SetValue(NewProp_OnActiveItemChanged, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_OnActiveItemChanged, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_OnActiveItemChanged, TEXT("ToolTip"), TEXT("Delegate that is called when a new item was equipped"));
				MetaData->SetValue(NewProp_OnItemRemoved, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_OnItemRemoved, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_OnItemRemoved, TEXT("ToolTip"), TEXT("Delegate that is called when an item was removed from the inventory"));
				MetaData->SetValue(NewProp_OnItemAdded, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_OnItemAdded, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_OnItemAdded, TEXT("ToolTip"), TEXT("Delegate that is called when an item was added to the inventory"));
				MetaData->SetValue(NewProp_CurrentInventory, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_CurrentInventory, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_CurrentInventory, TEXT("ToolTip"), TEXT("Item that is currently equipped"));
				MetaData->SetValue(NewProp_PendingInventory, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_PendingInventory, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_PendingInventory, TEXT("ToolTip"), TEXT("Item the player wants to equip next"));
				MetaData->SetValue(NewProp_Inventory, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_Inventory, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitInventoryManager.h"));
				MetaData->SetValue(NewProp_Inventory, TEXT("ToolTip"), TEXT("All items currently in the inventory"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitInventoryManager(Z_Construct_UClass_AAdvKitInventoryManager, &AAdvKitInventoryManager::StaticClass, TEXT("AAdvKitInventoryManager"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitInventoryManager);
	UClass* Z_Construct_UClass_AAdvKitPlayerController_NoRegister()
	{
		return AAdvKitPlayerController::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitPlayerController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APlayerController();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitPlayerController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900284;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseRollCorrectionHACK, AAdvKitPlayerController, bool);
				UProperty* NewProp_bUseRollCorrectionHACK = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseRollCorrectionHACK"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseRollCorrectionHACK, AAdvKitPlayerController), 0x0020080000000001, CPP_BOOL_PROPERTY_BITMASK(bUseRollCorrectionHACK, AAdvKitPlayerController), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief This is a slightly modified version of the default player controller and lets\nthe character restrict the view rotation.\n\nThis is useful for first person, when\nthe player cannot turn their head beyond what the skeleton allows for."));
				MetaData->SetValue(NewProp_bUseRollCorrectionHACK, TEXT("Category"), TEXT("AdvKitPlayerController"));
				MetaData->SetValue(NewProp_bUseRollCorrectionHACK, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitPlayerController.h"));
				MetaData->SetValue(NewProp_bUseRollCorrectionHACK, TEXT("ToolTip"), TEXT("Check to make the controller snap roll of the view to zero.\nSome animations might change the camera's roll which causes\nproblems if it is not used otherwise.\nE.g. the view will tilt and never go back.\n\nNote: This is not a nice solution, but I haven't found a\nbetter alternative so far. May change in the future."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitPlayerController(Z_Construct_UClass_AAdvKitPlayerController, &AAdvKitPlayerController::StaticClass, TEXT("AAdvKitPlayerController"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitPlayerController);
	UClass* Z_Construct_UClass_AAdvKitGravityPlayerController_NoRegister()
	{
		return AAdvKitGravityPlayerController::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitGravityPlayerController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitPlayerController();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitGravityPlayerController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900284;


				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitGravityPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitGravityPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Player controller class for the gravity character."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitGravityPlayerController(Z_Construct_UClass_AAdvKitGravityPlayerController, &AAdvKitGravityPlayerController::StaticClass, TEXT("AAdvKitGravityPlayerController"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitGravityPlayerController);
	UClass* Z_Construct_UClass_UAdvKitTargetLockComponent_NoRegister()
	{
		return UAdvKitTargetLockComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitTargetLockComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitTargetLockComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TargetOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TargetOffset, UAdvKitTargetLockComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_MinimumDistanceFromCenter = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinimumDistanceFromCenter"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinimumDistanceFromCenter, UAdvKitTargetLockComponent), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Camera"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitTargetLockComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetLockComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief This component tries to keep an attached camera between the parent character and its target so\nthat both are in view at all times."));
				MetaData->SetValue(NewProp_TargetOffset, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_TargetOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetLockComponent.h"));
				MetaData->SetValue(NewProp_TargetOffset, TEXT("ToolTip"), TEXT("Offset to add to the center point"));
				MetaData->SetValue(NewProp_MinimumDistanceFromCenter, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_MinimumDistanceFromCenter, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetLockComponent.h"));
				MetaData->SetValue(NewProp_MinimumDistanceFromCenter, TEXT("ToolTip"), TEXT("The minimal distance the camera is away from the center point between character and target"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitTargetLockComponent(Z_Construct_UClass_UAdvKitTargetLockComponent, &UAdvKitTargetLockComponent::StaticClass, TEXT("UAdvKitTargetLockComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitTargetLockComponent);
	UFunction* Z_Construct_UFunction_AAdvKitTargetPoint_GetTargetedActor()
	{
		struct AdvKitTargetPoint_eventGetTargetedActor_Parms
		{
			AActor* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitTargetPoint();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetedActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AdvKitTargetPoint_eventGetTargetedActor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTargetPoint_eventGetTargetedActor_Parms), 0x0010000000000580, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetPoint.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the actor that is targeted by this point.\n@return The actual target of this point"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitTargetPoint_IsValidTarget()
	{
		struct AdvKitTargetPoint_eventIsValidTarget_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitTargetPoint();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsValidTarget"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AdvKitTargetPoint_eventIsValidTarget_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTargetPoint_eventIsValidTarget_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTargetPoint_eventIsValidTarget_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTargetPoint_eventIsValidTarget_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetPoint.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return True if this point is currently able to be targeted"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitTargetPoint_NoRegister()
	{
		return AAdvKitTargetPoint::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitTargetPoint()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ATargetPoint();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitTargetPoint::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitTargetPoint_GetTargetedActor());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitTargetPoint_IsValidTarget());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanBeTargeted, AAdvKitTargetPoint, bool);
				UProperty* NewProp_bCanBeTargeted = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanBeTargeted"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanBeTargeted, AAdvKitTargetPoint), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanBeTargeted, AAdvKitTargetPoint), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitTargetPoint_GetTargetedActor(), "GetTargetedActor"); // 2899403735
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitTargetPoint_IsValidTarget(), "IsValidTarget"); // 346584563
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitTargetPoint.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetPoint.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief This actor defines a point that can be targeted by characters or weapons."));
				MetaData->SetValue(NewProp_bCanBeTargeted, TEXT("Category"), TEXT("AdvKitTargetPoint"));
				MetaData->SetValue(NewProp_bCanBeTargeted, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTargetPoint.h"));
				MetaData->SetValue(NewProp_bCanBeTargeted, TEXT("ToolTip"), TEXT("True if the target point is currently active"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitTargetPoint(Z_Construct_UClass_AAdvKitTargetPoint, &AAdvKitTargetPoint::StaticClass, TEXT("AAdvKitTargetPoint"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitTargetPoint);
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms
		{
			FVector HalfSize;
			FRotator Orientation;
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoxTraceMultiBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			UProperty* NewProp_Orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Orientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Orientation, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfSize"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfSize, AdvKitTraceUtilityComponent_eventBoxTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiBoxTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a box along the given line and returns all hits encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param HalfSize           Distance from the center of box along each axis\n@param Orientation    Orientation of the box\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiForObjectsBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms
		{
			FVector HalfSize;
			FRotator Orientation;
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoxTraceMultiForObjectsBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			UProperty* NewProp_Orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Orientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Orientation, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfSize"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfSize, AdvKitTraceUtilityComponent_eventBoxTraceMultiForObjectsBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiBoxTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a box along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Orientation\n@param HalfSize               Radius of the sphere to sweep\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms
		{
			FVector HalfSize;
			FRotator Orientation;
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoxTraceSingleBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			UProperty* NewProp_Orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Orientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Orientation, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfSize"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfSize, AdvKitTraceUtilityComponent_eventBoxTraceSingleBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("BoxTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a box along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param HalfSize           Distance from the center of box along each axis\n@param Orientation    Orientation of the box\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleForObjectsBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms
		{
			FVector HalfSize;
			FRotator Orientation;
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoxTraceSingleForObjectsBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			UProperty* NewProp_Orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Orientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Orientation, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfSize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfSize"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfSize, AdvKitTraceUtilityComponent_eventBoxTraceSingleForObjectsBlueprint_Parms), 0x0010000000000082, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("BoxTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a box along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Orientation\n@param HalfSize               Radius of the sphere to sweep\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms
		{
			float Radius;
			float HalfHeight;
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CapsuleTraceMultiBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			UProperty* NewProp_HalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(HalfHeight, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000080);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiBlueprint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiCapsuleTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a capsule along the given line and returns all hits encountered up to and including the first blocking hit.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the capsule to sweep\n@param HalfHeight     Distance from center of capsule to tip of hemisphere endcap.\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiForObjects()
	{
		struct AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms
		{
			float Radius;
			float HalfHeight;
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CapsuleTraceMultiForObjects"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			UProperty* NewProp_HalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(HalfHeight, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000000000080);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventCapsuleTraceMultiForObjects_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Collision"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiCapsuleTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a capsule along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the capsule to sweep\n@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                              True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms
		{
			float Radius;
			float HalfHeight;
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CapsuleTraceSingleBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			UProperty* NewProp_HalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(HalfHeight, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000080);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleBlueprint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("CapsuleTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a capsule along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the capsule to sweep\n@param HalfHeight     Distance from center of capsule to tip of hemisphere endcap.\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleForObjectsBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms
		{
			float Radius;
			float HalfHeight;
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CapsuleTraceSingleForObjectsBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			UProperty* NewProp_HalfHeight = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(HalfHeight, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080);
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventCapsuleTraceSingleForObjectsBlueprint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("CapsuleTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a capsule along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the capsule to sweep\n@param HalfHeight     Distance from center of capsule to tip of hemisphere endcap.\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_DrawDebug()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DrawDebug"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Debug"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Draw a debug line to visualize the trace"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetEnd()
	{
		struct AdvKitTraceUtilityComponent_eventGetEnd_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEnd"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitTraceUtilityComponent_eventGetEnd_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTraceUtilityComponent_eventGetEnd_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the location of the trace end in world space\n@return Trace end location in world space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetStart()
	{
		struct AdvKitTraceUtilityComponent_eventGetStart_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStart"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitTraceUtilityComponent_eventGetStart_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTraceUtilityComponent_eventGetStart_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the location of the trace start in world space\n@return Trace start location in world space"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms
		{
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LineTraceMultiBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventLineTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiLineTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("raycast"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Does a collision trace along the given line and returns all hits encountered up to and including the first blocking hit.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param TraceChannel   The channel to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a blocking hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiForObjectsBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms
		{
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LineTraceMultiForObjectsBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventLineTraceMultiForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiLineTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("raycast"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Does a collision trace along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms
		{
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LineTraceSingleBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventLineTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("LineTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("raycast"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Does a collision trace along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleForObjectBlueprints()
	{
		struct AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms
		{
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LineTraceSingleForObjectBlueprints"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventLineTraceSingleForObjectBlueprints_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("LineTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("raycast"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Does a collision trace along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms
		{
			float Radius;
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SphereTraceMultiBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventSphereTraceMultiBlueprint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiSphereTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a sphere along the given line and returns all hits encountered up to and including the first blocking hit.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the sphere to sweep\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiForObjectsBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms
		{
			float Radius;
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			TArray<FHitResult> OutHits;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SphereTraceMultiForObjectsBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHits = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutHits, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010008000000180);
			UProperty* NewProp_OutHits_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHits, TEXT("OutHits"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventSphereTraceMultiForObjectsBlueprint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("MultiSphereTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a sphere along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the sphere to sweep\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleBlueprint()
	{
		struct AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms
		{
			float Radius;
			TEnumAsByte<ETraceTypeQuery> TraceChannel;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SphereTraceSingleBlueprint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), sizeof(bool), true);
			UProperty* NewProp_TraceChannel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TraceChannel"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TraceChannel, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_ETraceTypeQuery());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventSphereTraceSingleBlueprint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("SphereTraceByChannel"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a sphere along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the sphere to sweep\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleForObjectBlueprints()
	{
		struct AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms
		{
			float Radius;
			TArray<TEnumAsByte<EObjectTypeQuery> > ObjectTypes;
			bool bTraceComplex;
			TArray<AActor*> ActorsToIgnore;
			TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
			FHitResult OutHit;
			bool bIgnoreSelf;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTraceUtilityComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SphereTraceSingleForObjectBlueprints"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms, bool);
			UProperty* NewProp_bIgnoreSelf = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIgnoreSelf"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIgnoreSelf, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHit"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutHit, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_DrawDebugType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DrawDebugType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DrawDebugType, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000000000080, Z_Construct_UEnum_Engine_EDrawDebugTrace());
			UProperty* NewProp_ActorsToIgnore = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ActorsToIgnore, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000008000182);
			UProperty* NewProp_ActorsToIgnore_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ActorsToIgnore, TEXT("ActorsToIgnore"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms, bool);
			UProperty* NewProp_bTraceComplex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTraceComplex"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTraceComplex, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectTypes = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ObjectTypes, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000008000182);
			UProperty* NewProp_ObjectTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ObjectTypes, TEXT("ObjectTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_EObjectTypeQuery());
			UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, AdvKitTraceUtilityComponent_eventSphereTraceSingleForObjectBlueprints_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AutoCreateRefTerm"), TEXT("ActorsToIgnore"));
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Trace"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("SphereTraceForObjects"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("sweep"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sweeps a sphere along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the sphere to sweep\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a hit, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitTraceUtilityComponent_NoRegister()
	{
		return UAdvKitTraceUtilityComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitTraceUtilityComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitTraceUtilityComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiForObjectsBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleForObjectsBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiForObjects());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleForObjectsBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_DrawDebug());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetEnd());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetStart());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiForObjectsBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleForObjectBlueprints());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiForObjectsBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleBlueprint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleForObjectBlueprints());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DebugLineThickness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugLineThickness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DebugLineThickness, UAdvKitTraceUtilityComponent), 0x0020080000000005);
				UProperty* NewProp_DebugLineColor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugLineColor"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DebugLineColor, UAdvKitTraceUtilityComponent), 0x0020080000000005, Z_Construct_UScriptStruct_FColor());
				UProperty* NewProp_TraceLength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TraceLength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TraceLength, UAdvKitTraceUtilityComponent), 0x0020080000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiBlueprint(), "BoxTraceMultiBlueprint"); // 603680507
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceMultiForObjectsBlueprint(), "BoxTraceMultiForObjectsBlueprint"); // 2879375669
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleBlueprint(), "BoxTraceSingleBlueprint"); // 1109452022
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_BoxTraceSingleForObjectsBlueprint(), "BoxTraceSingleForObjectsBlueprint"); // 975044353
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiBlueprint(), "CapsuleTraceMultiBlueprint"); // 2609409259
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceMultiForObjects(), "CapsuleTraceMultiForObjects"); // 2027134285
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleBlueprint(), "CapsuleTraceSingleBlueprint"); // 2058389450
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_CapsuleTraceSingleForObjectsBlueprint(), "CapsuleTraceSingleForObjectsBlueprint"); // 2256233694
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_DrawDebug(), "DrawDebug"); // 268524850
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetEnd(), "GetEnd"); // 2601475852
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_GetStart(), "GetStart"); // 2814782239
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiBlueprint(), "LineTraceMultiBlueprint"); // 1856812933
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceMultiForObjectsBlueprint(), "LineTraceMultiForObjectsBlueprint"); // 21146586
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleBlueprint(), "LineTraceSingleBlueprint"); // 1623097304
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_LineTraceSingleForObjectBlueprints(), "LineTraceSingleForObjectBlueprints"); // 3364463442
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiBlueprint(), "SphereTraceMultiBlueprint"); // 1348072888
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceMultiForObjectsBlueprint(), "SphereTraceMultiForObjectsBlueprint"); // 1009716797
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleBlueprint(), "SphereTraceSingleBlueprint"); // 1294158909
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTraceUtilityComponent_SphereTraceSingleForObjectBlueprints(), "SphereTraceSingleForObjectBlueprints"); // 1324481450
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Utility"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility LOD Events Collision Physics Rendering Rendering | Material TextureStreaming Input Lighting Base Activation Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Player/AdvKitTraceUtilityComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief A Utility component to make traces with that are configurable from the editor.\n\nThis component will use it's transformation to do a trace along its X-Axis with the\nlength defined by its TraceLength property."));
				MetaData->SetValue(NewProp_DebugLineThickness, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_DebugLineThickness, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
				MetaData->SetValue(NewProp_DebugLineThickness, TEXT("ToolTip"), TEXT("Thickness when rendering the debug line for the trace"));
				MetaData->SetValue(NewProp_DebugLineColor, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_DebugLineColor, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
				MetaData->SetValue(NewProp_DebugLineColor, TEXT("ToolTip"), TEXT("Color when rendering the debug line for the trace"));
				MetaData->SetValue(NewProp_TraceLength, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_TraceLength, TEXT("ModuleRelativePath"), TEXT("Classes/Player/AdvKitTraceUtilityComponent.h"));
				MetaData->SetValue(NewProp_TraceLength, TEXT("ToolTip"), TEXT("Trace Length for this component"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitTraceUtilityComponent(Z_Construct_UClass_UAdvKitTraceUtilityComponent, &UAdvKitTraceUtilityComponent::StaticClass, TEXT("UAdvKitTraceUtilityComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitTraceUtilityComponent);
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CanCreateTransitionsFor()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanCreateTransitionsFor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535, sizeof(AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms), sizeof(bool), true);
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_ForCharacterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacterClass, AdvKitTransitionBuilderModule_eventCanCreateTransitionsFor_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if this module can create transitions for a given zone and character.\n@param       ForCharacterClass       Character to create transitions for.\n@param       ForZone         Zone to create transitions for.\n@return True if this module can create transitions for the given arguments."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionArea()
	{
		struct AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms
		{
			FString Id;
			AAdvKitZone* SourceZone;
			FVector MinWorldSourceLocation;
			FVector MinWorldTargetLocation;
			FVector MaxWorldSourceLocation;
			FVector MaxWorldTargetLocation;
			TSubclassOf<AAdvKitCharacter>  ForCharacter;
			TEnumAsByte<EAdvKitMovementMode> MovementMode;
			AAdvKitZone* TargetZone;
			uint8 CustomMovementMode;
			UAdvKitTransitionComponentArea* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateTransitionArea"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C80401, 65535, sizeof(AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitTransitionComponentArea_NoRegister());
			UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000000000080);
			UProperty* NewProp_TargetZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetZone, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementMode, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			UProperty* NewProp_ForCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacter, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_MaxWorldTargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxWorldTargetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxWorldTargetLocation, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MaxWorldSourceLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxWorldSourceLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxWorldSourceLocation, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MinWorldTargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MinWorldTargetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinWorldTargetLocation, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MinWorldSourceLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MinWorldSourceLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinWorldSourceLocation, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_SourceZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SourceZone, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UStrProperty(CPP_PROPERTY_BASE(Id, AdvKitTransitionBuilderModule_eventCreateTransitionArea_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_CustomMovementMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionBetween()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateTransitionBetween"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535, sizeof(AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms), sizeof(bool), true);
			UProperty* NewProp_TargetZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetZone, AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_SourceZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SourceZone, AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_ForCharacterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacterClass, AdvKitTransitionBuilderModule_eventCreateTransitionBetween_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates transitions between two given zones\n@param       ForCharacterClass       Character to create transitions for.\n@param       SourceZone      Zone to create transitions from.\n@param       TargetZone      Zone to create transitions to.\n@return      True if any transitions were created."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionPoint()
	{
		struct AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms
		{
			FString Id;
			AAdvKitZone* SourceZone;
			FVector WorldSourceLocation;
			FVector WorldTargetLocation;
			TSubclassOf<AAdvKitCharacter>  ForCharacter;
			TEnumAsByte<EAdvKitMovementMode> MovementMode;
			AAdvKitZone* TargetZone;
			uint8 CustomMovementMode;
			UAdvKitTransitionComponentPoint* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateTransitionPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C80401, 65535, sizeof(AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitTransitionComponentPoint_NoRegister());
			UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000000000080);
			UProperty* NewProp_TargetZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetZone, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementMode, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			UProperty* NewProp_ForCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacter, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_WorldTargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldTargetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldTargetLocation, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldSourceLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldSourceLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldSourceLocation, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_SourceZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SourceZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SourceZone, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UStrProperty(CPP_PROPERTY_BASE(Id, AdvKitTransitionBuilderModule_eventCreateTransitionPoint_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_CustomMovementMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitions()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateTransitions"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(AdvKitTransitionBuilderModule_eventCreateTransitions_Parms));
			UProperty* NewProp_OutAffectedZones = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutAffectedZones"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutAffectedZones, AdvKitTransitionBuilderModule_eventCreateTransitions_Parms), 0x0010000000000180);
			UProperty* NewProp_OutAffectedZones_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutAffectedZones, TEXT("OutAffectedZones"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Create transitions for zone\n@param[out]  OutAffectedZones        All zones that are targets of the created transitions"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionsFor()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateTransitionsFor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C080C00, 65535, sizeof(AdvKitTransitionBuilderModule_eventCreateTransitionsFor_Parms));
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitTransitionBuilderModule_eventCreateTransitionsFor_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_ForCharacterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacterClass, AdvKitTransitionBuilderModule_eventCreateTransitionsFor_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Create transitions for a given character and zone\n@param       ForCharacterClass       Character to create transitions for.\n@param       ForZone         Zone to create transitions for.\n@param[out]  OutAffectedZones        All zones that are targets of the created transitions"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GatherPotentialTargetZones()
	{
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GatherPotentialTargetZones"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C480C00, 65535, sizeof(AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms), sizeof(bool), true);
			UProperty* NewProp_OutZones = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutZones"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutZones, AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms), 0x0010000000000180);
			UProperty* NewProp_OutZones_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutZones, TEXT("OutZones"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_ForCharacterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacterClass, AdvKitTransitionBuilderModule_eventGatherPotentialTargetZones_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Queries all zones that might be potential targets for new transitions.\n@param       ForCharacterClass       Character to create transitions for.\n@param       ForZone         Zone to create transitions for.\n@param[out]  OutZones        All zones that are potential targets.\n@return      True if any potential targets were found, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterHalfExtent()
	{
		struct AdvKitTransitionBuilderModule_eventGetCharacterHalfExtent_Parms
		{
			TSubclassOf<AAdvKitCharacter>  ForCharacterClass;
			AAdvKitZone* ForZone;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCharacterHalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54880400, 65535, sizeof(AdvKitTransitionBuilderModule_eventGetCharacterHalfExtent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionBuilderModule_eventGetCharacterHalfExtent_Parms), 0x0010000000000582, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ForZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ForZone, AdvKitTransitionBuilderModule_eventGetCharacterHalfExtent_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_ForCharacterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacterClass, AdvKitTransitionBuilderModule_eventGetCharacterHalfExtent_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Utility method to query a character's size properties.\n@param       ForCharacterClass       Character to get size of.\n@param       ForZone         Zone to get character's size in.\n@return Half extent (Radius, Radius, Half Height) of character"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterMovementProperties_BP()
	{
		struct AdvKitTransitionBuilderModule_eventGetCharacterMovementProperties_BP_Parms
		{
			TSubclassOf<AAdvKitCharacter>  ForCharacterClass;
			FAdvKitMovementProperties ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCharacterMovementProperties_BP"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54080401, 65535, sizeof(AdvKitTransitionBuilderModule_eventGetCharacterMovementProperties_BP_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionBuilderModule_eventGetCharacterMovementProperties_BP_Parms), 0x0010000008000582, Z_Construct_UScriptStruct_FAdvKitMovementProperties());
			UProperty* NewProp_ForCharacterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacterClass, AdvKitTransitionBuilderModule_eventGetCharacterMovementProperties_BP_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetCharacterMovementProperties"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Utility method to get movement properties of a given character\n@param       ForCharacterClass       Character to get movement properties of.\n@return The character's movement properties."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetOuterZone()
	{
		struct AdvKitTransitionBuilderModule_eventGetOuterZone_Parms
		{
			AAdvKitZone* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOuterZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04080401, 65535, sizeof(AdvKitTransitionBuilderModule_eventGetOuterZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionBuilderModule_eventGetOuterZone_Parms), 0x0010000000000580, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return The zone this build module belongs to"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionBuilderModule_OverlapForCloseZones()
	{
		struct AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms
		{
			AAdvKitZone* ToZone;
			FVector OverlapStart;
			FVector OverlapEnd;
			float OverlapRadius;
			TArray<AAdvKitZone*> OutOtherZones;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionBuilderModule();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OverlapForCloseZones"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C80400, 65535, sizeof(AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), sizeof(bool), true);
			UProperty* NewProp_OutOtherZones = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutOtherZones"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OutOtherZones, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), 0x0010000000000180);
			UProperty* NewProp_OutOtherZones_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutOtherZones, TEXT("OutOtherZones"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_OverlapRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverlapRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(OverlapRadius, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), 0x0010000000000080);
			UProperty* NewProp_OverlapEnd = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverlapEnd"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OverlapEnd, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OverlapStart = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverlapStart"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OverlapStart, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ToZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ToZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ToZone, AdvKitTransitionBuilderModule_eventOverlapForCloseZones_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Does an overlap check to find all zones within it.\n@param       ToZone  The origin zone to find overlaps for.\n@param       OverlapStart    Start of the overlap.\n@param       OverlapEnd              End of the overlap.\n@param       OverlapRadius   Radius of the overlap.\n@param[out]  OutOtherZones   All zones that were overlapped.\n@return True if any zones were overlapped, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitTransitionBuilderModule_NoRegister()
	{
		return UAdvKitTransitionBuilderModule::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitTransitionBuilderModule()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitTransitionBuilderModule::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903081;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CanCreateTransitionsFor());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionArea());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionBetween());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitions());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionsFor());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GatherPotentialTargetZones());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterHalfExtent());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterMovementProperties_BP());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetOuterZone());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_OverlapForCloseZones());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DefaultCharacterClasses = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultCharacterClasses"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(DefaultCharacterClasses, UAdvKitTransitionBuilderModule), 0x0014000000000005);
				UProperty* NewProp_DefaultCharacterClasses_Inner = new(EC_InternalUseOnlyConstructor, NewProp_DefaultCharacterClasses, TEXT("DefaultCharacterClasses"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_CreatedOrUpdatedTransitions = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CreatedOrUpdatedTransitions"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(CreatedOrUpdatedTransitions, UAdvKitTransitionBuilderModule), 0x002008800000000c);
				UProperty* NewProp_CreatedOrUpdatedTransitions_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CreatedOrUpdatedTransitions, TEXT("CreatedOrUpdatedTransitions"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000080008, Z_Construct_UClass_UAdvKitTransitionComponent_NoRegister());
				UProperty* NewProp_AffectedZones = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AffectedZones"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(AffectedZones, UAdvKitTransitionBuilderModule), 0x0020080000000004);
				UProperty* NewProp_AffectedZones_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AffectedZones, TEXT("AffectedZones"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AAdvKitZone_NoRegister());
				UProperty* NewProp_ErrorMarginDot = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ErrorMarginDot"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ErrorMarginDot, UAdvKitTransitionBuilderModule), 0x0020080000000015);
				UProperty* NewProp_ErrorMarginPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ErrorMarginPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ErrorMarginPosition, UAdvKitTransitionBuilderModule), 0x0020080000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CanCreateTransitionsFor(), "CanCreateTransitionsFor"); // 3621262461
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionArea(), "CreateTransitionArea"); // 3875414628
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionBetween(), "CreateTransitionBetween"); // 550491045
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionPoint(), "CreateTransitionPoint"); // 2438577147
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitions(), "CreateTransitions"); // 381823108
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_CreateTransitionsFor(), "CreateTransitionsFor"); // 4178791954
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GatherPotentialTargetZones(), "GatherPotentialTargetZones"); // 1695124360
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterHalfExtent(), "GetCharacterHalfExtent"); // 3114149108
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetCharacterMovementProperties_BP(), "GetCharacterMovementProperties_BP"); // 3483465013
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_GetOuterZone(), "GetOuterZone"); // 702804059
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionBuilderModule_OverlapForCloseZones(), "OverlapForCloseZones"); // 1647100157
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class for modules that create transition. A module takes care of creating transitions for\nspecific types of zones."));
				MetaData->SetValue(NewProp_DefaultCharacterClasses, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_DefaultCharacterClasses, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(NewProp_DefaultCharacterClasses, TEXT("ToolTip"), TEXT("For which character classes this builder should create transitions."));
				MetaData->SetValue(NewProp_CreatedOrUpdatedTransitions, TEXT("Category"), TEXT("AdvKitTransitionBuilderModule"));
				MetaData->SetValue(NewProp_CreatedOrUpdatedTransitions, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CreatedOrUpdatedTransitions, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(NewProp_CreatedOrUpdatedTransitions, TEXT("ToolTip"), TEXT("During the build process this is used to keep track transitions that where created or updated"));
				MetaData->SetValue(NewProp_AffectedZones, TEXT("Category"), TEXT("AdvKitTransitionBuilderModule"));
				MetaData->SetValue(NewProp_AffectedZones, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(NewProp_AffectedZones, TEXT("ToolTip"), TEXT("During the build process this is used to keep track of zones that transitions where created to or removed from"));
				MetaData->SetValue(NewProp_ErrorMarginDot, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_ErrorMarginDot, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(NewProp_ErrorMarginDot, TEXT("ToolTip"), TEXT("When checking if two directions align, this is the maximum variance of their dot product to be considered equal."));
				MetaData->SetValue(NewProp_ErrorMarginPosition, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_ErrorMarginPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionBuilderModule.h"));
				MetaData->SetValue(NewProp_ErrorMarginPosition, TEXT("ToolTip"), TEXT("When checking if two positions align, this is the maximum variance for positions to be considered equal."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitTransitionBuilderModule(Z_Construct_UClass_UAdvKitTransitionBuilderModule, &UAdvKitTransitionBuilderModule::StaticClass, TEXT("UAdvKitTransitionBuilderModule"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitTransitionBuilderModule);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Balance_NoRegister()
	{
		return UAdvKitBuildModule_Balance::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Balance()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Balance::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateEndTransition, UAdvKitBuildModule_Balance, bool);
				UProperty* NewProp_bCreateEndTransition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateEndTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateEndTransition, UAdvKitBuildModule_Balance), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateEndTransition, UAdvKitBuildModule_Balance), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateStartTransition, UAdvKitBuildModule_Balance, bool);
				UProperty* NewProp_bCreateStartTransition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateStartTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateStartTransition, UAdvKitBuildModule_Balance), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateStartTransition, UAdvKitBuildModule_Balance), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Balance Enter and Exit"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Balance.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Balance.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions for balance zones"));
				MetaData->SetValue(NewProp_bCreateEndTransition, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateEndTransition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Balance.h"));
				MetaData->SetValue(NewProp_bCreateEndTransition, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition at the end point"));
				MetaData->SetValue(NewProp_bCreateStartTransition, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateStartTransition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Balance.h"));
				MetaData->SetValue(NewProp_bCreateStartTransition, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition at the start point"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Balance(Z_Construct_UClass_UAdvKitBuildModule_Balance, &UAdvKitBuildModule_Balance::StaticClass, TEXT("UAdvKitBuildModule_Balance"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Balance);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ladder_NoRegister()
	{
		return UAdvKitBuildModule_Ladder::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ladder()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Ladder::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateTransitionToFloor, UAdvKitBuildModule_Ladder, bool);
				UProperty* NewProp_bCreateTransitionToFloor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateTransitionToFloor"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateTransitionToFloor, UAdvKitBuildModule_Ladder), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateTransitionToFloor, UAdvKitBuildModule_Ladder), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateTransitionToPlatform, UAdvKitBuildModule_Ladder, bool);
				UProperty* NewProp_bCreateTransitionToPlatform = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateTransitionToPlatform"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateTransitionToPlatform, UAdvKitBuildModule_Ladder), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateTransitionToPlatform, UAdvKitBuildModule_Ladder), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSidewaysTransitionRequiresJump, UAdvKitBuildModule_Ladder, bool);
				UProperty* NewProp_bSidewaysTransitionRequiresJump = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSidewaysTransitionRequiresJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSidewaysTransitionRequiresJump, UAdvKitBuildModule_Ladder), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bSidewaysTransitionRequiresJump, UAdvKitBuildModule_Ladder), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Ladder Enter and Exit"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Ladder.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ladder.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions for ladder zones"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ladder.h"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition at bottom of the ladder"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ladder.h"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition at the top of the ladder"));
				MetaData->SetValue(NewProp_bSidewaysTransitionRequiresJump, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bSidewaysTransitionRequiresJump, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ladder.h"));
				MetaData->SetValue(NewProp_bSidewaysTransitionRequiresJump, TEXT("ToolTip"), TEXT("Whether or not transitions to the side require jumps"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Ladder(Z_Construct_UClass_UAdvKitBuildModule_Ladder, &UAdvKitBuildModule_Ladder::StaticClass, TEXT("UAdvKitBuildModule_Ladder"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Ladder);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_NoRegister()
	{
		return UAdvKitBuildModule_Ledge::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Ledge::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_FloorTraceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FloorTraceDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FloorTraceDistance, UAdvKitBuildModule_Ledge), 0x0020080000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateTransitionToFloor, UAdvKitBuildModule_Ledge, bool);
				UProperty* NewProp_bCreateTransitionToFloor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateTransitionToFloor"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateTransitionToFloor, UAdvKitBuildModule_Ledge), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateTransitionToFloor, UAdvKitBuildModule_Ledge), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateTransitionToPlatform, UAdvKitBuildModule_Ledge, bool);
				UProperty* NewProp_bCreateTransitionToPlatform = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateTransitionToPlatform"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateTransitionToPlatform, UAdvKitBuildModule_Ledge), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateTransitionToPlatform, UAdvKitBuildModule_Ledge), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSidewaysTransitionRequiresJump, UAdvKitBuildModule_Ledge, bool);
				UProperty* NewProp_bSidewaysTransitionRequiresJump = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSidewaysTransitionRequiresJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSidewaysTransitionRequiresJump, UAdvKitBuildModule_Ledge), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bSidewaysTransitionRequiresJump, UAdvKitBuildModule_Ledge), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Ledge Enter, Exit,  Corners and Jumps"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Ledge.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions for ledge zones"));
				MetaData->SetValue(NewProp_FloorTraceDistance, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_FloorTraceDistance, TEXT("EditCondition"), TEXT("bCreateTransitionToFloor"));
				MetaData->SetValue(NewProp_FloorTraceDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge.h"));
				MetaData->SetValue(NewProp_FloorTraceDistance, TEXT("ToolTip"), TEXT("The maximum trace distance down to find the floor when creating an exit transition"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge.h"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition to the floor below the ledge"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge.h"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition to the platform above the ledge"));
				MetaData->SetValue(NewProp_bSidewaysTransitionRequiresJump, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bSidewaysTransitionRequiresJump, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge.h"));
				MetaData->SetValue(NewProp_bSidewaysTransitionRequiresJump, TEXT("ToolTip"), TEXT("Whether or not transitions to the side require jumps"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Ledge(Z_Construct_UClass_UAdvKitBuildModule_Ledge, &UAdvKitBuildModule_Ledge::StaticClass, TEXT("UAdvKitBuildModule_Ledge"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Ledge);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Ladder_NoRegister()
	{
		return UAdvKitBuildModule_Ledge_Ladder::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Ladder()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Ledge_Ladder::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LadderZOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LadderZOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LadderZOffset, UAdvKitBuildModule_Ledge_Ladder), 0x0010000000000001);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Jumps between Ledge and Ladder"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Ledge_Ladder.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge_Ladder.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions between ledge and ladder zones"));
				MetaData->SetValue(NewProp_LadderZOffset, TEXT("Category"), TEXT("AdvKitBuildModule_Ledge_Ladder"));
				MetaData->SetValue(NewProp_LadderZOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge_Ladder.h"));
				MetaData->SetValue(NewProp_LadderZOffset, TEXT("ToolTip"), TEXT("An offset to add when finding the closest location on the ladder"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Ledge_Ladder(Z_Construct_UClass_UAdvKitBuildModule_Ledge_Ladder, &UAdvKitBuildModule_Ledge_Ladder::StaticClass, TEXT("UAdvKitBuildModule_Ledge_Ladder"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Ledge_Ladder);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Tightspace_NoRegister()
	{
		return UAdvKitBuildModule_Ledge_Tightspace::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Ledge_Tightspace()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Ledge_Tightspace::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Transitions between Ledge and Tight Space"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Ledge_Tightspace.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Ledge_Tightspace.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions between ledge and tight space zones"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Ledge_Tightspace(Z_Construct_UClass_UAdvKitBuildModule_Ledge_Tightspace, &UAdvKitBuildModule_Ledge_Tightspace::StaticClass, TEXT("UAdvKitBuildModule_Ledge_Tightspace"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Ledge_Tightspace);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Tightspace_NoRegister()
	{
		return UAdvKitBuildModule_Tightspace::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Tightspace()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Tightspace::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateEndTransition, UAdvKitBuildModule_Tightspace, bool);
				UProperty* NewProp_bCreateEndTransition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateEndTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateEndTransition, UAdvKitBuildModule_Tightspace), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateEndTransition, UAdvKitBuildModule_Tightspace), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateStartTransition, UAdvKitBuildModule_Tightspace, bool);
				UProperty* NewProp_bCreateStartTransition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateStartTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateStartTransition, UAdvKitBuildModule_Tightspace), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateStartTransition, UAdvKitBuildModule_Tightspace), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Tight Space Enter and Exit"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Tightspace.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Tightspace.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions for tight space zones"));
				MetaData->SetValue(NewProp_bCreateEndTransition, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateEndTransition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Tightspace.h"));
				MetaData->SetValue(NewProp_bCreateEndTransition, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition at the end point"));
				MetaData->SetValue(NewProp_bCreateStartTransition, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateStartTransition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Tightspace.h"));
				MetaData->SetValue(NewProp_bCreateStartTransition, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition at the start point"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Tightspace(Z_Construct_UClass_UAdvKitBuildModule_Tightspace, &UAdvKitBuildModule_Tightspace::StaticClass, TEXT("UAdvKitBuildModule_Tightspace"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Tightspace);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall_NoRegister()
	{
		return UAdvKitBuildModule_Wall::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Wall::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateTransitionToFloor, UAdvKitBuildModule_Wall, bool);
				UProperty* NewProp_bCreateTransitionToFloor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateTransitionToFloor"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateTransitionToFloor, UAdvKitBuildModule_Wall), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateTransitionToFloor, UAdvKitBuildModule_Wall), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateTransitionToPlatform, UAdvKitBuildModule_Wall, bool);
				UProperty* NewProp_bCreateTransitionToPlatform = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCreateTransitionToPlatform"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateTransitionToPlatform, UAdvKitBuildModule_Wall), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCreateTransitionToPlatform, UAdvKitBuildModule_Wall), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Wall Enter, Exit and Corners"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Wall.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Wall.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions for wall zones"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Wall.h"));
				MetaData->SetValue(NewProp_bCreateTransitionToFloor, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition to the floor below the wall"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Wall.h"));
				MetaData->SetValue(NewProp_bCreateTransitionToPlatform, TEXT("ToolTip"), TEXT("Whether or not to create an exit transition to the platform above the wall"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Wall(Z_Construct_UClass_UAdvKitBuildModule_Wall, &UAdvKitBuildModule_Wall::StaticClass, TEXT("UAdvKitBuildModule_Wall"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Wall);
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall_Ceiling_NoRegister()
	{
		return UAdvKitBuildModule_Wall_Ceiling::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitBuildModule_Wall_Ceiling()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionBuilderModule();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitBuildModule_Wall_Ceiling::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20903080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Transitions between Wall and Ceiling"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/BuildModules/AdvKitBuildModule_Wall_Ceiling.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/BuildModules/AdvKitBuildModule_Wall_Ceiling.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a transition builder module to create transitions between wall and ceiling zones"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitBuildModule_Wall_Ceiling(Z_Construct_UClass_UAdvKitBuildModule_Wall_Ceiling, &UAdvKitBuildModule_Wall_Ceiling::StaticClass, TEXT("UAdvKitBuildModule_Wall_Ceiling"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitBuildModule_Wall_Ceiling);
	UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_CanTransition()
	{
		struct AdvKitTransitionComponent_eventCanTransition_Parms
		{
			AAdvKitCharacter* Character;
			FVector AtLocation;
			FVector InDirection;
			bool bIsJump;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitTransitionComponent_eventCanTransition_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTransitionComponent_eventCanTransition_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTransitionComponent_eventCanTransition_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTransitionComponent_eventCanTransition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsJump, AdvKitTransitionComponent_eventCanTransition_Parms, bool);
			UProperty* NewProp_bIsJump = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsJump, AdvKitTransitionComponent_eventCanTransition_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsJump, AdvKitTransitionComponent_eventCanTransition_Parms), sizeof(bool), true);
			UProperty* NewProp_InDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InDirection, AdvKitTransitionComponent_eventCanTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AtLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AtLocation, AdvKitTransitionComponent_eventCanTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Character = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Character"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Character, AdvKitTransitionComponent_eventCanTransition_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Transition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the transition can be used.\n@param       Character       Character that wants to transition\n@param       AtLocation      World location from where to start the transition if possible\n@param       InDirection     Direction in world space where to transition to\n@param       bIsJump Whether or not the transition is done with a jump\n@return True if transition can be used."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestSourcePosition()
	{
		struct AdvKitTransitionComponent_eventGetClosestSourcePosition_Parms
		{
			FVector ToWorldPosition;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetClosestSourcePosition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitTransitionComponent_eventGetClosestSourcePosition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionComponent_eventGetClosestSourcePosition_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ToWorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ToWorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ToWorldPosition, AdvKitTransitionComponent_eventGetClosestSourcePosition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Transition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query to get the closest location where a transition can start in relation to another location.\n@param       ToWorldPosition         Location in world space to find reference point to.\n@return Closest location in world space to start the transition."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestTargetPosition()
	{
		struct AdvKitTransitionComponent_eventGetClosestTargetPosition_Parms
		{
			FVector ToWorldPosition;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetClosestTargetPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitTransitionComponent_eventGetClosestTargetPosition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitTransitionComponent_eventGetClosestTargetPosition_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ToWorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ToWorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ToWorldPosition, AdvKitTransitionComponent_eventGetClosestTargetPosition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Transition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Query to get the closest location where a transition will end in relation to another location.\n@param       ToWorldPosition         Location in world space to find reference point to.\n@return Closest location in world space to end the transition."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitTransitionComponent_IsDynamicTransitionValid()
	{
		struct AdvKitTransitionComponent_eventIsDynamicTransitionValid_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitTransitionComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsDynamicTransitionValid"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitTransitionComponent_eventIsDynamicTransitionValid_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitTransitionComponent_eventIsDynamicTransitionValid_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitTransitionComponent_eventIsDynamicTransitionValid_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitTransitionComponent_eventIsDynamicTransitionValid_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Transition"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Dynamic transitions can be invalid (e.g. a transition point is too far off) and not be\nused during this time (think moving platforms).\n@return True if the dynamic transition can be used."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitTransitionComponent_NoRegister()
	{
		return UAdvKitTransitionComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitTransitionComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitTransitionComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00081;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionComponent_CanTransition());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestSourcePosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestTargetPosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitTransitionComponent_IsDynamicTransitionValid());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TargetCustomPhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetCustomPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TargetCustomPhysics, UAdvKitTransitionComponent), 0x0010000000000015);
				UProperty* NewProp_TargetPhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TargetPhysics, UAdvKitTransitionComponent), 0x0010000000000015, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
				UProperty* NewProp_TargetZone = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UWeakObjectProperty(CPP_PROPERTY_BASE(TargetZone, UAdvKitTransitionComponent), 0x0014000000020015, Z_Construct_UClass_AAdvKitZone_NoRegister());
				UProperty* NewProp_UseableBy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UseableBy"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(UseableBy, UAdvKitTransitionComponent), 0x0014000000000805, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_MinLocationRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinLocationRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinLocationRadius, UAdvKitTransitionComponent), 0x0010000000000005);
				UProperty* NewProp_MinDirectionNormal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinDirectionNormal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinDirectionNormal, UAdvKitTransitionComponent), 0x0010000000000005);
				UProperty* NewProp_TransitionDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TransitionDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TransitionDirection, UAdvKitTransitionComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bNeedsJump, UAdvKitTransitionComponent, uint8);
				UProperty* NewProp_bNeedsJump = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bNeedsJump"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bNeedsJump, UAdvKitTransitionComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bNeedsJump, UAdvKitTransitionComponent), sizeof(uint8), false);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDynamicTransitionActive, UAdvKitTransitionComponent, bool);
				UProperty* NewProp_bDynamicTransitionActive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDynamicTransitionActive"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDynamicTransitionActive, UAdvKitTransitionComponent), 0x0010000200000005, CPP_BOOL_PROPERTY_BITMASK(bDynamicTransitionActive, UAdvKitTransitionComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsDynamic, UAdvKitTransitionComponent, bool);
				UProperty* NewProp_bIsDynamic = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsDynamic"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsDynamic, UAdvKitTransitionComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsDynamic, UAdvKitTransitionComponent), sizeof(bool), true);
				UProperty* NewProp_TransitionId = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TransitionId"), RF_Public|RF_Transient|RF_MarkAsNative) UStrProperty(CPP_PROPERTY_BASE(TransitionId, UAdvKitTransitionComponent), 0x0010000000000000);
				UProperty* NewProp_CreatedByBuildModule = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CreatedByBuildModule"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CreatedByBuildModule, UAdvKitTransitionComponent), 0x0010000000000000, Z_Construct_UClass_UAdvKitTransitionBuilderModule_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionComponent_CanTransition(), "CanTransition"); // 2999187668
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestSourcePosition(), "GetClosestSourcePosition"); // 1442616599
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionComponent_GetClosestTargetPosition(), "GetClosestTargetPosition"); // 525845704
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitTransitionComponent_IsDynamicTransitionValid(), "IsDynamicTransitionValid"); // 2775749940
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Component Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class for transitions between zones."));
				MetaData->SetValue(NewProp_TargetCustomPhysics, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_TargetCustomPhysics, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_TargetCustomPhysics, TEXT("ToolTip"), TEXT("Custom movement mode the character will have after this transition"));
				MetaData->SetValue(NewProp_TargetPhysics, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_TargetPhysics, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_TargetPhysics, TEXT("ToolTip"), TEXT("Movement mode the character will have after this transition"));
				MetaData->SetValue(NewProp_TargetZone, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_TargetZone, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_TargetZone, TEXT("ToolTip"), TEXT("DuplicateTransient,"));
				MetaData->SetValue(NewProp_UseableBy, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_UseableBy, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_UseableBy, TEXT("ToolTip"), TEXT("Which kind of character can use the transition"));
				MetaData->SetValue(NewProp_MinLocationRadius, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MinLocationRadius, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_MinLocationRadius, TEXT("ToolTip"), TEXT("Character's location offset from the transition can differ this much from the closest transition source."));
				MetaData->SetValue(NewProp_MinDirectionNormal, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MinDirectionNormal, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_MinDirectionNormal, TEXT("ToolTip"), TEXT("Character's direction can differ this much from the required direction."));
				MetaData->SetValue(NewProp_TransitionDirection, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_TransitionDirection, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_TransitionDirection, TEXT("ToolTip"), TEXT("Character needs to go this direction"));
				MetaData->SetValue(NewProp_bNeedsJump, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_bNeedsJump, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_bNeedsJump, TEXT("ToolTip"), TEXT("Character needs to jump"));
				MetaData->SetValue(NewProp_bDynamicTransitionActive, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_bDynamicTransitionActive, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_bDynamicTransitionActive, TEXT("ToolTip"), TEXT("Flag that indicates this transition is dynamic."));
				MetaData->SetValue(NewProp_bIsDynamic, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_bIsDynamic, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_bIsDynamic, TEXT("ToolTip"), TEXT("Flag that indicates this transition is dynamic."));
				MetaData->SetValue(NewProp_TransitionId, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_TransitionId, TEXT("ToolTip"), TEXT("Identifier given by the build module responsible for creating this transitions, used to update"));
				MetaData->SetValue(NewProp_CreatedByBuildModule, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitTransitionComponent.h"));
				MetaData->SetValue(NewProp_CreatedByBuildModule, TEXT("ToolTip"), TEXT("Class of build module responsible for creating this transitions, used to update"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitTransitionComponent(Z_Construct_UClass_UAdvKitTransitionComponent, &UAdvKitTransitionComponent::StaticClass, TEXT("UAdvKitTransitionComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitTransitionComponent);
	UClass* Z_Construct_UClass_UAdvKitTransitionComponentArea_NoRegister()
	{
		return UAdvKitTransitionComponentArea::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitTransitionComponentArea()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitTransitionComponentArea::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_MaxTargetPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxTargetPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxTargetPosition, UAdvKitTransitionComponentArea), 0x0020080000000014, Z_Construct_UScriptStruct_FBasedPosition());
				UProperty* NewProp_MaxSourcePosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxSourcePosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxSourcePosition, UAdvKitTransitionComponentArea), 0x0020080000000014, Z_Construct_UScriptStruct_FBasedPosition());
				UProperty* NewProp_MinTargetPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinTargetPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinTargetPosition, UAdvKitTransitionComponentArea), 0x0020080000000014, Z_Construct_UScriptStruct_FBasedPosition());
				UProperty* NewProp_MinSourcePosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinSourcePosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinSourcePosition, UAdvKitTransitionComponentArea), 0x0020080000000014, Z_Construct_UScriptStruct_FBasedPosition());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Component Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/Transitions/AdvKitTransitionComponentArea.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentArea.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Transition that is an area between two defined lines on the source and target zone."));
				MetaData->SetValue(NewProp_MaxTargetPosition, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MaxTargetPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentArea.h"));
				MetaData->SetValue(NewProp_MaxTargetPosition, TEXT("ToolTip"), TEXT("Right end of the transition (inside of the target zone)"));
				MetaData->SetValue(NewProp_MaxSourcePosition, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MaxSourcePosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentArea.h"));
				MetaData->SetValue(NewProp_MaxSourcePosition, TEXT("ToolTip"), TEXT("Right start of the transition (inside the source zone)"));
				MetaData->SetValue(NewProp_MinTargetPosition, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MinTargetPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentArea.h"));
				MetaData->SetValue(NewProp_MinTargetPosition, TEXT("ToolTip"), TEXT("Left end of the transition line (inside of the target zone)"));
				MetaData->SetValue(NewProp_MinSourcePosition, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_MinSourcePosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentArea.h"));
				MetaData->SetValue(NewProp_MinSourcePosition, TEXT("ToolTip"), TEXT("Left start of the transition line(inside the source zone)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitTransitionComponentArea(Z_Construct_UClass_UAdvKitTransitionComponentArea, &UAdvKitTransitionComponentArea::StaticClass, TEXT("UAdvKitTransitionComponentArea"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitTransitionComponentArea);
	UClass* Z_Construct_UClass_UAdvKitTransitionComponentPoint_NoRegister()
	{
		return UAdvKitTransitionComponentPoint::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitTransitionComponentPoint()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAdvKitTransitionComponent();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitTransitionComponentPoint::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SourcePosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SourcePosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SourcePosition, UAdvKitTransitionComponentPoint), 0x0010000000000014, Z_Construct_UScriptStruct_FBasedPosition());
				UProperty* NewProp_TargetPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TargetPosition, UAdvKitTransitionComponentPoint), 0x0010000000000014, Z_Construct_UScriptStruct_FBasedPosition());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Component Activation ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/Transitions/AdvKitTransitionComponentPoint.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentPoint.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Transition that is a straight line defined by a start and end point."));
				MetaData->SetValue(NewProp_SourcePosition, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_SourcePosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentPoint.h"));
				MetaData->SetValue(NewProp_SourcePosition, TEXT("ToolTip"), TEXT("Based position on the start zone"));
				MetaData->SetValue(NewProp_TargetPosition, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_TargetPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Transitions/AdvKitTransitionComponentPoint.h"));
				MetaData->SetValue(NewProp_TargetPosition, TEXT("ToolTip"), TEXT("Based position on the target zone"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitTransitionComponentPoint(Z_Construct_UClass_UAdvKitTransitionComponentPoint, &UAdvKitTransitionComponentPoint::StaticClass, TEXT("UAdvKitTransitionComponentPoint"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitTransitionComponentPoint);
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_UsedBySignature__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventUsedBySignature_Parms
		{
			AAdvKitCharacter* ByCharacter;
			AAdvKitInventoryItem* WithItem;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UsedBySignature__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventUsedBySignature_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, _Script_AdvKitRuntime_eventUsedBySignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_ByCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ByCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ByCharacter, _Script_AdvKitRuntime_eventUsedBySignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsable.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitUsable_CanBeUsedBy()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitUsable();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanBeUsedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitUsable_eventCanBeUsedBy_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitUsable_eventCanBeUsedBy_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitUsable_eventCanBeUsedBy_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitUsable_eventCanBeUsedBy_Parms), sizeof(bool), true);
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, AdvKitUsable_eventCanBeUsedBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_Character = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Character"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Character, AdvKitUsable_eventCanBeUsedBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsable.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called before UsedBy to check whether or not a character can use this object.\n\n@param       Character       The using character.\n@param       WithItem        Optional item the character used with this object (e.g. a key).\n@return      true if usable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitUsable_UsedBy()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitUsable();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UsedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitUsable_eventUsedBy_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, AdvKitUsable_eventUsedBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_Character = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Character"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Character, AdvKitUsable_eventUsedBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsable.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when a character uses this object.\n\n@param       Character       The using character.\n@param       WithItem        Optional item the character used with this object (e.g. a key)."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitUsable_NoRegister()
	{
		return AAdvKitUsable::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitUsable()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitUsable::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitUsable_CanBeUsedBy());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitUsable_UsedBy());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnUsedBy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnUsedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnUsedBy, AAdvKitUsable), 0x0010100010080000, Z_Construct_UDelegateFunction_AdvKitRuntime_UsedBySignature__DelegateSignature());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitUsable_CanBeUsedBy(), "CanBeUsedBy"); // 78853877
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitUsable_UsedBy(), "UsedBy"); // 1121711759
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitUsable.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsable.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class for all sorts of usable scene actors (like levers or buttons)."));
				MetaData->SetValue(NewProp_OnUsedBy, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_OnUsedBy, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsable.h"));
				MetaData->SetValue(NewProp_OnUsedBy, TEXT("ToolTip"), TEXT("Delegate that is called when this actor was used."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitUsable(Z_Construct_UClass_AAdvKitUsable, &AAdvKitUsable::StaticClass, TEXT("AAdvKitUsable"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitUsable);
	UFunction* Z_Construct_UFunction_AAdvKitPickup_CanBePickedUpBy()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitPickup();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanBePickedUpBy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitPickup_eventCanBePickedUpBy_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitPickup_eventCanBePickedUpBy_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitPickup_eventCanBePickedUpBy_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitPickup_eventCanBePickedUpBy_Parms), sizeof(bool), true);
			UProperty* NewProp_Character = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Character"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Character, AdvKitPickup_eventCanBePickedUpBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can a character pick this pickup up? (what a question indeed...)\n\n@param       Character       The character that wants to pick up this object.\n@return                              True if character can pick up the object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitPickup_PickedUpBy()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitPickup();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PickedUpBy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08080C00, 65535, sizeof(AdvKitPickup_eventPickedUpBy_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, AdvKitPickup_eventPickedUpBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_Character = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Character"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Character, AdvKitPickup_eventPickedUpBy_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("BlueprintProtected"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Picked up by a character (should only be called when CanBePickedUpBy returns true)\n\n@param       Character       The character that picked up this object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitPickup_Respawn()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitPickup();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Respawn"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called by a timer after RespawnTime"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitPickup_NoRegister()
	{
		return AAdvKitPickup::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitPickup()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitUsable();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitPickup::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitPickup_CanBePickedUpBy());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitPickup_PickedUpBy());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitPickup_Respawn());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanBePickedUpWithUse, AAdvKitPickup, bool);
				UProperty* NewProp_bCanBePickedUpWithUse = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanBePickedUpWithUse"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanBePickedUpWithUse, AAdvKitPickup), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCanBePickedUpWithUse, AAdvKitPickup), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bActive, AAdvKitPickup, bool);
				UProperty* NewProp_bActive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bActive"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bActive, AAdvKitPickup), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bActive, AAdvKitPickup), sizeof(bool), true);
				UProperty* NewProp_RespawnTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RespawnTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RespawnTime, AAdvKitPickup), 0x0020080000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bRespawnAfterPickup, AAdvKitPickup, bool);
				UProperty* NewProp_bRespawnAfterPickup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bRespawnAfterPickup"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bRespawnAfterPickup, AAdvKitPickup), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bRespawnAfterPickup, AAdvKitPickup), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDestroyOnPickup, AAdvKitPickup, bool);
				UProperty* NewProp_bDestroyOnPickup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDestroyOnPickup"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDestroyOnPickup, AAdvKitPickup), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bDestroyOnPickup, AAdvKitPickup), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitPickup_CanBePickedUpBy(), "CanBePickedUpBy"); // 216057051
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitPickup_PickedUpBy(), "PickedUpBy"); // 1354081000
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitPickup_Respawn(), "Respawn"); // 577843420
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitPickup.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Pickup objects can act when the player overlaps them or uses them."));
				MetaData->SetValue(NewProp_bCanBePickedUpWithUse, TEXT("Category"), TEXT("Pickup"));
				MetaData->SetValue(NewProp_bCanBePickedUpWithUse, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
				MetaData->SetValue(NewProp_bCanBePickedUpWithUse, TEXT("ToolTip"), TEXT("Can this be picked up with the UsedBy function?"));
				MetaData->SetValue(NewProp_bActive, TEXT("Category"), TEXT("Pickup"));
				MetaData->SetValue(NewProp_bActive, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
				MetaData->SetValue(NewProp_bActive, TEXT("ToolTip"), TEXT("Whether this pickup is currently active (and visible etc...)."));
				MetaData->SetValue(NewProp_RespawnTime, TEXT("Category"), TEXT("Pickup"));
				MetaData->SetValue(NewProp_RespawnTime, TEXT("EditCondition"), TEXT("bRespawnAfterPickup"));
				MetaData->SetValue(NewProp_RespawnTime, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
				MetaData->SetValue(NewProp_RespawnTime, TEXT("ToolTip"), TEXT("How long to wait until respawning."));
				MetaData->SetValue(NewProp_bRespawnAfterPickup, TEXT("Category"), TEXT("Pickup"));
				MetaData->SetValue(NewProp_bRespawnAfterPickup, TEXT("EditCondition"), TEXT("!bDestroyOnPickup"));
				MetaData->SetValue(NewProp_bRespawnAfterPickup, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
				MetaData->SetValue(NewProp_bRespawnAfterPickup, TEXT("ToolTip"), TEXT("Respawn after being picked up."));
				MetaData->SetValue(NewProp_bDestroyOnPickup, TEXT("Category"), TEXT("Pickup"));
				MetaData->SetValue(NewProp_bDestroyOnPickup, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitPickup.h"));
				MetaData->SetValue(NewProp_bDestroyOnPickup, TEXT("ToolTip"), TEXT("Destroy this pickup actor after being picked up by a character."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitPickup(Z_Construct_UClass_AAdvKitPickup, &AAdvKitPickup::StaticClass, TEXT("AAdvKitPickup"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitPickup);
	UClass* Z_Construct_UClass_AAdvKitAmmunitionPickup_NoRegister()
	{
		return AAdvKitAmmunitionPickup::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitAmmunitionPickup()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitPickup();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitAmmunitionPickup::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Ammunition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Ammunition"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Ammunition, AAdvKitAmmunitionPickup), 0x0020080000000015);
				UProperty* NewProp_AmmuntionForWeapon = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AmmuntionForWeapon"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(AmmuntionForWeapon, AAdvKitAmmunitionPickup), 0x0024080000000015, Z_Construct_UClass_AAdvKitWeapon_NoRegister(), UClass::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitAmmunitionPickup.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitAmmunitionPickup.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Pickup class that provides ammunition for a specified weapon class."));
				MetaData->SetValue(NewProp_Ammunition, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_Ammunition, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitAmmunitionPickup.h"));
				MetaData->SetValue(NewProp_Ammunition, TEXT("ToolTip"), TEXT("How much ammunition the pickup gives."));
				MetaData->SetValue(NewProp_AmmuntionForWeapon, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_AmmuntionForWeapon, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitAmmunitionPickup.h"));
				MetaData->SetValue(NewProp_AmmuntionForWeapon, TEXT("ToolTip"), TEXT("The weapon this supply is for."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitAmmunitionPickup(Z_Construct_UClass_AAdvKitAmmunitionPickup, &AAdvKitAmmunitionPickup::StaticClass, TEXT("AAdvKitAmmunitionPickup"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitAmmunitionPickup);
	UClass* Z_Construct_UClass_AAdvKitInventoryPickup_NoRegister()
	{
		return AAdvKitInventoryPickup::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitInventoryPickup()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitPickup();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitInventoryPickup::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_SpawnedInventoryClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SpawnedInventoryClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(SpawnedInventoryClass, AAdvKitInventoryPickup), 0x0024080000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitInventoryPickup.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryPickup.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Inventory pickups spawn items when overlapped or used by the character and add it to\nthe character's inventory."));
				MetaData->SetValue(NewProp_SpawnedInventoryClass, TEXT("Category"), TEXT("Inventory"));
				MetaData->SetValue(NewProp_SpawnedInventoryClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitInventoryPickup.h"));
				MetaData->SetValue(NewProp_SpawnedInventoryClass, TEXT("ToolTip"), TEXT("The item that is spawned for the character on pickup."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitInventoryPickup(Z_Construct_UClass_AAdvKitInventoryPickup, &AAdvKitInventoryPickup::StaticClass, TEXT("AAdvKitInventoryPickup"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitInventoryPickup);
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchDeactivatedBySignature__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventSwitchDeactivatedBySignature_Parms
		{
			AAdvKitCharacter* ByCharacter;
			AAdvKitInventoryItem* WithItem;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SwitchDeactivatedBySignature__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventSwitchDeactivatedBySignature_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, _Script_AdvKitRuntime_eventSwitchDeactivatedBySignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_ByCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ByCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ByCharacter, _Script_AdvKitRuntime_eventSwitchDeactivatedBySignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchActivatedBySignature__DelegateSignature()
	{
		struct _Script_AdvKitRuntime_eventSwitchActivatedBySignature_Parms
		{
			AAdvKitCharacter* ByCharacter;
			AAdvKitInventoryItem* WithItem;
		};
		UObject* Outer=Z_Construct_UPackage__Script_AdvKitRuntime();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SwitchActivatedBySignature__DelegateSignature"), RF_Public|RF_Transient|RF_MarkAsNative) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_AdvKitRuntime_eventSwitchActivatedBySignature_Parms));
			UProperty* NewProp_WithItem = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WithItem"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WithItem, _Script_AdvKitRuntime_eventSwitchActivatedBySignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister());
			UProperty* NewProp_ByCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ByCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ByCharacter, _Script_AdvKitRuntime_eventSwitchActivatedBySignature_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitUsableSimpleSwitch_NoRegister()
	{
		return AAdvKitUsableSimpleSwitch::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitUsableSimpleSwitch()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitUsable();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitUsableSimpleSwitch::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DeactivationCharacterActionClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DeactivationCharacterActionClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(DeactivationCharacterActionClass, AAdvKitUsableSimpleSwitch), 0x0014000000000015, Z_Construct_UClass_UAdvKitCA_UseSwitch_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_ActivationCharacterActionClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ActivationCharacterActionClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ActivationCharacterActionClass, AAdvKitUsableSimpleSwitch), 0x0014000000000015, Z_Construct_UClass_UAdvKitCA_UseSwitch_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_OnDeactivatedBy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnDeactivatedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnDeactivatedBy, AAdvKitUsableSimpleSwitch), 0x0010100010080000, Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchDeactivatedBySignature__DelegateSignature());
				UProperty* NewProp_OnActivatedBy = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnActivatedBy"), RF_Public|RF_Transient|RF_MarkAsNative) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnActivatedBy, AAdvKitUsableSimpleSwitch), 0x0010100010080000, Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchActivatedBySignature__DelegateSignature());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanBeDeactivated, AAdvKitUsableSimpleSwitch, bool);
				UProperty* NewProp_bCanBeDeactivated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanBeDeactivated"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanBeDeactivated, AAdvKitUsableSimpleSwitch), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCanBeDeactivated, AAdvKitUsableSimpleSwitch), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanBeActivated, AAdvKitUsableSimpleSwitch, bool);
				UProperty* NewProp_bCanBeActivated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bCanBeActivated"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanBeActivated, AAdvKitUsableSimpleSwitch), 0x0020080000000015, CPP_BOOL_PROPERTY_BITMASK(bCanBeActivated, AAdvKitUsableSimpleSwitch), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bActive, AAdvKitUsableSimpleSwitch, bool);
				UProperty* NewProp_bActive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bActive"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bActive, AAdvKitUsableSimpleSwitch), 0x0020080000000035, CPP_BOOL_PROPERTY_BITMASK(bActive, AAdvKitUsableSimpleSwitch), sizeof(bool), true);
				UProperty* NewProp_KeyClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("KeyClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(KeyClass, AAdvKitUsableSimpleSwitch), 0x0024080000000015, Z_Construct_UClass_AAdvKitInventoryItem_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_Root = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Root"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Root, AAdvKitUsableSimpleSwitch), 0x00200800000a001d, Z_Construct_UClass_USceneComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class for a simple switch that can be activated with an item (e.g. a key)"));
				MetaData->SetValue(NewProp_DeactivationCharacterActionClass, TEXT("Category"), TEXT("Switch"));
				MetaData->SetValue(NewProp_DeactivationCharacterActionClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_DeactivationCharacterActionClass, TEXT("ToolTip"), TEXT("Action the player has to do when deactivating the switch."));
				MetaData->SetValue(NewProp_ActivationCharacterActionClass, TEXT("Category"), TEXT("Switch"));
				MetaData->SetValue(NewProp_ActivationCharacterActionClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_ActivationCharacterActionClass, TEXT("ToolTip"), TEXT("Action the player has to do when activating the switch."));
				MetaData->SetValue(NewProp_OnDeactivatedBy, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_OnDeactivatedBy, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_OnDeactivatedBy, TEXT("ToolTip"), TEXT("Delegate that is called when the switch was deactivated."));
				MetaData->SetValue(NewProp_OnActivatedBy, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_OnActivatedBy, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_OnActivatedBy, TEXT("ToolTip"), TEXT("Delegate that is called when the switch was activated."));
				MetaData->SetValue(NewProp_bCanBeDeactivated, TEXT("Category"), TEXT("Switch"));
				MetaData->SetValue(NewProp_bCanBeDeactivated, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_bCanBeDeactivated, TEXT("ToolTip"), TEXT("Can this switch be deactivated?"));
				MetaData->SetValue(NewProp_bCanBeActivated, TEXT("Category"), TEXT("Switch"));
				MetaData->SetValue(NewProp_bCanBeActivated, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_bCanBeActivated, TEXT("ToolTip"), TEXT("Can this switch be activated?"));
				MetaData->SetValue(NewProp_bActive, TEXT("Category"), TEXT("Switch"));
				MetaData->SetValue(NewProp_bActive, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_bActive, TEXT("ToolTip"), TEXT("Is this switch currently active?"));
				MetaData->SetValue(NewProp_KeyClass, TEXT("Category"), TEXT("Switch"));
				MetaData->SetValue(NewProp_KeyClass, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_KeyClass, TEXT("ToolTip"), TEXT("Class of another item that this switch needs to be activated (if any)."));
				MetaData->SetValue(NewProp_Root, TEXT("Category"), TEXT("AdvKitUsableSimpleSwitch"));
				MetaData->SetValue(NewProp_Root, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Root, TEXT("ModuleRelativePath"), TEXT("Classes/Items/AdvKitUsableSimpleSwitch.h"));
				MetaData->SetValue(NewProp_Root, TEXT("ToolTip"), TEXT("Root component for useable actors."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitUsableSimpleSwitch(Z_Construct_UClass_AAdvKitUsableSimpleSwitch, &AAdvKitUsableSimpleSwitch::StaticClass, TEXT("AAdvKitUsableSimpleSwitch"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitUsableSimpleSwitch);
	UFunction* Z_Construct_UFunction_AAdvKitZone_AddTransition()
	{
		struct AdvKitZone_eventAddTransition_Parms
		{
			TSubclassOf<AAdvKitCharacter>  For;
			UAdvKitTransitionComponent* Transition;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitZone_eventAddTransition_Parms));
			UProperty* NewProp_Transition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Transition"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Transition, AdvKitZone_eventAddTransition_Parms), 0x0010000000080080, Z_Construct_UClass_UAdvKitTransitionComponent_NoRegister());
			UProperty* NewProp_For = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("For"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(For, AdvKitZone_eventAddTransition_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Add an existing transition to the transitions list\n@param       For             Character class that can use the transition\n@param       Transition      The transition to add"));
			MetaData->SetValue(NewProp_Transition, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_ConstrainDirectionToZone()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstrainDirectionToZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(AdvKitZone_eventConstrainDirectionToZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventConstrainDirectionToZone_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AtWorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtWorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AtWorldLocation, AdvKitZone_eventConstrainDirectionToZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldDirection, AdvKitZone_eventConstrainDirectionToZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Restricts a desired direction to match zone.\n@param       WorldDirection  Direction to restrict.\n@param       AtWorldLocation Location at which the direction should be constrained. (Since zones may be splines a constrained direction can differ based on location).\n@return      Direction restricted to zone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_ConstrainPositionToZone()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstrainPositionToZone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(AdvKitZone_eventConstrainPositionToZone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventConstrainPositionToZone_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZone_eventConstrainPositionToZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZone_eventConstrainPositionToZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldPosition, AdvKitZone_eventConstrainPositionToZone_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Clamps a given location so it is inside the zone.\n@param       WorldPosition   Location to clamp.\n@param       HalfExtent      Half size of the character, describing its capsule (e.g. capsule radius and half height)\n@param       ExtentWorldRotation     Rotation of the character.\n@return      Location inside zone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GenerateTransitions()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GenerateTransitions"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(AdvKitZone_eventGenerateTransitions_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bZoneMoved, AdvKitZone_eventGenerateTransitions_Parms, bool);
			UProperty* NewProp_bZoneMoved = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bZoneMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bZoneMoved, AdvKitZone_eventGenerateTransitions_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bZoneMoved, AdvKitZone_eventGenerateTransitions_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bZoneMoved"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates all transitions for this zone. Called either manually or by a transition builder if an\nadjacent zone triggers it.\n@param       bZoneMoved      True if this zone was moved, false if it not"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetClosestZoneLocation()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetClosestZoneLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(AdvKitZone_eventGetClosestZoneLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetClosestZoneLocation_Parms), 0x0010000000000580, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZone_eventGetClosestZoneLocation_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZone_eventGetClosestZoneLocation_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldPosition, AdvKitZone_eventGetClosestZoneLocation_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a new zone location as close to a given location as possible\n@param       WorldPosition   Location the zone location would ideally be at.\n@param       HalfExtent      Half size of the character, describing its capsule (e.g. capsule radius and half height)\n@param       ExtentWorldRotation     Rotation of the character.\n@return      Zone Location inside zone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetCustomPhysics()
	{
		struct AdvKitZone_eventGetCustomPhysics_Parms
		{
			uint8 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCustomPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitZone_eventGetCustomPhysics_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetCustomPhysics_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get custom movement mode of this zone.\n@return Custom movement mode inside the zone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetPhysics()
	{
		struct AdvKitZone_eventGetPhysics_Parms
		{
			TEnumAsByte<EAdvKitMovementMode> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitZone_eventGetPhysics_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetPhysics_Parms), 0x0010000000000580, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get movement mode of this zone.\n@return Movement mode inside the zone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetPositionInDirection()
	{
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPositionInDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(AdvKitZone_eventGetPositionInDirection_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetPositionInDirection_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZone_eventGetPositionInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZone_eventGetPositionInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bClamp, AdvKitZone_eventGetPositionInDirection_Parms, bool);
			UProperty* NewProp_bClamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bClamp"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bClamp, AdvKitZone_eventGetPositionInDirection_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bClamp, AdvKitZone_eventGetPositionInDirection_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldDesiredDelta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldDesiredDelta"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldDesiredDelta, AdvKitZone_eventGetPositionInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_FromWorldPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FromWorldPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(FromWorldPosition, AdvKitZone_eventGetPositionInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the next position in this zone in a certain direction. Since zones restrict movement the character can not always\nmove as it desires, but has to adhere to a direction given by the zone.\n@param       FromWorldPosition       Where the movement starts\n@param       WorldDesiredDelta       The intended direction of the movement\n@param       bClamp  Whether or not to restrict the resulting location to the zone as well\n@param       HalfExtent      Half size of the character, describing its capsule (e.g. capsule radius and half height)\n@param       ExtentWorldRotation     Rotation of the character.\n@return The resulting location after the move was restricted to the zone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetZoneForwardVector()
	{
		struct AdvKitZone_eventGetZoneForwardVector_Parms
		{
			const UAdvKitZoneLocation* AtLocation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZoneForwardVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitZone_eventGetZoneForwardVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetZoneForwardVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AtLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AtLocation, AdvKitZone_eventGetZoneForwardVector_Parms), 0x0010000000000082, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the zone's forward vector at a specified point.\n@param       AtLocation      Location to query the vector at.\n@return      Forward vector in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetZoneRightVector()
	{
		struct AdvKitZone_eventGetZoneRightVector_Parms
		{
			const UAdvKitZoneLocation* AtLocation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZoneRightVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitZone_eventGetZoneRightVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetZoneRightVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AtLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AtLocation, AdvKitZone_eventGetZoneRightVector_Parms), 0x0010000000000082, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the zone's right vector at a specified point.\n@param       AtLocation      Location to query the vector at.\n@return      Right vector in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_GetZoneUpVector()
	{
		struct AdvKitZone_eventGetZoneUpVector_Parms
		{
			const UAdvKitZoneLocation* AtLocation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetZoneUpVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820400, 65535, sizeof(AdvKitZone_eventGetZoneUpVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventGetZoneUpVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AtLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AtLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(AtLocation, AdvKitZone_eventGetZoneUpVector_Parms), 0x0010000000000082, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the zone's up vector at a specified point.\n@param       AtLocation      Location to query the vector at.\n@return      Up vector in world space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_HasCustomPhysics()
	{
		struct AdvKitZone_eventHasCustomPhysics_Parms
		{
			uint8 QueryPhysics;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasCustomPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitZone_eventHasCustomPhysics_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitZone_eventHasCustomPhysics_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitZone_eventHasCustomPhysics_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitZone_eventHasCustomPhysics_Parms), sizeof(bool), true);
			UProperty* NewProp_QueryPhysics = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("QueryPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(QueryPhysics, AdvKitZone_eventHasCustomPhysics_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the zone has a specific custom movement mode.\n@param QueryPhysics  The mode to check for.\n@return      True if zone has this mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_HasPhysics()
	{
		struct AdvKitZone_eventHasPhysics_Parms
		{
			TEnumAsByte<EAdvKitMovementMode> QueryPhysics;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitZone_eventHasPhysics_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitZone_eventHasPhysics_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitZone_eventHasPhysics_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitZone_eventHasPhysics_Parms), sizeof(bool), true);
			UProperty* NewProp_QueryPhysics = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("QueryPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(QueryPhysics, AdvKitZone_eventHasPhysics_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the zone has a specific movement mode.\n@param QueryPhysics  The mode to check for.\n@return      True if zone has this mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_MoveLocationInDirection()
	{
		struct AdvKitZone_eventMoveLocationInDirection_Parms
		{
			UAdvKitZoneLocation* LocationToMove;
			FVector WorldDesiredDelta;
			FVector HalfExtent;
			FRotator ExtentWorldRotation;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MoveLocationInDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitZone_eventMoveLocationInDirection_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitZone_eventMoveLocationInDirection_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitZone_eventMoveLocationInDirection_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitZone_eventMoveLocationInDirection_Parms), sizeof(bool), true);
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZone_eventMoveLocationInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZone_eventMoveLocationInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldDesiredDelta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldDesiredDelta"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldDesiredDelta, AdvKitZone_eventMoveLocationInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LocationToMove = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LocationToMove"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(LocationToMove, AdvKitZone_eventMoveLocationInDirection_Parms), 0x0010000000000080, Z_Construct_UClass_UAdvKitZoneLocation_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Moves a zone location along the zone while keeping it inside the zone.\n@param       LocationToMove  The location object to move\n@param       WorldDesiredDelta       The intended direction of the movement\n@param       HalfExtent      Half size of the character, describing its capsule (e.g. capsule radius and half height)\n@param       ExtentWorldRotation     Rotation of the character.\n@return True if location was moved, false otherwise"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_RegisterTransition()
	{
		struct AdvKitZone_eventRegisterTransition_Parms
		{
			FVector WorldSourceLocation;
			FVector WorldTargetLocation;
			TSubclassOf<AAdvKitCharacter>  ForCharacter;
			TEnumAsByte<EAdvKitMovementMode> MovementMode;
			AAdvKitZone* TargetZone;
			uint8 CustomMovementMode;
			UAdvKitTransitionComponentPoint* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RegisterTransition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitZone_eventRegisterTransition_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventRegisterTransition_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitTransitionComponentPoint_NoRegister());
			UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, AdvKitZone_eventRegisterTransition_Parms), 0x0010000000000080);
			UProperty* NewProp_TargetZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetZone, AdvKitZone_eventRegisterTransition_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementMode, AdvKitZone_eventRegisterTransition_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			UProperty* NewProp_ForCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacter, AdvKitZone_eventRegisterTransition_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_WorldTargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldTargetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldTargetLocation, AdvKitZone_eventRegisterTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldSourceLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldSourceLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldSourceLocation, AdvKitZone_eventRegisterTransition_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_CustomMovementMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a new transition point in this zone, specified by the parameters.\n@param       WorldSourceLocation             Start of the transition (inside the zone)\n@param       WorldTargetLocation     End of the transition (outside of the zone)\n@param       ForCharacter    Which character class can use the transition\n@param       MovementMode    Movement mode the character will have after the transition\n@param       TargetZone              Target zone of the transition or null if used to exit the zone\n@param       CustomMovementMode      Which custom movement mode the character will have after the transition.\n@return Created transition component"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_RegisterTransitionArea()
	{
		struct AdvKitZone_eventRegisterTransitionArea_Parms
		{
			FVector MinWorldSourceLocation;
			FVector MinWorldTargetLocation;
			FVector MaxWorldSourceLocation;
			FVector MaxWorldTargetLocation;
			TSubclassOf<AAdvKitCharacter>  ForCharacter;
			TEnumAsByte<EAdvKitMovementMode> MovementMode;
			AAdvKitZone* TargetZone;
			uint8 CustomMovementMode;
			UAdvKitTransitionComponentArea* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RegisterTransitionArea"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitZone_eventRegisterTransitionArea_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000000080588, Z_Construct_UClass_UAdvKitTransitionComponentArea_NoRegister());
			UProperty* NewProp_CustomMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CustomMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomMovementMode, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000000000080);
			UProperty* NewProp_TargetZone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetZone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetZone, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			UProperty* NewProp_MovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementMode, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000000000080, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
			UProperty* NewProp_ForCharacter = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ForCharacter"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(ForCharacter, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0014000000000080, Z_Construct_UClass_AAdvKitCharacter_NoRegister(), UClass::StaticClass());
			UProperty* NewProp_MaxWorldTargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxWorldTargetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxWorldTargetLocation, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MaxWorldSourceLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxWorldSourceLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxWorldSourceLocation, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MinWorldTargetLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MinWorldTargetLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinWorldTargetLocation, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MinWorldSourceLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MinWorldSourceLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinWorldSourceLocation, AdvKitZone_eventRegisterTransitionArea_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_CustomMovementMode"), TEXT("0"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a new transition area in this zone, specified by the parameters.\n@param       MinWorldSourceLocation          Left start of the transition line (inside the zone)\n@param       MinWorldTargetLocation          Left end of the transition line (outside of the zone)\n@param       MaxWorldSourceLocation          Right start of the transition (inside the zone)\n@param       MaxWorldTargetLocation          Right end of the transition (outside of the zone)\n@param       ForCharacter    Which character class can use the transition\n@param       MovementMode    Movement mode the character will have after the transition\n@param       TargetZone              Target zone of the transition or null if used to exit the zone\n@param       CustomMovementMode      Which custom movement mode the character will have after the transition.\n@return Created transition component"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AAdvKitZone_RemoveExistingTransitionsTo()
	{
		struct AdvKitZone_eventRemoveExistingTransitionsTo_Parms
		{
			AAdvKitZone* Other;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveExistingTransitionsTo"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(AdvKitZone_eventRemoveExistingTransitionsTo_Parms));
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Other, AdvKitZone_eventRemoveExistingTransitionsTo_Parms), 0x0010000000000080, Z_Construct_UClass_AAdvKitZone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Removes all transitions that target a specified zone\n@param       Other   The zone that transitions target"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitZone_NoRegister()
	{
		return AAdvKitZone::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitZone()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitZone::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_AddTransition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_ConstrainDirectionToZone());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_ConstrainPositionToZone());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GenerateTransitions());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetClosestZoneLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetCustomPhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetPhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetPositionInDirection());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetZoneForwardVector());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetZoneRightVector());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_GetZoneUpVector());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_HasCustomPhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_HasPhysics());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_MoveLocationInDirection());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_RegisterTransition());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_RegisterTransitionArea());
				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZone_RemoveExistingTransitionsTo());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BuildModules = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BuildModules"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(BuildModules, AAdvKitZone), 0x001000800000000d);
				UProperty* NewProp_BuildModules_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BuildModules, TEXT("BuildModules"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UAdvKitTransitionBuilderModule_NoRegister());
				UProperty* NewProp_CustomZonePhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomZonePhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CustomZonePhysics, AAdvKitZone), 0x0010000000000005);
				UProperty* NewProp_ZonePhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ZonePhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ZonePhysics, AAdvKitZone), 0x0010000000000005, Z_Construct_UEnum_AdvKitRuntime_EAdvKitMovementMode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_AddTransition(), "AddTransition"); // 3304940771
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_ConstrainDirectionToZone(), "ConstrainDirectionToZone"); // 3476752077
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_ConstrainPositionToZone(), "ConstrainPositionToZone"); // 4276383523
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GenerateTransitions(), "GenerateTransitions"); // 3923428487
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetClosestZoneLocation(), "GetClosestZoneLocation"); // 3425810127
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetCustomPhysics(), "GetCustomPhysics"); // 779513640
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetPhysics(), "GetPhysics"); // 527573323
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetPositionInDirection(), "GetPositionInDirection"); // 464358262
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetZoneForwardVector(), "GetZoneForwardVector"); // 1593663398
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetZoneRightVector(), "GetZoneRightVector"); // 2215399184
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_GetZoneUpVector(), "GetZoneUpVector"); // 1351411713
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_HasCustomPhysics(), "HasCustomPhysics"); // 259867900
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_HasPhysics(), "HasPhysics"); // 3239530800
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_MoveLocationInDirection(), "MoveLocationInDirection"); // 1912404435
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_RegisterTransition(), "RegisterTransition"); // 2189864194
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_RegisterTransitionArea(), "RegisterTransitionArea"); // 3635959940
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZone_RemoveExistingTransitionsTo(), "RemoveExistingTransitionsTo"); // 1509869921
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/AdvKitZone.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Zones are special movement objects that a character can use for specific movement modes.\n\nA zone always restricts movement within a specified region, e.g. a line or rectangle. Zones can\nalso have predefined transition points between them."));
				MetaData->SetValue(NewProp_BuildModules, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_BuildModules, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_BuildModules, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
				MetaData->SetValue(NewProp_BuildModules, TEXT("ToolTip"), TEXT("Build modules this zone will use."));
				MetaData->SetValue(NewProp_BuildModules_Inner, TEXT("Category"), TEXT("Transitions"));
				MetaData->SetValue(NewProp_BuildModules_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_BuildModules_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
				MetaData->SetValue(NewProp_BuildModules_Inner, TEXT("ToolTip"), TEXT("Build modules this zone will use."));
				MetaData->SetValue(NewProp_CustomZonePhysics, TEXT("Category"), TEXT("Zone"));
				MetaData->SetValue(NewProp_CustomZonePhysics, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
				MetaData->SetValue(NewProp_CustomZonePhysics, TEXT("ToolTip"), TEXT("Custom Movement mode to be used in this zone"));
				MetaData->SetValue(NewProp_ZonePhysics, TEXT("Category"), TEXT("Zone"));
				MetaData->SetValue(NewProp_ZonePhysics, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZone.h"));
				MetaData->SetValue(NewProp_ZonePhysics, TEXT("ToolTip"), TEXT("Movement mode to be used in this zone"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitZone(Z_Construct_UClass_AAdvKitZone, &AAdvKitZone::StaticClass, TEXT("AAdvKitZone"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitZone);
	UFunction* Z_Construct_UFunction_AAdvKitZoneLine_GetProjectedHalfExtent()
	{
		struct AdvKitZoneLine_eventGetProjectedHalfExtent_Parms
		{
			FVector LocalDirection;
			FVector HalfExtent;
			FRotator ExtentWorldRotation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZoneLine();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetProjectedHalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C80400, 65535, sizeof(AdvKitZoneLine_eventGetProjectedHalfExtent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZoneLine_eventGetProjectedHalfExtent_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZoneLine_eventGetProjectedHalfExtent_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZoneLine_eventGetProjectedHalfExtent_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LocalDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LocalDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalDirection, AdvKitZoneLine_eventGetProjectedHalfExtent_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneLine.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Projects a given character extent onto a line defined by direction.\n@param       LocalDirection  The line's direction to project onto in local space\n@param       HalfExtent      The extent of the character to project\n@param       ExtentWorldRotation     World rotation of the character.\n@return      The projected half extent."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitZoneLine_NoRegister()
	{
		return AAdvKitZoneLine::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitZoneLine()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitZone();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitZoneLine::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZoneLine_GetProjectedHalfExtent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConstrainExtentAtEnd, AAdvKitZoneLine, bool);
				UProperty* NewProp_bConstrainExtentAtEnd = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bConstrainExtentAtEnd"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConstrainExtentAtEnd, AAdvKitZoneLine), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bConstrainExtentAtEnd, AAdvKitZoneLine), sizeof(bool), true);
				UProperty* NewProp_ZoneEnd = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ZoneEnd"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ZoneEnd, AAdvKitZoneLine), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bConstrainExtentAtStart, AAdvKitZoneLine, bool);
				UProperty* NewProp_bConstrainExtentAtStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bConstrainExtentAtStart"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bConstrainExtentAtStart, AAdvKitZoneLine), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bConstrainExtentAtStart, AAdvKitZoneLine), sizeof(bool), true);
				UProperty* NewProp_ZoneStart = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ZoneStart"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ZoneStart, AAdvKitZoneLine), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZoneLine_GetProjectedHalfExtent(), "GetProjectedHalfExtent"); // 1188996446
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/Zones/AdvKitZoneLine.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneLine.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a zone that consists of a straight line defined by a beginning and end point.\nThe character can only move in two directions along the line."));
				MetaData->SetValue(NewProp_bConstrainExtentAtEnd, TEXT("Category"), TEXT("Zone"));
				MetaData->SetValue(NewProp_bConstrainExtentAtEnd, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneLine.h"));
				MetaData->SetValue(NewProp_bConstrainExtentAtEnd, TEXT("ToolTip"), TEXT("Whether or not the end of the line is clamped by the character's extent (think it as being a wall)."));
				MetaData->SetValue(NewProp_ZoneEnd, TEXT("Category"), TEXT("Zone"));
				MetaData->SetValue(NewProp_ZoneEnd, TEXT("MakeEditWidget"), TEXT(""));
				MetaData->SetValue(NewProp_ZoneEnd, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneLine.h"));
				MetaData->SetValue(NewProp_ZoneEnd, TEXT("ToolTip"), TEXT("End of the line"));
				MetaData->SetValue(NewProp_bConstrainExtentAtStart, TEXT("Category"), TEXT("Zone"));
				MetaData->SetValue(NewProp_bConstrainExtentAtStart, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneLine.h"));
				MetaData->SetValue(NewProp_bConstrainExtentAtStart, TEXT("ToolTip"), TEXT("Whether or not the start of the line is clamped by the character's extent (think it as being a wall)."));
				MetaData->SetValue(NewProp_ZoneStart, TEXT("Category"), TEXT("Zone"));
				MetaData->SetValue(NewProp_ZoneStart, TEXT("MakeEditWidget"), TEXT(""));
				MetaData->SetValue(NewProp_ZoneStart, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneLine.h"));
				MetaData->SetValue(NewProp_ZoneStart, TEXT("ToolTip"), TEXT("Start of the line"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitZoneLine(Z_Construct_UClass_AAdvKitZoneLine, &AAdvKitZoneLine::StaticClass, TEXT("AAdvKitZoneLine"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitZoneLine);
	UFunction* Z_Construct_UFunction_AAdvKitZoneRectangle_GetProjectedHalfExtent()
	{
		struct AdvKitZoneRectangle_eventGetProjectedHalfExtent_Parms
		{
			FVector HalfExtent;
			FRotator ExtentWorldRotation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AAdvKitZoneRectangle();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetProjectedHalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C80400, 65535, sizeof(AdvKitZoneRectangle_eventGetProjectedHalfExtent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZoneRectangle_eventGetProjectedHalfExtent_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZoneRectangle_eventGetProjectedHalfExtent_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZoneRectangle_eventGetProjectedHalfExtent_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneRectangle.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Projects a given character extent onto the rectangle plane.\n@param       HalfExtent      The extent of the character to project\n@param       ExtentWorldRotation     World rotation of the character.\n@return      The projected half extent."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AAdvKitZoneRectangle_NoRegister()
	{
		return AAdvKitZoneRectangle::StaticClass();
	}
	UClass* Z_Construct_UClass_AAdvKitZoneRectangle()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AAdvKitZone();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = AAdvKitZoneRectangle::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900081;

				OuterClass->LinkChild(Z_Construct_UFunction_AAdvKitZoneRectangle_GetProjectedHalfExtent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LocalRectMaxBoundary = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocalRectMaxBoundary"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalRectMaxBoundary, AAdvKitZoneRectangle), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_LocalRectMinBoundary = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocalRectMinBoundary"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalRectMinBoundary, AAdvKitZoneRectangle), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AAdvKitZoneRectangle_GetProjectedHalfExtent(), "GetProjectedHalfExtent"); // 2858146485
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/Zones/AdvKitZoneRectangle.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneRectangle.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Implementation of a zone that provides the character with a rectangle defined movement."));
				MetaData->SetValue(NewProp_LocalRectMaxBoundary, TEXT("Category"), TEXT("Rect"));
				MetaData->SetValue(NewProp_LocalRectMaxBoundary, TEXT("MakeEditWidget"), TEXT(""));
				MetaData->SetValue(NewProp_LocalRectMaxBoundary, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneRectangle.h"));
				MetaData->SetValue(NewProp_LocalRectMaxBoundary, TEXT("ToolTip"), TEXT("\"Upper Right\" corner of the rectangle"));
				MetaData->SetValue(NewProp_LocalRectMinBoundary, TEXT("Category"), TEXT("Rect"));
				MetaData->SetValue(NewProp_LocalRectMinBoundary, TEXT("MakeEditWidget"), TEXT(""));
				MetaData->SetValue(NewProp_LocalRectMinBoundary, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/Zones/AdvKitZoneRectangle.h"));
				MetaData->SetValue(NewProp_LocalRectMinBoundary, TEXT("ToolTip"), TEXT("\"Lower Left\" corner of the rectangle"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AAdvKitZoneRectangle(Z_Construct_UClass_AAdvKitZoneRectangle, &AAdvKitZoneRectangle::StaticClass, TEXT("AAdvKitZoneRectangle"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AAdvKitZoneRectangle);
	UFunction* Z_Construct_UFunction_UAdvKitZoneLocation_ConstrainDirection()
	{
		struct AdvKitZoneLocation_eventConstrainDirection_Parms
		{
			FVector WorldDirection;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitZoneLocation();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConstrainDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitZoneLocation_eventConstrainDirection_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AdvKitZoneLocation_eventConstrainDirection_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldDirection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldDirection, AdvKitZoneLocation_eventConstrainDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZoneLocation.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Constrains a direction in world space to align with the zone.\n@param       WorldDirection  Direction to constrain.\n@return      The restricted direction."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAdvKitZoneLocation_MoveInDirection()
	{
		struct AdvKitZoneLocation_eventMoveInDirection_Parms
		{
			FVector WorldDesiredDelta;
			FVector HalfExtent;
			FRotator ExtentWorldRotation;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAdvKitZoneLocation();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MoveInDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20400, 65535, sizeof(AdvKitZoneLocation_eventMoveInDirection_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AdvKitZoneLocation_eventMoveInDirection_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AdvKitZoneLocation_eventMoveInDirection_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AdvKitZoneLocation_eventMoveInDirection_Parms), sizeof(bool), true);
			UProperty* NewProp_ExtentWorldRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ExtentWorldRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ExtentWorldRotation, AdvKitZoneLocation_eventMoveInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HalfExtent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HalfExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HalfExtent, AdvKitZoneLocation_eventMoveInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_WorldDesiredDelta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldDesiredDelta"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldDesiredDelta, AdvKitZoneLocation_eventMoveInDirection_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("AdvKit"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZoneLocation.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Attempts to move the location inside the zone.\n@param       WorldDesiredDelta       Direction to move in.\n@param       HalfExtent      Half size of the character, describing its capsule (e.g. capsule radius and half height)\n@param       ExtentWorldRotation     Rotation of the character.\n@return      True if the loation could be moved, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAdvKitZoneLocation_NoRegister()
	{
		return UAdvKitZoneLocation::StaticClass();
	}
	UClass* Z_Construct_UClass_UAdvKitZoneLocation()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAdvKitZoneLocation::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitZoneLocation_ConstrainDirection());
				OuterClass->LinkChild(Z_Construct_UFunction_UAdvKitZoneLocation_MoveInDirection());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LocalPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocalPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalPosition, UAdvKitZoneLocation), 0x0010000000000025, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Zone = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Zone"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Zone, UAdvKitZoneLocation), 0x0010000000000025, Z_Construct_UClass_AAdvKitZone_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitZoneLocation_ConstrainDirection(), "ConstrainDirection"); // 1531403663
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAdvKitZoneLocation_MoveInDirection(), "MoveInDirection"); // 3370993551
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Environment/AdvKitZoneLocation.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZoneLocation.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("@brief Base class for object that defines a location inside a zone.\n\nDifferent zones can have different location specifiers. This class\ntakes care of storing a location and all the conversion methods\nrequired to position the character."));
				MetaData->SetValue(NewProp_LocalPosition, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_LocalPosition, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZoneLocation.h"));
				MetaData->SetValue(NewProp_LocalPosition, TEXT("ToolTip"), TEXT("Relative location to the zone"));
				MetaData->SetValue(NewProp_Zone, TEXT("Category"), TEXT("AdvKit"));
				MetaData->SetValue(NewProp_Zone, TEXT("ModuleRelativePath"), TEXT("Classes/Environment/AdvKitZoneLocation.h"));
				MetaData->SetValue(NewProp_Zone, TEXT("ToolTip"), TEXT("Zone this location is in"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAdvKitZoneLocation(Z_Construct_UClass_UAdvKitZoneLocation, &UAdvKitZoneLocation::StaticClass, TEXT("UAdvKitZoneLocation"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAdvKitZoneLocation);
	UClass* Z_Construct_UClass_UAnimMetaData_Transition_NoRegister()
	{
		return UAnimMetaData_Transition::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimMetaData_Transition()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimMetaData();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAnimMetaData_Transition::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20013080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAbsoluteTransitionCorrection, UAnimMetaData_Transition, bool);
				UProperty* NewProp_bAbsoluteTransitionCorrection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAbsoluteTransitionCorrection"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAbsoluteTransitionCorrection, UAnimMetaData_Transition), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(bAbsoluteTransitionCorrection, UAnimMetaData_Transition), sizeof(bool), true);
				UProperty* NewProp_LocalRotationOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocalRotationOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalRotationOffset, UAnimMetaData_Transition), 0x0010000000000015, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_LocalTranslationOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocalTranslationOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LocalTranslationOffset, UAnimMetaData_Transition), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/Movement/AnimMetaData_Transition.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AnimMetaData_Transition.h"));
				MetaData->SetValue(NewProp_bAbsoluteTransitionCorrection, TEXT("Category"), TEXT("Transition Prediction"));
				MetaData->SetValue(NewProp_bAbsoluteTransitionCorrection, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AnimMetaData_Transition.h"));
				MetaData->SetValue(NewProp_bAbsoluteTransitionCorrection, TEXT("ToolTip"), TEXT("Use rotation part of transition prediction"));
				MetaData->SetValue(NewProp_LocalRotationOffset, TEXT("Category"), TEXT("Transition Prediction"));
				MetaData->SetValue(NewProp_LocalRotationOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AnimMetaData_Transition.h"));
				MetaData->SetValue(NewProp_LocalRotationOffset, TEXT("ToolTip"), TEXT("Rotation offset the character gets form the animation in character space"));
				MetaData->SetValue(NewProp_LocalTranslationOffset, TEXT("Category"), TEXT("Transition Prediction"));
				MetaData->SetValue(NewProp_LocalTranslationOffset, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/Movement/AnimMetaData_Transition.h"));
				MetaData->SetValue(NewProp_LocalTranslationOffset, TEXT("ToolTip"), TEXT("Movement offset the character gets form the animation in character space"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimMetaData_Transition(Z_Construct_UClass_UAnimMetaData_Transition, &UAnimMetaData_Transition::StaticClass, TEXT("UAnimMetaData_Transition"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimMetaData_Transition);
	UClass* Z_Construct_UClass_UAnimNotify_CharacterModifier_NoRegister()
	{
		return UAnimNotify_CharacterModifier::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimNotify_CharacterModifier()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimNotify();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAnimNotify_CharacterModifier::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20812080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Modifiers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Modifiers"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Modifiers, UAnimNotify_CharacterModifier), 0x001000800000001d);
				UProperty* NewProp_Modifiers_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Modifiers, TEXT("Modifiers"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0002000000080008, Z_Construct_UClass_UAdvKitCharacterAction_CharacterModifier_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Modify Character"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AnimNotify_CharacterModifier.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotify_CharacterModifier.h"));
				MetaData->SetValue(NewProp_Modifiers, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_Modifiers, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Modifiers, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotify_CharacterModifier.h"));
				MetaData->SetValue(NewProp_Modifiers, TEXT("Tooltip"), TEXT("Configurations that make changes to the character."));
				MetaData->SetValue(NewProp_Modifiers_Inner, TEXT("Category"), TEXT("Action"));
				MetaData->SetValue(NewProp_Modifiers_Inner, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_Modifiers_Inner, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotify_CharacterModifier.h"));
				MetaData->SetValue(NewProp_Modifiers_Inner, TEXT("Tooltip"), TEXT("Configurations that make changes to the character."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimNotify_CharacterModifier(Z_Construct_UClass_UAnimNotify_CharacterModifier, &UAnimNotify_CharacterModifier::StaticClass, TEXT("UAnimNotify_CharacterModifier"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimNotify_CharacterModifier);
	UClass* Z_Construct_UClass_UAnimNotify_SetTransitionZone_NoRegister()
	{
		return UAnimNotify_SetTransitionZone::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimNotify_SetTransitionZone()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UAnimNotify();
			Z_Construct_UPackage__Script_AdvKitRuntime();
			OuterClass = UAnimNotify_SetTransitionZone::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20012080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSnapToZone, UAnimNotify_SetTransitionZone, bool);
				UProperty* NewProp_bSnapToZone = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bSnapToZone"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSnapToZone, UAnimNotify_SetTransitionZone), 0x0020080000000011, CPP_BOOL_PROPERTY_BITMASK(bSnapToZone, UAnimNotify_SetTransitionZone), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("DisplayName"), TEXT("Set Zone"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Actions/AnimNotify_SetTransitionZone.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotify_SetTransitionZone.h"));
				MetaData->SetValue(OuterClass, TEXT("OnlyDefaultConstructorDeclared"), TEXT(""));
				MetaData->SetValue(NewProp_bSnapToZone, TEXT("Category"), TEXT("Transition"));
				MetaData->SetValue(NewProp_bSnapToZone, TEXT("ModuleRelativePath"), TEXT("Classes/Actions/AnimNotify_SetTransitionZone.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimNotify_SetTransitionZone(Z_Construct_UClass_UAnimNotify_SetTransitionZone, &UAnimNotify_SetTransitionZone::StaticClass, TEXT("UAnimNotify_SetTransitionZone"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimNotify_SetTransitionZone);
	UPackage* Z_Construct_UPackage__Script_AdvKitRuntime()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/AdvKitRuntime")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x5BB80B5A;
			Guid.B = 0xB80134BA;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

			Z_Construct_UDelegateFunction_AdvKitRuntime_OrientationChanged__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_UsedBySignature__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchActivatedBySignature__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_SwitchDeactivatedBySignature__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_ItemAddedSignature__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_ItemRemovedSignature__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_ActiveItemChanged__DelegateSignature();
			Z_Construct_UDelegateFunction_AdvKitRuntime_InventoryItemsChanged__DelegateSignature();
		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
