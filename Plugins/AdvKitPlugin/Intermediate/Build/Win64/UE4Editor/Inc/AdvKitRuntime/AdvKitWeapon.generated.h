// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	C++ class header boilerplate exported from UnrealHeaderTool.
	This is automatically generated by the tools.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "ObjectBase.h"

PRAGMA_DISABLE_DEPRECATION_WARNINGS
struct FAdvKitWeaponState;
class AActor;
struct FDamageEvent;
class AController;
class UAdvKitFireModeConfiguration;
struct FRotator;
struct FVector;
class AAdvKitProjectile;
#ifdef ADVKITRUNTIME_AdvKitWeapon_generated_h
#error "AdvKitWeapon.generated.h already included, missing '#pragma once' in AdvKitWeapon.h"
#endif
#define ADVKITRUNTIME_AdvKitWeapon_generated_h

#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_29_GENERATED_BODY \
	friend ADVKITRUNTIME_API class UScriptStruct* Z_Construct_UScriptStruct_FAdvKitWeaponState(); \
	ADVKITRUNTIME_API static class UScriptStruct* StaticStruct();


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_RPC_WRAPPERS \
	virtual void OnWeaponEmpty_Implementation(); \
	virtual void OnMagazineEmpty_Implementation(); \
	virtual void OnReloadEnd_Implementation(); \
	virtual void OnReloaded_Implementation(); \
	virtual void OnReloadBegin_Implementation(); \
	virtual void OnFireEnd_Implementation(); \
	virtual void OnFireShot_Implementation(); \
	virtual void OnFireBegin_Implementation(); \
	virtual bool StopReloadServer_Validate(); \
	virtual void StopReloadServer_Implementation(); \
	virtual bool StartReloadServer_Validate(); \
	virtual void StartReloadServer_Implementation(); \
	virtual bool StopFireServer_Validate(); \
	virtual void StopFireServer_Implementation(); \
	virtual bool StartFireServer_Validate(uint8 ); \
	virtual void StartFireServer_Implementation(uint8 FireModeIndex); \
	virtual void BlockedBy_Implementation(AActor* By, float BlockedDamage); \
	virtual float BlockDamage_Implementation(float Damage, const FDamageEvent& DamageEvent, AController* EventInstigator, AActor* DamageCauser); \
	virtual void StopReloadTimer_Implementation(); \
	virtual void StartReloadTimer_Implementation(); \
	virtual void AddAmmunition_Implementation(int32 Amount); \
	virtual void ReloadAmmunition_Implementation(); \
	virtual void StopReloadInternal_Implementation(); \
	virtual void StartReloadInternal_Implementation(); \
	virtual bool CanReload_Implementation(); \
	virtual void StopFireInternal_Implementation(); \
	virtual void StartFireInternal_Implementation(); \
	virtual bool CanFire_Implementation(); \
	virtual FVector GetTraceStart_Implementation(uint8 FireModeIndex); \
	virtual FVector GetMuzzleLocation_Implementation(uint8 FireModeIndex); \
	virtual void FireCustom_Implementation(); \
	virtual AAdvKitProjectile* FireProjectile_Implementation(); \
	virtual void FireInstant_Implementation(); \
	virtual void FireAmmunition_Implementation(); \
	virtual void HandleFiringPrerequisites_Implementation(); \
	virtual void ConsumeAmmunition_Implementation(); \
	virtual void StopReload_Implementation(); \
	virtual void StartReload_Implementation(); \
	virtual void StopFire_Implementation(); \
	virtual void StartFire_Implementation(uint8 FireModeIndex); \
 \
	DECLARE_FUNCTION(execOnWeaponEmpty) \
	{ \
		P_FINISH; \
		this->OnWeaponEmpty_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnMagazineEmpty) \
	{ \
		P_FINISH; \
		this->OnMagazineEmpty_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnReloadEnd) \
	{ \
		P_FINISH; \
		this->OnReloadEnd_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnReloaded) \
	{ \
		P_FINISH; \
		this->OnReloaded_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnReloadBegin) \
	{ \
		P_FINISH; \
		this->OnReloadBegin_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnFireEnd) \
	{ \
		P_FINISH; \
		this->OnFireEnd_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnFireShot) \
	{ \
		P_FINISH; \
		this->OnFireShot_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnFireBegin) \
	{ \
		P_FINISH; \
		this->OnFireBegin_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnRep_WeaponState) \
	{ \
		P_GET_STRUCT(FAdvKitWeaponState,Z_Param_OldState); \
		P_FINISH; \
		this->OnRep_WeaponState(Z_Param_OldState); \
	} \
 \
	DECLARE_FUNCTION(execStopReloadServer) \
	{ \
		P_FINISH; \
		if (!this->StopReloadServer_Validate()) \
		{ \
			RPC_ValidateFailed(TEXT("StopReloadServer_Validate")); \
			return; \
		} \
		this->StopReloadServer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReloadServer) \
	{ \
		P_FINISH; \
		if (!this->StartReloadServer_Validate()) \
		{ \
			RPC_ValidateFailed(TEXT("StartReloadServer_Validate")); \
			return; \
		} \
		this->StartReloadServer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopFireServer) \
	{ \
		P_FINISH; \
		if (!this->StopFireServer_Validate()) \
		{ \
			RPC_ValidateFailed(TEXT("StopFireServer_Validate")); \
			return; \
		} \
		this->StopFireServer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartFireServer) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		if (!this->StartFireServer_Validate(Z_Param_FireModeIndex)) \
		{ \
			RPC_ValidateFailed(TEXT("StartFireServer_Validate")); \
			return; \
		} \
		this->StartFireServer_Implementation(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execBlockedBy) \
	{ \
		P_GET_OBJECT(AActor,Z_Param_By); \
		P_GET_PROPERTY(UFloatProperty,Z_Param_BlockedDamage); \
		P_FINISH; \
		this->BlockedBy_Implementation(Z_Param_By,Z_Param_BlockedDamage); \
	} \
 \
	DECLARE_FUNCTION(execBlockDamage) \
	{ \
		P_GET_PROPERTY(UFloatProperty,Z_Param_Damage); \
		P_GET_STRUCT_REF(FDamageEvent,Z_Param_Out_DamageEvent); \
		P_GET_OBJECT(AController,Z_Param_EventInstigator); \
		P_GET_OBJECT(AActor,Z_Param_DamageCauser); \
		P_FINISH; \
		*(float*)Z_Param__Result=this->BlockDamage_Implementation(Z_Param_Damage,Z_Param_Out_DamageEvent,Z_Param_EventInstigator,Z_Param_DamageCauser); \
	} \
 \
	DECLARE_FUNCTION(execGetFireModeClass) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(TSubclassOf<UAdvKitFireModeConfiguration> *)Z_Param__Result=this->GetFireModeClass(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execHasFireMode) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->HasFireMode(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execReloadedTimer) \
	{ \
		P_FINISH; \
		this->ReloadedTimer(); \
	} \
 \
	DECLARE_FUNCTION(execStopReloadTimer) \
	{ \
		P_FINISH; \
		this->StopReloadTimer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReloadTimer) \
	{ \
		P_FINISH; \
		this->StartReloadTimer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execAddAmmunition) \
	{ \
		P_GET_PROPERTY(UIntProperty,Z_Param_Amount); \
		P_FINISH; \
		this->AddAmmunition_Implementation(Z_Param_Amount); \
	} \
 \
	DECLARE_FUNCTION(execReloadAmmunition) \
	{ \
		P_FINISH; \
		this->ReloadAmmunition_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopReloadInternal) \
	{ \
		P_FINISH; \
		this->StopReloadInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReloadInternal) \
	{ \
		P_FINISH; \
		this->StartReloadInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execCanReload) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->CanReload_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopFireInternal) \
	{ \
		P_FINISH; \
		this->StopFireInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartFireInternal) \
	{ \
		P_FINISH; \
		this->StartFireInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execCanFire) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->CanFire_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execAddSpread) \
	{ \
		P_GET_STRUCT(FRotator,Z_Param_OriginalAim); \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FRotator*)Z_Param__Result=this->AddSpread(Z_Param_OriginalAim,Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execGetAdjustedAim) \
	{ \
		P_GET_STRUCT(FVector,Z_Param_StartFireLocation); \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FRotator*)Z_Param__Result=this->GetAdjustedAim(Z_Param_StartFireLocation,Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execGetTraceStart) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FVector*)Z_Param__Result=this->GetTraceStart_Implementation(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execGetMuzzleLocation) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FVector*)Z_Param__Result=this->GetMuzzleLocation_Implementation(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execIsReloading) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsReloading(); \
	} \
 \
	DECLARE_FUNCTION(execIsFiring) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsFiring(); \
	} \
 \
	DECLARE_FUNCTION(execIsIdle) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsIdle(); \
	} \
 \
	DECLARE_FUNCTION(execHasAmmunitionInMagazine) \
	{ \
		P_GET_PROPERTY(UIntProperty,Z_Param_Amount); \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->HasAmmunitionInMagazine(Z_Param_Amount); \
	} \
 \
	DECLARE_FUNCTION(execHasAmmunition) \
	{ \
		P_GET_PROPERTY(UIntProperty,Z_Param_Amount); \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->HasAmmunition(Z_Param_Amount); \
	} \
 \
	DECLARE_FUNCTION(execIsMagazineEmpty) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsMagazineEmpty(); \
	} \
 \
	DECLARE_FUNCTION(execRefireTimer) \
	{ \
		P_FINISH; \
		this->RefireTimer(); \
	} \
 \
	DECLARE_FUNCTION(execStopRefireTimer) \
	{ \
		P_FINISH; \
		this->StopRefireTimer(); \
	} \
 \
	DECLARE_FUNCTION(execStartRefireTimer) \
	{ \
		P_GET_PROPERTY(UFloatProperty,Z_Param_Duration); \
		P_FINISH; \
		this->StartRefireTimer(Z_Param_Duration); \
	} \
 \
	DECLARE_FUNCTION(execFireCustom) \
	{ \
		P_FINISH; \
		this->FireCustom_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execFireProjectile) \
	{ \
		P_FINISH; \
		*(AAdvKitProjectile**)Z_Param__Result=this->FireProjectile_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execFireInstant) \
	{ \
		P_FINISH; \
		this->FireInstant_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execFireAmmunition) \
	{ \
		P_FINISH; \
		this->FireAmmunition_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execHandleFiringPrerequisites) \
	{ \
		P_FINISH; \
		this->HandleFiringPrerequisites_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execConsumeAmmunition) \
	{ \
		P_FINISH; \
		this->ConsumeAmmunition_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopReload) \
	{ \
		P_FINISH; \
		this->StopReload_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReload) \
	{ \
		P_FINISH; \
		this->StartReload_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopFire) \
	{ \
		P_FINISH; \
		this->StopFire_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartFire) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		this->StartFire_Implementation(Z_Param_FireModeIndex); \
	}


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_RPC_WRAPPERS_NO_PURE_DECLS \
	virtual bool StopReloadServer_Validate(); \
	virtual bool StartReloadServer_Validate(); \
	virtual bool StopFireServer_Validate(); \
	virtual bool StartFireServer_Validate(uint8 ); \
 \
	DECLARE_FUNCTION(execOnWeaponEmpty) \
	{ \
		P_FINISH; \
		this->OnWeaponEmpty_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnMagazineEmpty) \
	{ \
		P_FINISH; \
		this->OnMagazineEmpty_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnReloadEnd) \
	{ \
		P_FINISH; \
		this->OnReloadEnd_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnReloaded) \
	{ \
		P_FINISH; \
		this->OnReloaded_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnReloadBegin) \
	{ \
		P_FINISH; \
		this->OnReloadBegin_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnFireEnd) \
	{ \
		P_FINISH; \
		this->OnFireEnd_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnFireShot) \
	{ \
		P_FINISH; \
		this->OnFireShot_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnFireBegin) \
	{ \
		P_FINISH; \
		this->OnFireBegin_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execOnRep_WeaponState) \
	{ \
		P_GET_STRUCT(FAdvKitWeaponState,Z_Param_OldState); \
		P_FINISH; \
		this->OnRep_WeaponState(Z_Param_OldState); \
	} \
 \
	DECLARE_FUNCTION(execStopReloadServer) \
	{ \
		P_FINISH; \
		if (!this->StopReloadServer_Validate()) \
		{ \
			RPC_ValidateFailed(TEXT("StopReloadServer_Validate")); \
			return; \
		} \
		this->StopReloadServer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReloadServer) \
	{ \
		P_FINISH; \
		if (!this->StartReloadServer_Validate()) \
		{ \
			RPC_ValidateFailed(TEXT("StartReloadServer_Validate")); \
			return; \
		} \
		this->StartReloadServer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopFireServer) \
	{ \
		P_FINISH; \
		if (!this->StopFireServer_Validate()) \
		{ \
			RPC_ValidateFailed(TEXT("StopFireServer_Validate")); \
			return; \
		} \
		this->StopFireServer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartFireServer) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		if (!this->StartFireServer_Validate(Z_Param_FireModeIndex)) \
		{ \
			RPC_ValidateFailed(TEXT("StartFireServer_Validate")); \
			return; \
		} \
		this->StartFireServer_Implementation(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execBlockedBy) \
	{ \
		P_GET_OBJECT(AActor,Z_Param_By); \
		P_GET_PROPERTY(UFloatProperty,Z_Param_BlockedDamage); \
		P_FINISH; \
		this->BlockedBy_Implementation(Z_Param_By,Z_Param_BlockedDamage); \
	} \
 \
	DECLARE_FUNCTION(execBlockDamage) \
	{ \
		P_GET_PROPERTY(UFloatProperty,Z_Param_Damage); \
		P_GET_STRUCT_REF(FDamageEvent,Z_Param_Out_DamageEvent); \
		P_GET_OBJECT(AController,Z_Param_EventInstigator); \
		P_GET_OBJECT(AActor,Z_Param_DamageCauser); \
		P_FINISH; \
		*(float*)Z_Param__Result=this->BlockDamage_Implementation(Z_Param_Damage,Z_Param_Out_DamageEvent,Z_Param_EventInstigator,Z_Param_DamageCauser); \
	} \
 \
	DECLARE_FUNCTION(execGetFireModeClass) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(TSubclassOf<UAdvKitFireModeConfiguration> *)Z_Param__Result=this->GetFireModeClass(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execHasFireMode) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->HasFireMode(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execReloadedTimer) \
	{ \
		P_FINISH; \
		this->ReloadedTimer(); \
	} \
 \
	DECLARE_FUNCTION(execStopReloadTimer) \
	{ \
		P_FINISH; \
		this->StopReloadTimer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReloadTimer) \
	{ \
		P_FINISH; \
		this->StartReloadTimer_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execAddAmmunition) \
	{ \
		P_GET_PROPERTY(UIntProperty,Z_Param_Amount); \
		P_FINISH; \
		this->AddAmmunition_Implementation(Z_Param_Amount); \
	} \
 \
	DECLARE_FUNCTION(execReloadAmmunition) \
	{ \
		P_FINISH; \
		this->ReloadAmmunition_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopReloadInternal) \
	{ \
		P_FINISH; \
		this->StopReloadInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReloadInternal) \
	{ \
		P_FINISH; \
		this->StartReloadInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execCanReload) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->CanReload_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopFireInternal) \
	{ \
		P_FINISH; \
		this->StopFireInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartFireInternal) \
	{ \
		P_FINISH; \
		this->StartFireInternal_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execCanFire) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->CanFire_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execAddSpread) \
	{ \
		P_GET_STRUCT(FRotator,Z_Param_OriginalAim); \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FRotator*)Z_Param__Result=this->AddSpread(Z_Param_OriginalAim,Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execGetAdjustedAim) \
	{ \
		P_GET_STRUCT(FVector,Z_Param_StartFireLocation); \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FRotator*)Z_Param__Result=this->GetAdjustedAim(Z_Param_StartFireLocation,Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execGetTraceStart) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FVector*)Z_Param__Result=this->GetTraceStart_Implementation(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execGetMuzzleLocation) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		*(FVector*)Z_Param__Result=this->GetMuzzleLocation_Implementation(Z_Param_FireModeIndex); \
	} \
 \
	DECLARE_FUNCTION(execIsReloading) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsReloading(); \
	} \
 \
	DECLARE_FUNCTION(execIsFiring) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsFiring(); \
	} \
 \
	DECLARE_FUNCTION(execIsIdle) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsIdle(); \
	} \
 \
	DECLARE_FUNCTION(execHasAmmunitionInMagazine) \
	{ \
		P_GET_PROPERTY(UIntProperty,Z_Param_Amount); \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->HasAmmunitionInMagazine(Z_Param_Amount); \
	} \
 \
	DECLARE_FUNCTION(execHasAmmunition) \
	{ \
		P_GET_PROPERTY(UIntProperty,Z_Param_Amount); \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->HasAmmunition(Z_Param_Amount); \
	} \
 \
	DECLARE_FUNCTION(execIsMagazineEmpty) \
	{ \
		P_FINISH; \
		*(bool*)Z_Param__Result=this->IsMagazineEmpty(); \
	} \
 \
	DECLARE_FUNCTION(execRefireTimer) \
	{ \
		P_FINISH; \
		this->RefireTimer(); \
	} \
 \
	DECLARE_FUNCTION(execStopRefireTimer) \
	{ \
		P_FINISH; \
		this->StopRefireTimer(); \
	} \
 \
	DECLARE_FUNCTION(execStartRefireTimer) \
	{ \
		P_GET_PROPERTY(UFloatProperty,Z_Param_Duration); \
		P_FINISH; \
		this->StartRefireTimer(Z_Param_Duration); \
	} \
 \
	DECLARE_FUNCTION(execFireCustom) \
	{ \
		P_FINISH; \
		this->FireCustom_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execFireProjectile) \
	{ \
		P_FINISH; \
		*(AAdvKitProjectile**)Z_Param__Result=this->FireProjectile_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execFireInstant) \
	{ \
		P_FINISH; \
		this->FireInstant_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execFireAmmunition) \
	{ \
		P_FINISH; \
		this->FireAmmunition_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execHandleFiringPrerequisites) \
	{ \
		P_FINISH; \
		this->HandleFiringPrerequisites_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execConsumeAmmunition) \
	{ \
		P_FINISH; \
		this->ConsumeAmmunition_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopReload) \
	{ \
		P_FINISH; \
		this->StopReload_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartReload) \
	{ \
		P_FINISH; \
		this->StartReload_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStopFire) \
	{ \
		P_FINISH; \
		this->StopFire_Implementation(); \
	} \
 \
	DECLARE_FUNCTION(execStartFire) \
	{ \
		P_GET_PROPERTY(UByteProperty,Z_Param_FireModeIndex); \
		P_FINISH; \
		this->StartFire_Implementation(Z_Param_FireModeIndex); \
	}


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_EVENT_PARMS \
	struct AdvKitWeapon_eventAddAmmunition_Parms \
	{ \
		int32 Amount; \
	}; \
	struct AdvKitWeapon_eventBlockDamage_Parms \
	{ \
		float Damage; \
		FDamageEvent DamageEvent; \
		AController* EventInstigator; \
		AActor* DamageCauser; \
		float ReturnValue; \
 \
		/** Constructor, intializes return property only **/ \
		AdvKitWeapon_eventBlockDamage_Parms() \
			: ReturnValue(0) \
		{ \
		} \
	}; \
	struct AdvKitWeapon_eventBlockedBy_Parms \
	{ \
		AActor* By; \
		float BlockedDamage; \
	}; \
	struct AdvKitWeapon_eventCanFire_Parms \
	{ \
		bool ReturnValue; \
 \
		/** Constructor, intializes return property only **/ \
		AdvKitWeapon_eventCanFire_Parms() \
			: ReturnValue(false) \
		{ \
		} \
	}; \
	struct AdvKitWeapon_eventCanReload_Parms \
	{ \
		bool ReturnValue; \
 \
		/** Constructor, intializes return property only **/ \
		AdvKitWeapon_eventCanReload_Parms() \
			: ReturnValue(false) \
		{ \
		} \
	}; \
	struct AdvKitWeapon_eventFireProjectile_Parms \
	{ \
		AAdvKitProjectile* ReturnValue; \
 \
		/** Constructor, intializes return property only **/ \
		AdvKitWeapon_eventFireProjectile_Parms() \
			: ReturnValue(NULL) \
		{ \
		} \
	}; \
	struct AdvKitWeapon_eventGetMuzzleLocation_Parms \
	{ \
		uint8 FireModeIndex; \
		FVector ReturnValue; \
 \
		/** Constructor, intializes return property only **/ \
		AdvKitWeapon_eventGetMuzzleLocation_Parms() \
			: ReturnValue(ForceInit) \
		{ \
		} \
	}; \
	struct AdvKitWeapon_eventGetTraceStart_Parms \
	{ \
		uint8 FireModeIndex; \
		FVector ReturnValue; \
 \
		/** Constructor, intializes return property only **/ \
		AdvKitWeapon_eventGetTraceStart_Parms() \
			: ReturnValue(ForceInit) \
		{ \
		} \
	}; \
	struct AdvKitWeapon_eventStartFire_Parms \
	{ \
		uint8 FireModeIndex; \
	}; \
	struct AdvKitWeapon_eventStartFireServer_Parms \
	{ \
		uint8 FireModeIndex; \
	};


extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_AddAmmunition;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_BlockDamage;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_BlockedBy;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_CanFire;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_CanReload;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_ConsumeAmmunition;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_FireAmmunition;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_FireCustom;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_FireInstant;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_FireProjectile;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_GetMuzzleLocation;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_GetTraceStart;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_HandleFiringPrerequisites;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnFireBegin;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnFireEnd;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnFireShot;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnMagazineEmpty;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnReloadBegin;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnReloaded;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnReloadEnd;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_OnWeaponEmpty;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_ReloadAmmunition;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartFire;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartFireInternal;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartFireServer;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartReload;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartReloadInternal;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartReloadServer;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StartReloadTimer;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopFire;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopFireInternal;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopFireServer;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopReload;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopReloadInternal;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopReloadServer;
extern ADVKITRUNTIME_API  FName ADVKITRUNTIME_StopReloadTimer;
#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_CALLBACK_WRAPPERS
#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_INCLASS_NO_PURE_DECLS \
	private: \
	static void StaticRegisterNativesAAdvKitWeapon(); \
	friend ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitWeapon(); \
	public: \
	DECLARE_CLASS(AAdvKitWeapon, AAdvKitInventoryItem, COMPILED_IN_FLAGS(CLASS_Abstract), 0, TEXT("/Script/AdvKitRuntime"), NO_API) \
	DECLARE_SERIALIZER(AAdvKitWeapon) \
	/** Indicates whether the class is compiled into the engine */ \
	enum {IsIntrinsic=COMPILED_IN_INTRINSIC}; \
	void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_INCLASS \
	private: \
	static void StaticRegisterNativesAAdvKitWeapon(); \
	friend ADVKITRUNTIME_API class UClass* Z_Construct_UClass_AAdvKitWeapon(); \
	public: \
	DECLARE_CLASS(AAdvKitWeapon, AAdvKitInventoryItem, COMPILED_IN_FLAGS(CLASS_Abstract), 0, TEXT("/Script/AdvKitRuntime"), NO_API) \
	DECLARE_SERIALIZER(AAdvKitWeapon) \
	/** Indicates whether the class is compiled into the engine */ \
	enum {IsIntrinsic=COMPILED_IN_INTRINSIC}; \
	void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_STANDARD_CONSTRUCTORS \
	/** Standard constructor, called after all reflected properties have been initialized */ \
	NO_API AAdvKitWeapon(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()); \
	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(AAdvKitWeapon) \
	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, AAdvKitWeapon); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AAdvKitWeapon); \
private: \
	/** Private copy-constructor, should never be used */ \
	NO_API AAdvKitWeapon(const AAdvKitWeapon& InCopy); \
public:


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_ENHANCED_CONSTRUCTORS \
private: \
	/** Private copy-constructor, should never be used */ \
	NO_API AAdvKitWeapon(const AAdvKitWeapon& InCopy); \
public: \
	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, AAdvKitWeapon); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AAdvKitWeapon); \
	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(AAdvKitWeapon)


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_81_PROLOG \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_EVENT_PARMS


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_GENERATED_BODY_LEGACY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_RPC_WRAPPERS \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_CALLBACK_WRAPPERS \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_INCLASS \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_STANDARD_CONSTRUCTORS \
public: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS


#define projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_GENERATED_BODY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_RPC_WRAPPERS_NO_PURE_DECLS \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_CALLBACK_WRAPPERS \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_INCLASS_NO_PURE_DECLS \
	projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h_84_ENHANCED_CONSTRUCTORS \
private: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS


#undef CURRENT_FILE_ID
#define CURRENT_FILE_ID projectvelorum_Plugins_AdvKitPlugin_Source_AdvKitRuntime_Classes_Items_AdvKitWeapon_h


#define FOREACH_ENUM_EADVKITWEAPONSTATE(op) \
	op(EAdvKitWeaponState::Idle) \
	op(EAdvKitWeaponState::Firing) \
	op(EAdvKitWeaponState::Reloading) 
PRAGMA_ENABLE_DEPRECATION_WARNINGS
